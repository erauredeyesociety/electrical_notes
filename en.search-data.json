{"/electrical_notes/about/":{"data":{"about-this-site#About This Site":"About This SiteClass notes basically"},"title":"about"},"/electrical_notes/cs_420/ass1_ass2_topics/":{"data":{"1-contiguous-allocation#1. Contiguous Allocation":"Description: Each process occupies a single contiguous section of memory.\nHardware Support:\nBase register - Smallest physical address accessible by process Limit register - Range of logical addresses CPU compares every address against these registers for protection Assessment:\nAdvantage: Simple, fast access Problem: External fragmentation - total free memory exists but is scattered in small holes","1-fifo-first-in-first-out#1. FIFO (First-In-First-Out)":"Description: Replace the page that has been in memory the longest (oldest).\nAssessment:\nAdvantage: Simple to implement Problem: Belady’s Anomaly - increasing the number of frames can sometimes increase the page fault rate Poor performance; may replace frequently used pages","1-first-come-first-served-fcfs#1. First-Come, First-Served (FCFS)":"Description: Processes are served in arrival order using a FIFO queue. Nonpreemptive.\nMust be nonpreemptive? Yes, FCFS is always nonpreemptive.\nAssessment:\nAdvantage: Simple to implement Disadvantage: Convoy effect - short processes get stuck behind long processes, causing high average waiting time Disk scheduling disadvantage: Long waits because head position is ignored","1-functions-of-an-operating-system#1. Functions of an Operating System":"","1-mutex-locks#1. Mutex Locks":"Description: Simplest synchronization tool. A binary lock that protects a critical section.\nOperations:\nacquire() - Obtain the lock before entering CS release() - Release the lock when exiting CS Assessment:\nAdvantage: Simple concept Disadvantage: Requires busy waiting (spinlock) - process loops waiting for lock, wasting CPU cycles Both operations must be atomic (indivisible)","1-round-robin-rr#1. Round Robin (RR)":"Parameters: Time quantum (given)\nAlgorithm:\nMaintain FIFO ready queue Add arriving processes to queue in arrival order Execute front process for quantum or until completion If quantum expires, preempt and add to end of queue Repeat until all processes complete Special Cases:\nProcess completes before quantum expires Multiple processes arrive at same time (add in input order)","1-simple-structure-ms-dos#1. Simple Structure (MS-DOS)":"Characteristics:\nNot divided into modules Interfaces and functionality not well separated Application programs can access basic I/O routines and hardware directly Assessment:\nSimple to implement initially Poor protection and reliability Difficult to maintain and extend","10-virtual-memory-management#10. Virtual Memory Management":"","11-storage-systems-and-file-systems#11. Storage Systems and File Systems":"","12-os-design-and-implementation#12. OS Design and Implementation":"","13-assignment-1---shared-memory-producer-consumer#13. Assignment 1 - Shared Memory Producer-Consumer":"","14-assignment-2---cpu-scheduling-simulation#14. Assignment 2 - CPU Scheduling Simulation":"","15-quick-reference-tables#15. Quick Reference Tables":"","16-common-exam-question-patterns#16. Common Exam Question Patterns":"","2-interrupt-handling#2. Interrupt Handling":"","2-optimal-opt#2. Optimal (OPT)":"Description: Replace the page that will not be used for the longest period of time in the future.\nAssessment:\nAdvantage: Lowest possible page fault rate Disadvantage: Impossible to implement (requires predicting future) Used only as a theoretical benchmark for comparison","2-segmentation#2. Segmentation":"Description: Memory management scheme supporting the user’s view of memory. A program is a collection of logical units (segments): main program, procedures, functions, stack, heap, etc.\nLogical Address: Two-dimensional: Segment Table: Maps segment numbers to physical base addresses and limit (length).\nAssessment:\nAdvantage: Matches logical structure of programs; can share/protect segments independently Problem: Still suffers from external fragmentation (segments vary in size)","2-semaphores#2. Semaphores":"Description: An integer variable S accessed only through two atomic operations:\nwait(S) or P(S) - Decrement; wait if value becomes negative signal(S) or V(S) - Increment; may wake a waiting process Types:\nBinary Semaphore:\nRange: 0 or 1 Equivalent to a mutex lock Used for mutual exclusion Counting Semaphore:\nRange: unrestricted integer domain Can control access to a resource with a finite number of instances Initial value = number of available resources Can counting semaphores control access to resources with finite instances? Yes - initialize the semaphore to the number of available resources. Each wait() consumes one resource; each signal() releases one.\nImplementation Without Busy Waiting: Use a waiting queue to store blocked processes. When a process must wait, it’s placed in the queue and its state becomes waiting. When signal() is called, a process from the queue is awakened and moved to the ready queue.\nSemaphores vs. Mutex Locks:\nSemaphores are more general (counting vs. binary) Semaphores can be used for synchronization beyond mutual exclusion Mutex is simpler, semantically clearer for mutual exclusion","2-shortest-job-first-sjf#2. Shortest-Job-First (SJF)":"Description: Schedules the process with the shortest next CPU burst. Burst length can be predicted using exponential averaging of past bursts.\nAssessment:\nAdvantage: Optimal - gives minimum average waiting time for a given set of processes Disadvantage: Difficulty predicting the length of the next CPU burst Problem: Can cause starvation of longer processes","2-shortest-job-first-sjf---non-preemptive#2. Shortest Job First (SJF) - Non-preemptive":"Algorithm:\nScheduling decisions only when current process terminates Select process from ready queue with shortest CPU burst Ties broken by arrival time (FCFS) Execute selected process to completion Key: Once a process starts, it runs to completion (non-preemptive).","2-traditional-unix#2. Traditional UNIX":"Characteristics:\nLimited structuring Two layers: system programs and the kernel The kernel is everything below the system-call interface and above hardware Monolithic kernel with all services in kernel space Assessment:\nEfficient (everything in kernel, no message passing overhead) Difficult to maintain and extend Poor isolation between kernel components","3-bootstrapping-and-system-calls#3. Bootstrapping and System Calls":"","3-least-recently-used-lru#3. Least Recently Used (LRU)":"Description: Replace the page that has not been used for the longest time in the past. Uses past behavior to predict future behavior.\nAssessment:\nAdvantage: Generally excellent performance; does not suffer from Belady’s Anomaly Disadvantage: Requires expensive hardware support to track page usage times (counters or stack for every memory reference) Considered one of the best practical algorithms","3-microkernel#3. Microkernel":"Characteristics:\nMoves as much functionality as possible out of kernel into user space Minimal kernel: IPC, basic scheduling, low-level memory management Services communicate via message passing How do microkernels handle communication? Through message passing - services send messages to each other through the kernel’s IPC mechanism.\nAssessment:\nAdvantages: Easier to extend (add services in user space) Easier to port to new hardware More reliable (service failures don’t crash kernel) More secure (less code in privileged mode) Disadvantages: Performance overhead due to message passing and user/kernel space transitions","3-monitors#3. Monitors":"Description: A high-level abstraction (Abstract Data Type) providing a convenient and effective process synchronization mechanism. Only one process can be active within the monitor at any time.\nCondition Variables: Used to suspend and resume processes within the monitor:\nx.wait() - Suspend the calling process x.signal() - Resume one waiting process Assessment:\nAdvantage: Easier to ensure correctness than semaphores; mutual exclusion built-in Disadvantage: Not as widely supported; requires language/compiler support","3-paging#3. Paging":"Description: Physical address space can be noncontiguous, eliminating external fragmentation. Physical memory divided into fixed-size frames; logical memory divided into same-size pages.\nAddress Translation: Logical address: Page table maps page number to frame number Physical address: Calculating Page Number: Given logical address and page size, page number = logical address / page size (integer division).\nExample: Logical address 3085, page size 1024: Page number = 3085 / 1024 = 3\nTranslation Look-aside Buffer (TLB): A fast associative memory cache holding recent page table entries. Speeds up address translation since page tables are typically in main memory.\nHow does TLB assist translation? TLB stores recent page-to-frame mappings. On a memory reference, the TLB is searched first (in parallel). If found (TLB hit), the frame number is immediately available. If not (TLB miss), the page table must be accessed in main memory.\nAssessment:\nAdvantage: No external fragmentation; easy to allocate memory Problem: Internal fragmentation - allocated memory may be slightly larger than requested (last page may not be full)","3-priority-scheduling---no-preemption#3. Priority Scheduling - No Preemption":"Algorithm:\nScheduling decisions only when current process terminates Select process from ready queue with highest priority (smallest number) Ties broken arbitrarily Execute selected process to completion","3-shortest-remaining-time-first-srtf#3. Shortest-Remaining-Time-First (SRTF)":"Description: Preemptive version of SJF. When a new process arrives with a shorter burst time than the remaining time of the currently running process, the current process is preempted.\nAssessment:\nOptimal for preemptive scenarios High context switch overhead","4-hybrid-systems#4. Hybrid Systems":"Characteristics: Most modern OSs combine multiple approaches for practical reasons.\nExamples:\nLinux/Solaris: Monolithic kernel with loadable modules Mac OS X: Mach microkernel foundation + BSD UNIX components + other layers Windows: Modular monolithic kernel with some microkernel concepts","4-lru-approximation-second-chance-clock#4. LRU Approximation (Second-Chance, Clock)":"Description: Uses a reference bit for each page. When a page is referenced, its bit is set to 1. For replacement:\nExamine pages in FIFO order If reference bit = 0, replace this page If reference bit = 1, clear it to 0 and check next oldest page Give each page a “second chance” Assessment:\nAdvantage: Efficient approximation of LRU without expensive hardware Disadvantage: Not as effective as true LRU Widely used in practice","4-priority-scheduling#4. Priority Scheduling":"Description: CPU allocated based on priority number (typically smallest integer = highest priority). Can be preemptive or nonpreemptive.\nPreemption Variants:\nPR noPREMP (Assignment 2): Scheduling only on termination; select highest priority ready process PR withPREMP (Assignment 2): Also schedule when higher priority process arrives, preempting current process Assessment:\nAdvantage: Important tasks get CPU time Problem: Starvation - low-priority processes may never execute Solution: Aging - gradually increase the priority of processes waiting a long time What is Starvation? A situation where a process waits indefinitely because other processes continually receive preference.\nHow does Aging prevent it? By increasing a process’s priority as it waits longer, aging eventually makes every waiting process competitive for CPU time.","4-priority-scheduling---with-preemption#4. Priority Scheduling - With Preemption":"Algorithm:\nScheduling decisions on termination OR when higher priority arrives When new process arrives: If its priority \u003e current process priority, preempt current process Add preempted process back to ready queue Select highest priority ready process Execute until completion or preemption Key Difference: Can interrupt running process if higher priority arrives.","4-process-management#4. Process Management":"","5-round-robin-rr#5. Round Robin (RR)":"Description: Each process gets a small time quantum (typically 10-100 milliseconds). After the quantum expires, the process is preempted and added to the end of the ready queue (circular FIFO).\nAssignment 2 specifics: Processes added to queue in arrival order; if quantum expires, go to end of queue.\nAssessment:\nAdvantage: Good response time, fair Disadvantage: High overhead if quantum too small (relative to context switch time) If quantum too large, behaves like FCFS","5-thread-management#5. Thread Management":"","6-cpu-scheduling#6. CPU Scheduling":"","6-multilevel-feedback-queue#6. Multilevel Feedback Queue":"Description: Multiple ready queues with different priorities. Processes can move between queues based on CPU behavior.\nTypical Configuration:\nHigh-priority queues use RR with small quanta (interactive jobs) Low-priority queues use RR with large quanta or FCFS (CPU-bound jobs) Assessment:\nAdvantage: Aging easily implemented; adapts to process behavior Disadvantage: Highly configurable but complex to tune","7-concurrency-and-synchronization#7. Concurrency and Synchronization":"","8-deadlocks#8. Deadlocks":"","9-memory-management-real-memory#9. Memory Management (Real Memory)":"","address-binding#Address Binding":"When are symbolic addresses bound to physical addresses?\nThree Binding Times:\nCompile Time If memory location is known at compile time, absolute code is generated. Must recompile if starting location changes.\nLoad Time If memory location is unknown at compile time, compiler generates relocatable code. Binding occurs when the program is loaded.\nExecution Time Binding delayed until runtime if process can move during execution. Requires hardware support (base/limit registers). Most general-purpose OSs use execution time binding for flexibility.","algorithms-to-implement#Algorithms to Implement":"","allocation-methods#Allocation Methods":"Linked Allocation: Each file is a linked list of disk blocks scattered anywhere on the disk.\nWhy is the entire block unavailable to the user? Part of each block must be reserved for the pointer to the next block in the chain. If blocks are 512 bytes, and pointers are 4 bytes, only 508 bytes are available for user data per block.","assignment-1-success-factors#Assignment 1 Success Factors":"[CHECK] Understand circular buffer logic [CHECK] Check full/empty conditions correctly [CHECK] Use provided functions exclusively [CHECK] Handle synchronization with shared variables [CHECK] Test with various buffer sizes and item counts","assignment-2-success-factors#Assignment 2 Success Factors":"[CHECK] Implement event-driven simulation [CHECK] Use appropriate data structures for each algorithm [CHECK] Handle tie-breaking consistently [CHECK] Track all timing information accurately [CHECK] Test with edge cases (simultaneous arrivals, process completion timing) [CHECK] Verify calculations match algorithm specifications\nEnd of Study Guide","bootstrap-process#Bootstrap Process":"What is a Bootstrap Program? A small piece of code that initializes the system when the computer is powered on or rebooted. It locates and loads the operating system kernel into memory.\nWhere is it stored? In ROM (Read-Only Memory), EPROM (Erasable Programmable ROM), or firmware. This non-volatile storage ensures the bootstrap code is always available at startup.","bounded-buffer-producer-consumer#Bounded-Buffer (Producer-Consumer)":"Problem: Producer creates items and places them in a bounded buffer. Consumer removes items. Buffer has limited capacity.\nSolution Using Semaphores (Assignment 1 Concept):\nSemaphores: - mutex = 1 // Mutual exclusion for buffer access - empty = n // Count of empty slots - full = 0 // Count of full slots Producer: wait(empty) // Wait if buffer full wait(mutex) // Enter critical section [add item to buffer] signal(mutex) // Exit critical section signal(full) // Signal item added Consumer: wait(full) // Wait if buffer empty wait(mutex) // Enter critical section [remove item from buffer] signal(mutex) // Exit critical section signal(empty) // Signal slot freed Assignment 1 Specifics:\nUses shared memory instead of semaphores Must manage in and out pointers to track buffer positions Detect full: (in + 1) % bufSize == out Detect empty: in == out Use provided functions: GetIn(), SetIn(), GetOut(), SetOut(), WriteAtBufIndex(), ReadAtBufIndex() Structural Changes Analysis: If producer/consumer logic changes (e.g., different wait conditions, modified pointer management), analyze:\nWhat condition causes blocking? Does the new structure maintain mutual exclusion? Can deadlock or starvation occur?","calculation-problems#Calculation Problems":"1. Page Number from Logical Address:\nPage number = logical_address / page_size (integer division) Offset = logical_address % page_size 2. Context Switch Time with Swapping:\nTotal time = 2 \\times (swap_out_time + swap_in_time) + actual_context_switch Swap time = (process_size / transfer_rate) + latency 3. Effective Access Time:\nEAT = (1 - p) \\times mem_access + p \\times page_fault_time","conceptual-questions#Conceptual Questions":"Operating System as Government: Creates environment for programs to work; manages resources; doesn’t do productive work itself.\nItems Shared by Threads: Code, data, files. Each thread has its own: PC, registers, stack.\nWhy Google Chrome Uses Multiple Processes: Isolation for stability and security; tab/plugin crashes don’t affect others.\nAging Purpose: Prevents starvation by gradually increasing priority of waiting processes.\nThrashing: Excessive paging; process doesn’t have enough frames for working set; CPU utilization drops.","concurrency-vs-parallelism#Concurrency vs. Parallelism":"Concurrency: Multiple tasks making progress, typically by multiplexing CPU time (time-sharing). Possible on a single-processor system.\nParallelism: Multiple tasks executing simultaneously, requires multi-core or multi-processor hardware.\nWhich term describes multiple tasks making progress on a single processor? Concurrency - tasks interleave execution through time-slicing.","core-roles#Core Roles":"Resource Allocator The OS manages all system resources (CPU time, memory space, file storage, I/O devices) and mediates between conflicting requests to ensure efficient and fair usage.\nControl Program Controls program execution to prevent errors and improper computer use, maintaining system integrity and security.","cpu-mode-switching#CPU Mode Switching":"User Mode - Limited instruction set; cannot execute privileged operations Kernel Mode - Full access to all hardware and memory; can execute any instruction\nThe mode bit prevents user programs from interfering with OS operations or other users’ programs.","critical-section-problem#Critical Section Problem":"Critical Section (CS): A segment of code where a process accesses shared resources that must not be accessed by other processes concurrently.\nThree Requirements for a Solution:\nMutual Exclusion If process Pi is executing in its critical section, no other process can execute in their critical sections.\nProgress If no process is in the CS and some processes wish to enter, the selection of the next process cannot be postponed indefinitely. Only processes not in their remainder section can participate in the decision.\nBounded Waiting A limit must exist on the number of times other processes can enter their CS after a process requests entry and before that request is granted. Prevents starvation.\nRelationship: All three are necessary. Mutual exclusion alone could cause deadlock. Progress without bounded waiting could cause starvation. All three together ensure correct, fair synchronization.","deadlock-characterization#Deadlock Characterization":"What is Deadlock? A situation where a set of processes are blocked, each waiting for a resource held by another process in the set. No process can proceed.","deadlock-handling-methods#Deadlock Handling Methods":"Three General Approaches:\nPrevention Ensure at least one of the four necessary conditions cannot hold. Design system to make deadlock impossible.\nAvoidance Dynamically examine resource allocation state; only grant requests that keep the system in a safe state. Requires advance knowledge of resource needs.\nDetection and Recovery / Ignoring Allow deadlocks to occur, then detect and recover. Or ignore (ostrich algorithm) if deadlocks are rare.","deadlock-prevention-protocols#Deadlock Prevention Protocols":"Preventing Hold-and-Wait:\nProtocol 1: Require processes to request and be allocated all resources before execution begins Protocol 2: Allow processes to request resources only when they have none (must release all current resources before requesting new ones) Assessment: Both cause low resource utilization and potential starvation.","demand-paging#Demand Paging":"Description: A page is brought into memory only when it is needed (referenced during execution). The opposite is bringing the entire program into memory at load time.\nWhen is a page loaded? Only when needed during execution - specifically, when a page fault occurs referencing that page.\nValid-Invalid Bit: Each page table entry has a bit:\nValid (v) - Page is in memory (legal and in physical memory) Invalid (i) - Page is not in memory (either illegal or legal but not currently loaded) Page Fault Sequence:\nReference to invalid page causes a trap to OS (page fault) OS checks internal table: invalid reference (abort) or page not in memory? If valid reference, find a free frame Schedule disk operation to read page into frame Update page table (set bit to valid) Restart instruction that caused the page fault Assessment:\nAdvantage: Reduced memory requirements, faster program startup, more concurrent processes Disadvantage: Requires hardware support (page table with valid bit); slow page fault service time","demand-paging-vs-paging-with-swapping#Demand Paging vs. Paging with Swapping":"Demand Paging: Pages are loaded from disk only when referenced (lazy loading). Pages may never be swapped back to disk unless the frame is needed.\nPaging with Swapping: Entire processes can be swapped out to disk to free memory. When swapped back in, all pages return to memory. More aggressive memory management.\nKey Distinction: Demand paging is page-level and on-demand; swapping is process-level and typically involves all pages.","design-principles#Design Principles":"","dining-philosophers-problem#Dining Philosophers Problem":"Monitor Solution Starvation Scenario: A philosopher could starve if their neighbors continually acquire resources before them. For instance, if philosophers 0 and 2 keep eating, philosopher 1 may never get both chopsticks.","disk-scheduling#Disk Scheduling":"","disk-scheduling-algorithms#Disk Scheduling Algorithms":"FCFS (First-Come, First-Served):\nDescription: Services requests in arrival order Characteristic: Ignores current head position Disadvantage: Can result in long waits and inefficient head movement (wild swings across disk) Other Algorithms (SSTF, SCAN, C-SCAN, LOOK, C-LOOK): Consider head position to minimize seek time and improve throughput.","effective-access-time-eat#Effective Access Time (EAT)":"Performance of demand paging depends critically on the page fault rate (p).\nFormula:\nEAT = (1 - p) \\times memory_access_time + p \\times page_fault_service_time Example:\nMemory access: 200 ns Page fault service (including disk I/O): 8 ms = 8,000,000 ns If p = 0.001 (one fault per 1000 accesses): EAT = 0.999 \\times 200 + 0.001 \\times 8,000,000 = 199.8 + 8,000 = 8,199.8 ns Performance is 40\\times slower than memory access! The page fault rate must be very small for acceptable performance.","factors-influencing-algorithm-selection#Factors Influencing Algorithm Selection":"Request arrival patterns File allocation methods Disk load Required response time characteristics Fairness vs. efficiency trade-offs","file-system-implementation#File System Implementation":"","four-major-benefits-of-multithreading#Four Major Benefits of Multithreading":"1. Responsiveness Allows a program to continue running even if part of it is blocked. Critical for user interfaces - one thread can handle user input while another performs lengthy computation.\n2. Resource Sharing Threads automatically share the memory and resources of their parent process. This is simpler and more efficient than implementing shared memory or message passing between separate processes.\n3. Economy Thread creation and management is “lightweight” compared to “heavy-weight” process creation. Creating a thread is typically 10-100 times faster than creating a process. Context switching between threads of the same process is also much cheaper than process context switching.\n4. Scalability A multithreaded process can take advantage of multiprocessor architectures, with threads running in parallel on different cores. This enables true parallelism on multicore systems.","four-necessary-conditions-for-deadlock#Four Necessary Conditions for Deadlock":"Deadlock can occur only if all four conditions hold simultaneously:\nMutual Exclusion At least one resource must be nonsharable (only one process can use it at a time).\nHold and Wait A process must be holding at least one resource and waiting to acquire additional resources currently held by other processes.\nNo Preemption Resources cannot be forcibly taken away; they can only be released voluntarily by the process holding them after it completes its task.\nCircular Wait A closed chain of processes exists, where each process holds at least one resource needed by the next process in the chain.\nBreaking any one condition prevents deadlock.","fragmentation#Fragmentation":"External Fragmentation: Total free memory exists to satisfy a request, but it is scattered in non-contiguous small blocks. Occurs with variable-sized partitions (contiguous allocation, segmentation).\nInternal Fragmentation: Allocated memory is slightly larger than requested. The extra memory, internal to a partition, is not used. Occurs with fixed-sized partitions (paging).","implementation-considerations#Implementation Considerations":"Event-driven simulation - Process events in time order (arrivals, completions, quantum expirations) Ready queue management - Different data structures for different algorithms (FIFO queue, priority queue, sorted list) Context switching - Track when processes start/stop Tie-breaking - Be consistent with specified rules Edge cases - Multiple simultaneous events, idle CPU time","implementation-tips#Implementation Tips":"Always check buffer full/empty before producing/consuming Use modulo arithmetic for circular buffer indices Produce/consume one item at a time Update in/out pointers after each operation Handle the case where itemCnt items have been processed","input-format#Input Format":"Each process has:\nArrival time CPU burst length Priority (for priority scheduling) Process ID","interprocess-communication-ipc#Interprocess Communication (IPC)":"Cooperating processes need mechanisms to share information. Two fundamental models:\n1. Shared Memory\nProcesses share a region of memory Fast (no kernel intervention after setup) Requires synchronization by processes themselves Used in Assignment 1 for bounded buffer 2. Message Passing\nProcesses communicate by sending/receiving messages through the kernel Slower (kernel mediation for each message) Easier to implement, especially for distributed systems No synchronization conflicts","interrupt-handling-sequence#Interrupt Handling Sequence":"Interrupt Trigger\nAn I/O device controller signals completion by causing a hardware interrupt OR a trap/exception occurs from an error or system call Control Transfer\nCPU stops current execution Control transfers to the interrupt service routine (ISR) Transfer uses the interrupt vector - a table containing memory addresses of all service routines State Preservation\nThe address of the interrupted instruction is saved CPU registers and process state are saved to allow resumption later Kernel Mode Entry\nIf the interrupt is a system call requesting OS services, the mode bit changes to kernel mode (supervisor mode) This allows execution of privileged instructions that user programs cannot execute Service Routine Execution\nThe CPU executes the appropriate service routine based on the interrupt type The routine handles the event (service I/O, respond to system call, handle error) Return to User Mode\nAfter handling the interrupt, the mode bit changes back to user mode Execution resumes from the saved instruction address The system returns control to the interrupted process","items-shared-among-threads#Items Shared Among Threads":"Threads of the same process share:\nCode section (text) Data section (global variables) Open files and other OS resources Heap memory Each thread has its own:\nProgram counter Register set Stack (for local variables and function calls)","key-components#Key Components":"","key-operating-system-services#Key Operating System Services":"Service Description User Interface Provides CLI, GUI, or Batch interfaces for user interaction Program Execution Loads programs into memory, executes them, handles termination (normal or error) I/O Operations Manages I/O device operations, file access, and device communication File-System Manipulation Enables reading, writing, creating, deleting files; managing directories and permissions Communications (IPC) Allows processes to exchange information via shared memory or message passing Error Detection Constantly monitors for hardware/software errors and takes corrective action Resource Allocation Distributes CPU cycles, memory, storage, and I/O among concurrent processes Protection \u0026 Security Controls resource access and defends against unauthorized external access","key-takeaways-for-assignments#Key Takeaways for Assignments":"","memory-allocation-schemes#Memory Allocation Schemes":"","memory-management-comparison#Memory Management Comparison":"Scheme Fragmentation Address Translation Flexibility Contiguous External Base/Limit registers Low Segmentation External Segment table Medium Paging Internal Page table High Virtual Memory Internal Page table + disk Highest","multithreading-models#Multithreading Models":"Threads exist at two levels: user threads (managed by user-level libraries) and kernel threads (managed by the OS).\nModel Mapping Assessment Many-to-One Many user threads → 1 kernel thread Poor concurrency: if one thread blocks, all block. Rarely used today. One-to-One 1 user thread → 1 kernel thread Good concurrency, commonly used (Windows, Linux). Overhead may limit total thread count. Many-to-Many Many user threads → fewer/equal kernel threads OS creates optimal number of kernel threads. Flexible but complex. Common Thread Libraries:\nPOSIX Pthreads (UNIX/Linux) Windows threads Java threads","operating-systems-theory---complete-study-guide#Operating Systems Theory - Complete Study Guide":"Operating Systems Theory - Complete Study GuideComprehensive coverage for Assignments 1 \u0026 2","os-structures#OS Structures":"","output-requirements#Output Requirements":"For each algorithm, calculate and report:\nCompletion time for each process Turnaround time (completion - arrival) Waiting time (turnaround - burst) Average turnaround time Average waiting time Gantt chart showing process execution timeline","overview#Overview":"Implement producer and consumer programs that communicate through a bounded buffer in shared memory.","overview-1#Overview":"Simulate four CPU scheduling algorithms on a single CPU system, reading process data from input and producing scheduling statistics.","page-replacement#Page Replacement":"When is it needed? When a page fault occurs and no free frames are available in physical memory.\nModify (Dirty) Bit: Indicates whether a page has been modified since loading.\n0 (clean) - Page unchanged; no need to write back to disk (discard) 1 (dirty) - Page modified; must write back to disk before replacing What does the dirty bit signal? The page has been modified since it was loaded into memory and must be saved back to disk if selected as a victim.","page-replacement-algorithms#Page Replacement Algorithms":"","policy-vs-mechanism#Policy vs. Mechanism":"Critical Design Principle: Separate policy (what will be done?) from mechanism (how to do it?).\nMechanism: Determines how to accomplish a task (the implementation details).\nPolicy: Decides what needs to be done (the decision-making rules).\nWhy separate them? Flexibility - policy changes don’t require changing underlying mechanisms. Allows the same OS to adapt to different environments by changing policies without rewriting code.\nExample:\nMechanism: Timer interrupt hardware and context switching code Policy: CPU scheduling algorithm (RR, SJF, Priority)","positioning-time-components#Positioning Time Components":"Two Components:\nSeek Time - Time to move the disk arm to the desired cylinder Rotational Latency - Time for the desired sector to rotate under the read/write head Total positioning time = seek time + rotational latency","primary-goals#Primary Goals":"Execute user programs - Make solving user problems easier Convenience - Make the computer system easy to use Efficiency - Use hardware resources optimally Reliability \u0026 Safety - Prevent errors and improper computer use","process-control-block-pcb#Process Control Block (PCB)":"The PCB is the data structure containing all information associated with a process:\nProcess state Program counter (next instruction address) CPU registers (contents of all process-centric registers) CPU scheduling information (priority, queue pointers) Memory management information (page tables, segment tables) Accounting information (CPU used, time limits) I/O status information (allocated devices, open files)","process-creation#Process Creation":"Parent-Child Relationships: Parent processes create children processes, forming a process tree. The root is the init process (PID 1 on UNIX systems).\nUNIX Process Creation:\nfork() - System call that creates a new process (child) by duplicating the parent Child receives a copy of the parent’s address space Returns 0 to child, child’s PID to parent exec() - Replaces the child process’s memory space with a new program Overlays the current process image with a new program What happens if you call exec() before fork()? If you call exec() before fork(), the current process is replaced by the new program, and the fork() call never executes. You cannot create a child process because the code containing fork() has been overwritten.\nWhy does Google Chrome use multiple processes? Chrome uses separate processes for different tabs and plugins to provide isolation - if one tab crashes or is compromised, it doesn’t affect other tabs. This improves stability, security, and allows better resource management.","process-creation-1#Process Creation":"Producer (parent) creates shared memory using InitShm() Producer uses fork() to create Consumer (child) Producer uses exec() to load consumer executable Child inherits access to shared memory","process-fundamentals#Process Fundamentals":"What is a Process? A process is a program in execution - the active unit of work in a system. A program is merely a passive entity (executable file), while a process is active with a program counter and resources.","process-memory-layout#Process Memory Layout":"A process’s memory is divided into sections:\nText Section - Executable code Data Section - Global variables Heap Section - Dynamically allocated memory during runtime (grows upward) Stack Section - Temporary data (function parameters, return addresses, local variables) Question: What area contains dynamically allocated data? The heap section contains data allocated during runtime via functions like malloc().","process-states#Process States":"A process changes state as it executes:\nState Description New Process is being created Running Instructions are being executed on CPU Waiting Process is waiting for an event (I/O completion, signal) Ready Process is waiting to be assigned to a CPU Terminated Process has finished execution State Transitions:\nRunning → Waiting: Process makes I/O request Running → Ready: Interrupt occurs (time slice expires) Waiting → Ready: I/O or event completes Ready → Running: Scheduler selects this process Running → Terminated: Process completes When is a process forced off the CPU?\nI/O request (voluntary) Time slice expiration (involuntary preemption) Interrupt occurrence (involuntary) Calling fork() may trigger scheduling (depends on implementation)","process-states-summary#Process States Summary":"Transition Trigger New → Ready Process admitted Ready → Running Scheduler selects process Running → Waiting I/O request or event wait Running → Ready Interrupt (timer, preemption) Waiting → Ready I/O or event completion Running → Terminated Process exits","readers-writers-problem#Readers-Writers Problem":"First Readers-Writers Problem: No reader should wait unless a writer has already obtained permission. Readers have priority; writers may starve.\nSecond Readers-Writers Problem: Once a writer is ready, it performs its write ASAP. Writers have priority; readers may starve.\nWhen is a Reader-Writer Lock Preferable to a Semaphore? When an application has many more reads than writes. Multiple readers can access data concurrently without conflicts, improving performance over exclusive semaphore access.","real-time-scheduling-concepts#Real-Time Scheduling Concepts":"Two Types of Latency:\nInterrupt Latency - Time from interrupt arrival to service routine start Dispatch Latency - Time to stop current process and start new one Both must be minimized for real-time systems to meet deadlines.","required-functions#Required Functions":"Pointer Management:\nGetIn() - Read current in value SetIn(new_value) - Update in value GetOut() - Read current out value SetOut(new_value) - Update out value Buffer Access:\nWriteAtBufIndex(index, data) - Write data at buffer index ReadAtBufIndex(index) - Read data from buffer index Critical: Use these functions to maintain synchronization and avoid race conditions.","safe-and-unsafe-states#Safe and Unsafe States":"Unsafe State: Does not necessarily lead to deadlock - it means deadlock is possible. An unsafe state may or may not result in deadlock depending on future resource requests.\nSafe State: The system can allocate resources to each process in some order and avoid deadlock. A safe sequence exists.","scheduling-algorithm-selection-guide#Scheduling Algorithm Selection Guide":"Algorithm Best For Worst For FCFS Simple batch systems Interactive systems (convoy effect) SJF/SRTF Minimizing average waiting time Long processes (starvation risk) Priority Important tasks need preference Ensuring fairness (starvation risk) RR Interactive systems, time-sharing Minimizing turnaround time Multilevel Feedback Mixed workloads (interactive + CPU-bound) Simplicity of implementation","scheduling-algorithms#Scheduling Algorithms":"","scheduling-criteria#Scheduling Criteria":"Goals for scheduling algorithm performance:\nCriterion Goal Most Important For CPU Utilization Maximize General efficiency Throughput Maximize (processes completed per time unit) Batch systems Turnaround Time Minimize (submission to completion time) Batch systems Waiting Time Minimize (time spent in ready queue) All systems Response Time Minimize (request to first response time) Interactive systems Which is most important for interactive systems? Response time - users notice delays between requests and responses.","scheduling-fundamentals#Scheduling Fundamentals":"What is CPU Scheduling? The short-term scheduler (CPU scheduler) selects which process from the ready queue should execute next on the CPU.\nDispatcher: The dispatcher is the module that gives control of the CPU to the process selected by the scheduler. It performs:\nContext switching Switching to user mode Jumping to the proper location in the user program Dispatch latency is the time it takes to stop one process and start another.","shared-memory-structure-4kb-block#Shared Memory Structure (4KB block)":"Header:\nbufSize - Buffer capacity (number of items) itemCnt - Total items to produce/consume in - Index where next item will be produced out - Index where next item will be consumed Buffer Area: Contains the actual data items following the header.","standard-concurrency-problems#Standard Concurrency Problems":"","structures#Structures":"On-Disk Structures:\nBoot Control Block - Information to boot OS from this volume (boot block in UNIX, partition boot sector in Windows) Volume Control Block - Volume/partition details (superblock in UNIX, master file table in NTFS) Directory Structure - Organizes files Per-File File Control Block (FCB) - File details (inode in UNIX) Which structure implements a file system? All of the above work together. The boot control block, volume control block, and directory structure are the primary organizational structures.\nWhich structure reads/writes physical blocks? The basic file system (I/O control layer) issues generic commands to device drivers and reads/writes physical blocks.","synchronization-mechanisms#Synchronization Mechanisms":"","synchronization-requirements#Synchronization Requirements":"Buffer Full Condition:\n(in + 1) % bufSize == out Producer must wait if buffer is full before producing.\nBuffer Empty Condition:\nin == out Consumer must wait if buffer is empty before consuming.","synchronization-tool-comparison#Synchronization Tool Comparison":"Tool Complexity Requires Hardware Busy Waiting Best Use Mutex Lock Low Yes (atomic ops) Yes Simple mutual exclusion Binary Semaphore Medium Yes (atomic ops) Optional Mutual exclusion Counting Semaphore Medium Yes (atomic ops) Optional Resource counting Monitor High No (language support) No Complex synchronization","system-calls#System Calls":"What are System Calls? System calls provide the interface to OS services - they are the mechanism by which user programs request services from the operating system kernel.\nAPI, System-Call Interface, and OS Relationship:\nAPI (Application Programming Interface) - High-level functions programmers use (e.g., open(), read()) System-Call Interface - Intercepts API calls and invokes appropriate system calls in the OS Operating System - Executes the requested service in kernel mode Three Methods to Pass Parameters:\nRegisters - Pass parameters directly in CPU registers (simplest, but limited) Memory Block/Table - Store parameters in memory, pass address in register (used when many parameters) Stack - Push parameters onto the program stack, OS pops them off (flexible)","system-components#System Components":"Four Components of a Computer System:\nHardware - CPU, memory, I/O devices (provides basic computing resources) Operating System - Controls and coordinates hardware use among applications Application Programs - Define how system resources solve user problems Users - People, machines, or other computers using the system What runs all the time? The kernel is the one program running continuously on the computer. Everything else is either a system program (shipped with OS) or an application program.","the-problem-race-conditions#The Problem: Race Conditions":"What is a Race Condition? Occurs when multiple processes concurrently access and manipulate shared data, and the outcome depends on the particular order of access. This leads to inconsistent or incorrect results.\nExample: Two processes incrementing a shared counter - the final value depends on the timing of their memory reads and writes.","thrashing#Thrashing":"What is Thrashing? A state where a process is spending more time paging (swapping pages in and out) than executing. Occurs when a process doesn’t have enough frames to hold its working set (the set of pages actively used).\nSymptoms:\nLow CPU utilization (processes always waiting for page I/O) High paging activity Severe performance degradation Why doesn’t local replacement entirely solve thrashing? Local replacement (replacing only the process’s own pages) prevents one process from stealing frames from others, but doesn’t solve the fundamental problem: if a process doesn’t have enough frames for its working set, it will thrash regardless of the replacement policy. The only solution is to allocate more frames or reduce the degree of multiprogramming.\nPrevention:\nUse working set model to allocate sufficient frames Use local or priority replacement policies Suspend processes if insufficient memory","thread-fundamentals#Thread Fundamentals":"What is a Thread? A thread is a fundamental unit of CPU utilization, consisting of a thread ID, program counter, register set, and stack. Multiple threads within the same process share code, data, and files.\nSingle-threaded vs. Multithreaded Process:\nSingle-threaded: One program counter, one sequence of execution Multithreaded: Multiple program counters, multiple concurrent execution sequences Why shouldn’t a web server be single-threaded? A single-threaded web server can only handle one request at a time. While waiting for disk I/O or network operations for one client, it cannot service other clients, resulting in terrible performance and responsiveness.","thread-pools#Thread Pools":"What is a Thread Pool? A set of pre-created threads that wait for work to arrive. Instead of creating a new thread for each task, tasks are submitted to the pool, and an available thread executes them.\nWhy use Thread Pools?\nFaster service - No delay for thread creation Limited resources - Bounds the number of concurrent threads, preventing resource exhaustion Separation of concerns - Separates task creation from task execution mechanics","timer-interrupts#Timer Interrupts":"A timer (set by privileged instruction) can interrupt the computer after a specified period, ensuring the OS regains control periodically. This prevents any single process from monopolizing the CPU and enables time-sharing systems.","virtual-memory-fundamentals#Virtual Memory Fundamentals":"What is Virtual Memory? A technique that separates user logical memory from physical memory. Only part of a program needs to be in memory for execution.\nBenefits:\nLogical address space can be much larger than physical memory More programs can run concurrently Less I/O needed to load/swap programs Faster program loading and response time","what-are-interrupts#What are Interrupts?":"The operating system is interrupt-driven - it responds to events rather than running continuously. Interrupts signal that something requires the OS’s attention.\nTypes of Interrupts:\nHardware Interrupt - Generated by hardware devices (e.g., I/O device completing an operation) Software Interrupt (Trap/Exception) - Caused by software errors (division by zero) or user requests (system calls)","what-is-an-operating-system#What is an Operating System?":"An operating system is an intermediary program that sits between users and computer hardware, creating an environment where other programs can do useful work. Like a government, it doesn’t do productive work itself but provides the framework for others to operate efficiently.","when-does-scheduling-occur#When Does Scheduling Occur?":"Nonpreemptive (Cooperative) Scheduling: Scheduling decisions occur only when a process:\nSwitches from running to waiting state (I/O request) Terminates The process voluntarily relinquishes the CPU.\nPreemptive Scheduling: Scheduling decisions also occur when a process: 3. Switches from running to ready (interrupt, time slice expires) 4. Switches from waiting to ready (I/O completes, higher priority process arrives)\nThe OS can forcibly remove a process from the CPU."},"title":"ass1_ass2_topics"},"/electrical_notes/cs_420/ass1_ass2_topics_noteboooklm/":{"data":{"":"This documentation outlines the core theoretical concepts relevant to Assignments 1 and 2, based on the course description and included materials. The purpose of this course is two-fold: to provide an understanding of the concepts and design of operating systems (OS), and to examine implementation details of OSs like UNIX and Windows.","concurrency-and-synchronization#Concurrency and Synchronization":"This section includes race conditions, critical section solutions, and classic synchronization problems. Questions require: Explaining race conditions (concurrent access leading to outcome dependent on access order); assessing the relationship between the three critical section requirements (Mutual Exclusion, Progress, Bounded Waiting); discussing whether counting semaphores can be used to control access to resources with a finite number of instances (Yes); contrasting semaphores and mutex locks; detailing approaches to handle critical sections in OSs; analyzing structural changes in the bounded buffer producer process and the resulting blocking; describing scenarios for when using a reader–writer lock is preferable to a semaphore; explaining the difference between the first and second readers-writers problems; and describing a starvation scenario in the monitor solution for the dining philosophers problem.","cpu-scheduling#CPU Scheduling":"This includes scheduling algorithms, criteria, and related concepts like latency. Questions focus on: Which criterion is most important for an interactive system (response time); which circumstance cooperative scheduling can take place (running to waiting state switch); which algorithm must be nonpreemptive (FCFS); defining the role of the dispatcher; explaining starvation and how aging prevents it; identifying the two types of latency affecting real-time systems (interrupt latency, dispatch latency); and which term describes the capability for multiple tasks to make progress on a single processor system (concurrency).","deadlocks#Deadlocks":"This covers the characterization and handling of deadlocks. Questions address: The necessary condition for deadlock stating a resource must be nonsharable (mutual exclusion); whether an unsafe state necessarily leads to a deadlocked state (it may lead to it); explaining the four necessary conditions for deadlock (Mutual Exclusion, Hold and Wait, No Preemption, Circular Wait); listing the three general ways deadlocks are handled (prevention, avoidance, recovery/ignoring); and describing protocols to prevent the hold-and-wait condition.","functions-of-an-operating-system--os-structure#Functions of an Operating System \u0026amp; OS Structure":"This topic covers the definition and goals of an OS, its components, and system architecture. Questions include: How an operating system is like a government (it creates an environment for other programs to do work); what program runs all the time on the computer (the kernel); describing the four components of computer systems; describing OS design goals (convenience, reliability, safety, speed, ease of design/maintenance); and determining which statement relating to OS services, resource management, interfaces, protection, and security is incorrect. It also asks how microkernels handle communication (message passing), and defines the relationship between an API, the system-call interface, and the operating system.","i-functions-of-an-operating-system#I. Functions of an Operating System":"An operating system acts as an intermediary program between a user and the computer hardware.\nPrimary Goals and Roles (Describe the functions of an operating system):\nExecute user programs and make solving user problems easier. Make the computer system convenient to use. Use the computer hardware efficiently. Resource Allocator: The OS manages all resources and decides between conflicting requests to ensure efficient and fair resource use. Control Program: The OS controls the execution of programs to prevent errors and improper use of the computer. Key Operating System Services:\nUser Interface (UI): Nearly all OSs provide a user interface, which can be Command-Line (CLI), Graphics User Interface (GUI), or Batch. Program Execution: The system must load a program into memory, run it, and handle termination (normal or error). I/O Operations: Managing I/O requests, which may involve files or I/O devices. File-System Manipulation: Programs need to read, write, create, delete, search files and directories, list information, and manage permissions. Communications (IPC): Processes exchange information either on the same computer or over a network, potentially using shared memory or message passing. Error Detection: The OS must constantly be aware of errors in the CPU, memory, I/O devices, or user programs, and take appropriate action to ensure consistent computing. Resource Allocation: When multiple jobs run concurrently, the OS allocates resources such as CPU cycles, main memory, file storage, and I/O devices. Protection and Security: Protection ensures access to system resources is controlled, while security defends the system (and user information) from external invalid access attempts.","ii-interrupt-handling-describe-the-events-that-follow-the-occurrence-of-an-interrupt#II. Interrupt Handling (Describe the events that follow the occurrence of an interrupt)":"The operating system is fundamentally interrupt driven.\nInterrupt Trigger: An I/O device controller informs the CPU that it has finished an operation by causing a hardware interrupt. Alternatively, a trap or exception is a software-generated interrupt caused by an error (e.g., division by zero) or a user request (e.g., a system call). Control Transfer: The interrupt transfers control to the interrupt service routine. This transfer is generally achieved through the interrupt vector, which contains the memory addresses of all the service routines. State Preservation: The interrupt architecture must save the address of the interrupted instruction so the system can resume execution later. User program registers and process state are saved. Kernel Mode Entry: If the interrupt is a request for an OS service (a system call), the mode bit is changed to kernel mode (or supervisor mode), allowing privileged instructions to execute. Service Routine Execution: The CPU executes the relevant service routine based on the interrupt type. Return to User: After the interrupt is handled, the system call changes the mode back to user mode, and execution resumes from the saved instruction address. A timer can be set by the operating system (a privileged instruction) to interrupt the computer after a certain period, ensuring the OS regains control and preventing a single process from hogging resources.","iii-process-and-thread-management-schemes#III. Process and Thread Management Schemes":"A. Process Management (Describe and Assess)\nA process is defined as a program in execution and is the unit of work within the system; a program is merely a passive entity.\nComponent Description Process State Changes as the process executes: new, running, waiting (for an event), ready (waiting for a processor), or terminated. Process Control Block (PCB) Information associated with each process, including state, program counter, CPU registers, scheduling information, memory management data, accounting info, and I/O status. Process Creation Parent processes create children processes, forming a tree. The UNIX fork() system call creates a new process, and exec() replaces the child process’s memory space with a new program. Interprocess Communication (IPC) Cooperating processes need mechanisms to share information, achieve computation speedup, or maintain modularity. This is achieved via shared memory or message passing. B. Thread Management (Describe and Assess)\nA thread is a fundamental unit of CPU utilization. A multithreaded process has one program counter per thread, allowing multiple locations to execute at once.\nBenefit Description / Assessment Responsiveness Allows continued execution if part of the process is blocked (important for UIs). Resource Sharing Threads automatically share the resources of the parent process, which is easier than implementing shared memory or message passing between separate processes. Economy Thread creation is “light-weight” and cheaper than “heavy-weight” process creation; thread switching has lower overhead than context switching. Scalability A process can take advantage of multiprocessor architectures (parallelism). Multithreading Models (Explain the major alternatives for process/thread management):\nModel Description Assessment / Usage User Threads Management done by user-level thread libraries (e.g., POSIX Pthreads, Windows threads, Java threads). Kernel is unaware of them. Kernel Threads Supported directly by the operating system kernel (e.g., Windows, Linux, Solaris). Many-to-One Many user threads mapped to a single kernel thread. Low concurrency; if one thread blocks, all block. Few systems use this. One-to-One Each user thread maps to a separate kernel thread. Higher concurrency, commonly used (e.g., Windows, Linux). Overhead may restrict the total number of threads. Many-to-Many Many user threads mapped to a smaller or equal number of kernel threads. Allows the OS to create a sufficient number of kernel threads for optimal execution.","interrupts-bootstrapping-and-system-calls#Interrupts, Bootstrapping, and System Calls":"This covers how the OS starts and how user programs request services. Questions address: Which stage triggers the CPU switch from user program to interrupt processing; what a bootstrap program is and where it is stored (ROM/EPROM/firmware); the three general methods used to pass parameters during system calls (registers, block/table in memory, or pushed onto the stack); which mechanism provides the interface to OS services (system calls); and why clustered systems provide high-availability service.","iv-concurrency-mechanisms-use-semaphores-and-other-mechanisms-to-solve-standard-concurrency-problems#IV. Concurrency Mechanisms (Use semaphores and other mechanisms to solve standard concurrency problems)":"Concurrency supports more than one task making progress, typically achieved by multiplexing CPUs among processes/threads. Parallelism implies a system can perform more than one task simultaneously, requiring multi-core hardware.\nRace Condition: Occurs when several processes concurrently access and manipulate the same data, and the final outcome depends on the particular order in which the access takes place. Maintaining data consistency requires orderly execution of cooperating processes.\nCritical Section (CS) Requirements: Any solution designed to solve the critical-section problem must satisfy three requirements:\nMutual Exclusion: If process PiP_iPi​ is executing in its critical section, no other process can be executing in their critical sections. Progress: If no process is in the CS, and some wish to enter, the selection of the next process cannot be postponed indefinitely. Bounded Waiting: A limit must exist on the number of times other processes can enter their CS after a process requests entry, but before that request is granted. Synchronization Tools (Describe and Assess):\nMechanism Description Assessment / Usage Mutex Locks Simplest software tool. Protects a CS by requiring a process to acquire() a lock before entering and release() the lock upon exiting. Requires busy waiting (spinlock). Calls to acquire() and release() must be atomic. Semaphores An integer variable, SSS, accessed only via atomic wait() (decrement) and signal() (increment) operations. Counting Semaphores range over an unrestricted domain and can control access to a resource with a finite number of instances. Binary Semaphores are equivalent to mutex locks (range 0 or 1). Can be implemented without busy waiting using a waiting queue. Monitors A high-level abstraction (Abstract Data Type) ensuring that only one process may be active within the monitor procedures at a time. Uses condition variables (x.wait(), x.signal()) to suspend and resume processes within the monitor structure. Standard Concurrency Problem: Bounded-Buffer\nThe classic Producer-Consumer problem using a bounded buffer can be solved using three semaphores:\nmutex: Initialized to 1, ensuring mutual exclusion for buffer access. full: Initialized to 0, counting the number of full buffers. empty: Initialized to nnn (buffer size), counting the number of empty buffers. The Producer must wait(empty) (wait if buffer is full) before adding an item, and the Consumer must wait(full) (wait if buffer is empty) before removing an item. Both use wait(mutex) and signal(mutex) around buffer access (the critical section). (Assignment 1 requires implementing the bounded buffer producer/consumer using shared memory and managing the buffer pointers in and out to detect full/empty conditions.)\nDeadlock Characterization: Deadlock can arise if four conditions hold simultaneously:\nMutual Exclusion: Only one process can use a resource at a time. Hold and Wait: A process holding at least one resource is waiting to acquire additional resources held by other processes. No Preemption: Resources can only be released voluntarily by the holding process after completion. Circular Wait: A closed chain of waiting processes exists, where each process waits for a resource held by the next process in the chain.","memory-management-real-and-virtual#Memory Management (Real and Virtual)":"This topic covers address binding, allocation methods, fragmentation, paging, and demand paging. Questions include: Identifying the binding method used by most general-purpose OSs (execution time binding); calculating the page number from a given logical address and page size (requires calculation); distinguishing between internal and external fragmentation; describing how a TLB assists address translation; calculating context switch time associated with swapping (requires calculation based on transfer rate/latency); explaining the distinction between demand paging and paging with swapping; explaining how Effective Access Time is computed for demand paging; explaining why a local replacement algorithm doesn’t entirely solve thrashing; identifying when a page is loaded in demand paging (only when needed during execution); and identifying what the dirty (modify) bit signals (the page has been modified since loading).","operating-systems-theory-outline#Operating Systems Theory Outline":"","process-and-thread-management#Process and Thread Management":"This section addresses the definition, states, creation, and advantages of processes and threads. Questions cover: What area contains dynamically allocated data during runtime (heap section); which process state is switched to from ‘running’ when an I/O event occurs (waiting); scenarios that force a process off the CPU (I/O request, fork, interrupt/time slice expired); defining and describing the different process states; explaining why Google Chrome uses multiple processes; discussing the consequences of calling exec() before fork(); identifying items shared across threads of the same process (code, data, files); explaining why a web server shouldn’t be single-threaded; listing and explaining the four major benefits of multithreaded programming (Responsiveness, Resource Sharing, Economy, Scalability); and defining and justifying the use of a thread pool.","storage-and-file-system-implementation-general-course-relevance#Storage and File System Implementation (General Course Relevance)":"Questions address: The two components of positioning time (seek time + rotational latency); which disk scheduling algorithm ignores the current head position (FCFS); describing a disadvantage of FCFS disk scheduling (long waits); listing the factors influencing disk-scheduling algorithm selection; which structure reads and writes physical blocks (basic file system); what structures implement a file system (boot control block, volume control block, directory structure); and explaining why the entire block is unavailable to a user when linked allocation is employed.","summary-of-questions-from-source-materials#Summary of Questions from Source Materials":"The following is a condensed list of all multiple-choice and essay questions found in the provided slides, categorized by relevant topic:","v-cpu-scheduling-algorithms-describe-and-assess#V. CPU Scheduling Algorithms (Describe and Assess)":"The CPU scheduler is the short-term scheduler that selects the next process residing in the ready queue to execute on the CPU. Scheduling decisions are either nonpreemptive (when a process terminates or switches running →\\to→ waiting state) or preemptive (when a process switches running →\\to→ ready or waiting →\\to→ ready).\nScheduling Criteria (Assessment): The goal is to maximize CPU utilization and throughput, while minimizing turnaround time, waiting time, and response time.\nAlgorithm Description Assessment (Advantages/Disadvantages) First-Come, First-Served (FCFS) Processes are served in the order they arrive (FIFO queue). Nonpreemptive. Simple to implement. Can suffer from the convoy effect (short processes stuck behind long ones), leading to high average waiting time. Shortest-Job-First (SJF) Schedules the process with the shortest predicted next CPU burst time. Can be estimated using exponential averaging. Optimal: gives the minimum average waiting time for a given set of processes. The main difficulty is predicting the length of the next CPU burst. Shortest-Remaining-Time-First (SRTF) The preemptive version of SJF. If a new process arrives with a shorter burst time than the currently running process’s remaining time, the current process is preempted. Priority Scheduling (PR) The CPU is allocated based on a priority number (smallest integer ≡\\equiv≡ highest priority). Can be preemptive or nonpreemptive. Problem: Starvation (low-priority processes may never execute). Solution: Aging (gradually increasing the priority of processes waiting for a long time). Round Robin (RR) Each process receives a small time quantum (qqq), typically 10–100 milliseconds. If the quantum expires, the process is preempted and added to the end of the ready queue. Good response time. High overhead if qqq is too small (relative to context switch time). If qqq is large, it performs like FCFS. Multilevel Feedback Queue Allows processes to move between different ready queues based on their CPU behavior (e.g., short interactive jobs stay in RR queues with small quanta; CPU-bound jobs drop to FCFS queues). Aging can be easily implemented by moving processes between queues. Highly configurable based on criteria such as the number of queues and scheduling algorithms used for each queue.","vi-real-and-virtual-memory-management-schemes#VI. Real and Virtual Memory Management Schemes":"A. Real (Physical) Memory Management\nThe objective is to optimize CPU utilization and computer response by deciding what data moves into and out of memory, and allocating/deallocating memory space.\nMemory Allocation Schemes (Describe and Assess):\nContiguous Allocation: Each process is contained in a single contiguous section of memory. Assessment: Requires hardware support (Base/Limit registers) for protection. Suffers from external fragmentation (total memory space exists, but is scattered/noncontiguous). Segmentation: A memory management scheme that supports the user’s view of memory, where a program is viewed as a collection of logical units (segments) such as the main program, procedures, stack, and heap. Assessment: Logical addresses are two-dimensional: . Still suffers from external fragmentation. Paging: The physical address space is noncontiguous, avoiding external fragmentation. Physical memory is divided into fixed-size blocks called frames, and logical memory is divided into same-sized blocks called pages. Assessment: Logical addresses are translated using a page table which maps page numbers (ppp) to physical frame addresses. This scheme suffers from internal fragmentation (allocated memory slightly larger than requested). Hardware support often includes a Translation Look-aside Buffer (TLB) to speed up address translation, as the page table is usually kept in main memory. B. Virtual Memory Management (Describe and Assess)\nVirtual memory separates user logical memory from physical memory, allowing the logical address space to be much larger than the physical address space. This allows more programs to run concurrently and requires less I/O for loading programs.\nDemand Paging: The implementation method where a page is brought into memory only when it is actually needed (referenced).\nAssessment: Reduces I/O and memory needed, leading to faster response. Requires hardware support, including a page table with a valid–invalid bit (used to detect a page fault). Effective Access Time (EAT): Performance is sensitive to the page fault rate (ppp) because page fault service time (involving disk I/O) is extremely slow. EAT=(1−p)×(memory access time)+p×(page fault time)EAT = (1-p) \\times (memory\\ access\\ time) + p \\times (page\\ fault\\ time)EAT=(1−p)×(memory access time)+p×(page fault time). To maintain reasonable performance, ppp must be very small. Page Replacement (Describe and Assess): Required when a page fault occurs and no free frames are available. A modify (dirty) bit reduces overhead by indicating whether a victim page needs to be written back to disk.\nAlgorithm Description Assessment (Pros/Cons) First-In-First-Out (FIFO) Replaces the page that has been in memory the longest (oldest). Simple. Suffers from Belady’s Anomaly, where increasing the number of allocated frames can sometimes increase the page fault rate. Optimal (OPT) Replaces the page that will not be used for the longest period of time in the future. Impossible to implement since it requires predicting the future. Used solely as a standard for comparison. Least Recently Used (LRU) Replaces the page that has not been used for the longest time in the past. Generally a good algorithm that does not suffer from Belady’s Anomaly. Implementation requires expensive hardware support (counters or stacks) to track usage time. LRU Approximation (e.g., Second-Chance) Uses a reference bit; pages are replaced if the reference bit is 0. If 1, the bit is cleared and the process checks the next oldest page. An efficient attempt to approximate LRU behavior without complex hardware. Thrashing: A state where a process is busy swapping pages in and out because it does not have enough frames allocated to hold its current working set (locality). This results in low CPU utilization. Limiting the effects of thrashing requires using local or priority page replacement policies.","vii-assignment-specific-and-course-relevant-topics#VII. Assignment-Specific and Course Relevant Topics":"Assignment 1 Specifics: Shared Memory and Multi-Tasking\nAssignment 1 involves writing producer and consumer programs that communicate via a bounded buffer in shared memory.\nThe Producer (parent) uses fork() to create the Consumer (child) and loads the consumer executable using exec(). A fixed-size shared memory block (4K) is created by the producer using InitShm(). This block contains a header with: bufSize (buffer capacity), itemCnt (items to produce/consume), in (index of next item to produce), and out (index of next item to consume). The producer must wait if the bounded buffer is full. The consumer must wait if the bounded buffer is empty. Synchronization must be maintained by using specified functions to read/write the shared in and out variables (GetIn/Out(), SetIn/Out()) and to access the buffer contents (ReadAtBufIndex(), WriteAtBufIndex()). Assignment 2 Specifics: CPU Scheduling Algorithms\nAssignment 2 focuses on simulating four CPU scheduling algorithms, assuming a single CPU:\nRound Robin (RR): Processes are added to a FIFO queue based on arrival time. The time quantum is a parameter. If the quantum expires, the process goes to the end of the queue. Shortest Job First (SJF) (Non-preemptive): Scheduling decisions occur only when the current process terminates. The next process chosen is the one that has arrived and has the shortest CPU burst length. Ties are broken by arrival time (FCFS). Priority Scheduling without Preemption (PR noPREMP): Scheduling decisions occur only upon termination. The process with the highest priority (smallest number) is chosen. Ties are broken arbitrarily. Priority Scheduling with Preemption (PR withPREMP): Scheduling decisions occur upon termination OR when a higher priority process arrives. If a higher priority process arrives, the current CPU-holding process is preempted and added back to the priority queue. OS Design and Implementation:\nA crucial design principle is separating Policy (what will be done?) from Mechanism (how to do it?). Mechanisms determine how to accomplish a task, while policies decide what needs to be done. Separating them allows policy changes without changing underlying mechanisms.\nOS structures vary widely:\nSimple Structure (MS-DOS): Not divided into modules, interfaces and functionality poorly separated. Traditional UNIX: Limited structuring, consists of systems programs and the kernel (everything below the system-call interface). Microkernel: Moves as much functionality as possible from the kernel into user space, communicating via message passing. Benefits include being easier to extend/port, more reliable, and more secure; the detriment is performance overhead due to communication. Hybrid Systems: Most modern OSs combine multiple approaches (e.g., Linux/Solaris are monolithic plus modular; Mac OS X uses a Mach microkernel base combined with BSD UNIX parts)."},"title":"ass1_ass2_topics_noteboookLM"},"/electrical_notes/ee_300/":{"data":{"":"Linear Circuit Analysis II"},"title":"About EE 300"},"/electrical_notes/ee_300/10_s_domain_diffeq/":{"data":{"apply-laplace#Apply Laplace:":"s2I(s)−si(0)−i′(0)+2ζωn[sI(s)−i(0)]+ωn2I(s)=1ss^2I(s) - si(0) - i'(0) + 2\\zeta\\omega_n[sI(s) - i(0)] + \\omega_n^2I(s) = \\frac{1}{s}s2I(s)−si(0)−i′(0)+2ζωn​[sI(s)−i(0)]+ωn2​I(s)=s1​","common-pitfalls#Common Pitfalls":"","converting-back-to-s-domain-verification#Converting Back to s-Domain (Verification)":"You can verify your differential equation by applying Laplace transform:","converting-s-domain-equations-to-differential-equations#Converting s-Domain Equations to Differential Equations":"Converting s-Domain Equations to Differential Equations","damping-categories#Damping Categories":"Overdamped: ζ \u003e 1 (two real poles) Critically damped: ζ = 1 (repeated real pole) Underdamped: ζ \u003c 1 (complex conjugate poles)","example-1-first-order-series-rc#Example 1: First-Order (Series RC)":"","example-2-first-order-series-rl#Example 2: First-Order (Series RL)":"","example-3-second-order-series-rlc#Example 3: Second-Order (Series RLC)":"","example-4-parallel-rlc-circuit#Example 4: Parallel RLC Circuit":"","example-series-rlc#Example: Series RLC":"From: LCd2idt2+RCdidt+i=CdvsdtLC\\frac{d^2i}{dt^2} + RC\\frac{di}{dt} + i = C\\frac{dv_s}{dt}LCdt2d2i​+RCdtdi​+i=Cdtdvs​​\nDivide by LC: d2idt2+RLdidt+1LCi=1Ldvsdt\\frac{d^2i}{dt^2} + \\frac{R}{L}\\frac{di}{dt} + \\frac{1}{LC}i = \\frac{1}{L}\\frac{dv_s}{dt}dt2d2i​+LR​dtdi​+LC1​i=L1​dtdvs​​Identify:\nωn2=1LC\\omega_n^2 = \\frac{1}{LC}ωn2​=LC1​ → ωn=1LC\\omega_n = \\frac{1}{\\sqrt{LC}}ωn​=LC​1​ 2ζωn=RL2\\zeta\\omega_n = \\frac{R}{L}2ζωn​=LR​ → ζ=R2CL\\zeta = \\frac{R}{2}\\sqrt{\\frac{C}{L}}ζ=2R​LC​​","extracting-system-parameters#Extracting System Parameters":"Once you have the differential equation in standard form, you can identify system characteristics.","first-order-standard-form#First-Order Standard Form":"τdy(t)dt+y(t)=Ku(t)\\tau\\frac{dy(t)}{dt} + y(t) = Ku(t)τdtdy(t)​+y(t)=Ku(t)Where:\nτ = time constant (seconds) K = DC gain For RC circuit: τ = RC For RL circuit: τ = L/R","inverse-correspondence-rules#Inverse Correspondence Rules":"These rules convert s-domain terms back to time-domain:\ns-Domain Term Time-Domain Equivalent Notes V(s) or I(s) v(t) or i(t) Basic function sV(s) dv(t)/dt First derivative s²V(s) d²v(t)/dt² Second derivative s³V(s) d³v(t)/dt³ Third derivative V(s)/s ∫v(t)dt Integration Constant C Constant C Unchanged V_s(s) v_s(t) = ℒ-¹{V_s(s)} Inverse transform source Important: Initial conditions are assumed to be handled separately (they appear as additional terms in s-domain).","next-steps#Next Steps":"Compare with PATH B: Your derived equation should match what PATH B gives directly Extract parameters: Use standard form to find ω_n, ζ, etc. Verify: Apply Laplace transform to your diff eq and confirm it gives the original s-domain equation","overview#Overview":"This document covers the reverse process: starting with an s-domain algebraic equation (from PATH A) and deriving the corresponding time-domain differential equation.\ngraph LR A[s-Domain Algebraic Equation] --\u003e B[Apply InverseCorrespondence] B --\u003e C[Time-DomainDifferential Equation] style A fill:#e8f5e9 style C fill:#ffe0b2","pitfall-1-forgetting-to-clear-denominators#Pitfall 1: Forgetting to Clear Denominators":"Before applying inverse correspondence, ensure all terms are polynomials in s, not fractions.","pitfall-2-wrong-correspondence#Pitfall 2: Wrong Correspondence":"WRONG: V(s)s→v(t)t\\frac{V(s)}{s} \\rightarrow \\frac{v(t)}{t}sV(s)​→tv(t)​\nRIGHT: V(s)s→∫v(t)dt\\frac{V(s)}{s} \\rightarrow \\int v(t)dtsV(s)​→∫v(t)dt","pitfall-3-mixing-variables#Pitfall 3: Mixing Variables":"Stay consistent - if solving for i(t), don’t introduce v(t) without substituting relationships.","pitfall-4-source-function-confusion#Pitfall 4: Source Function Confusion":"The inverse transform of V_s(s) gives v_s(t), but you may need its derivative for the RHS.","practice-problems#Practice Problems":"Given the following s-domain equations, derive the time-domain differential equations:","problem-1#Problem 1":"12s=I(s)[4+20s]\\frac{12}{s} = I(s)\\left[4 + \\frac{20}{s}\\right]s12​=I(s)[4+s20​]","problem-2#Problem 2":"V(s)[15+12s]=4sV(s)\\left[\\frac{1}{5} + \\frac{1}{2s}\\right] = \\frac{4}{s}V(s)[51​+2s1​]=s4​","problem-3#Problem 3":"I(s)[8+2s+40s]=20sI(s)\\left[8 + 2s + \\frac{40}{s}\\right] = \\frac{20}{s}I(s)[8+2s+s40​]=s20​","quick-reference-s-to-t-correspondence#Quick Reference: s to t Correspondence":"From s-Domain To Time-Domain Operation F(s) f(t) Basic sF(s) df/dt Differentiation s²F(s) d²f/dt² 2nd derivative s³F(s) d³f/dt³ 3rd derivative F(s)/s ∫f(t)dt Integration C (constant) C (constant) Unchanged 1/s u(t) Step function 1/(s+a) e^(-at)u(t) Exponential ω/(s²+ω²) sin(ωt)u(t) Sine s/(s²+ω²) cos(ωt)u(t) Cosine","second-order-standard-form#Second-Order Standard Form":"d2y(t)dt2+2ζωndy(t)dt+ωn2y(t)=Ku(t)\\frac{d^2y(t)}{dt^2} + 2\\zeta\\omega_n\\frac{dy(t)}{dt} + \\omega_n^2y(t) = Ku(t)dt2d2y(t)​+2ζωn​dtdy(t)​+ωn2​y(t)=Ku(t)Where:\nω_n = natural frequency (rad/s) ζ = damping ratio (unitless) K = DC gain","starting-s-domain-equation#Starting s-Domain Equation":"From PATH A Example 1: 10s=I(s)[100+105s]\\frac{10}{s} = I(s)\\left[100 + \\frac{10^5}{s}\\right]s10​=I(s)[100+s105​]Or equivalently (voltage across capacitor): VC(s)=104s(s+1000)V_C(s) = \\frac{10^4}{s(s+1000)}VC​(s)=s(s+1000)104​Let’s work with the impedance equation: Vs(s)=I(s)⋅R+I(s)⋅1sCV_s(s) = I(s) \\cdot R + I(s) \\cdot \\frac{1}{sC}Vs​(s)=I(s)⋅R+I(s)⋅sC1​","starting-s-domain-equation-1#Starting s-Domain Equation":"From PATH A Example 2: 5s+2=I(s)[10+0.5s]\\frac{5}{s+2} = I(s)[10 + 0.5s]s+25​=I(s)[10+0.5s]","starting-s-domain-equation-2#Starting s-Domain Equation":"For a series RLC circuit: Vs(s)=I(s)[R+sL+1sC]V_s(s) = I(s)\\left[R + sL + \\frac{1}{sC}\\right]Vs​(s)=I(s)[R+sL+sC1​]","starting-s-domain-equation-3#Starting s-Domain Equation":"Is(s)=V(s)[1R+1sL+sC]I_s(s) = V(s)\\left[\\frac{1}{R} + \\frac{1}{sL} + sC\\right]Is​(s)=V(s)[R1​+sL1​+sC]","step-1-expand#Step 1: Expand":"5s+2=10I(s)+0.5sI(s)\\frac{5}{s+2} = 10I(s) + 0.5sI(s)s+25​=10I(s)+0.5sI(s)","step-1-expand-1#Step 1: Expand":"Vs(s)=RI(s)+sLI(s)+I(s)sCV_s(s) = RI(s) + sLI(s) + \\frac{I(s)}{sC}Vs​(s)=RI(s)+sLI(s)+sCI(s)​","step-1-expand-2#Step 1: Expand":"Is(s)=V(s)R+V(s)sL+sCV(s)I_s(s) = \\frac{V(s)}{R} + \\frac{V(s)}{sL} + sCV(s)Is​(s)=RV(s)​+sLV(s)​+sCV(s)","step-1-start-with-s-domain-equation#Step 1: Start with s-Domain Equation":"Begin with your algebraic equation from PATH A.","step-1-write-explicitly#Step 1: Write Explicitly":"Vs(s)=R⋅I(s)+I(s)sCV_s(s) = R \\cdot I(s) + \\frac{I(s)}{sC}Vs​(s)=R⋅I(s)+sCI(s)​","step-2-multiply-both-sides-by-1-already-clear#Step 2: Multiply Both Sides by 1 (already clear)":"5s+2=10I(s)+0.5sI(s)\\frac{5}{s+2} = 10I(s) + 0.5sI(s)s+25​=10I(s)+0.5sI(s)","step-2-multiply-by-sc#Step 2: Multiply by sC":"sC⋅Vs(s)=sRC⋅I(s)+I(s)sC \\cdot V_s(s) = sRC \\cdot I(s) + I(s)sC⋅Vs​(s)=sRC⋅I(s)+I(s)","step-2-multiply-by-sc-1#Step 2: Multiply by sC":"sCVs(s)=sRCI(s)+s2LCI(s)+I(s)sCV_s(s) = sRCI(s) + s^2LCI(s) + I(s)sCVs​(s)=sRCI(s)+s2LCI(s)+I(s)","step-2-multiply-by-sl#Step 2: Multiply by sL":"sLIs(s)=sLV(s)R+V(s)+s2LCV(s)sLI_s(s) = \\frac{sLV(s)}{R} + V(s) + s^2LCV(s)sLIs​(s)=RsLV(s)​+V(s)+s2LCV(s)","step-2-multiply-to-clear-denominators#Step 2: Multiply to Clear Denominators":"Get all terms with same denominator or eliminate fractions.","step-3-apply-inverse-correspondence#Step 3: Apply Inverse Correspondence":"sC⋅Vs(s)→Cdvs(t)dtsC \\cdot V_s(s) \\rightarrow C\\frac{dv_s(t)}{dt}sC⋅Vs​(s)→Cdtdvs​(t)​ sRC⋅I(s)→RCdi(t)dtsRC \\cdot I(s) \\rightarrow RC\\frac{di(t)}{dt}sRC⋅I(s)→RCdtdi(t)​ I(s)→i(t)I(s) \\rightarrow i(t)I(s)→i(t)","step-3-apply-inverse-correspondence-1#Step 3: Apply Inverse Correspondence":"Left side: 5s+2→5e−2tu(t)\\frac{5}{s+2} \\rightarrow 5e^{-2t}u(t)s+25​→5e−2tu(t)\nRight side:\n10I(s)→10i(t)10I(s) \\rightarrow 10i(t)10I(s)→10i(t) 0.5sI(s)→0.5di(t)dt0.5sI(s) \\rightarrow 0.5\\frac{di(t)}{dt}0.5sI(s)→0.5dtdi(t)​","step-3-apply-inverse-correspondence-2#Step 3: Apply Inverse Correspondence":"sCVs(s)→Cdvs(t)dtsCV_s(s) \\rightarrow C\\frac{dv_s(t)}{dt}sCVs​(s)→Cdtdvs​(t)​ sRCI(s)→RCdi(t)dtsRCI(s) \\rightarrow RC\\frac{di(t)}{dt}sRCI(s)→RCdtdi(t)​ s2LCI(s)→LCd2i(t)dt2s^2LCI(s) \\rightarrow LC\\frac{d^2i(t)}{dt^2}s2LCI(s)→LCdt2d2i(t)​ I(s)→i(t)I(s) \\rightarrow i(t)I(s)→i(t)","step-3-apply-inverse-correspondence-3#Step 3: Apply Inverse Correspondence":"sLIs(s)→Ldis(t)dtsLI_s(s) \\rightarrow L\\frac{di_s(t)}{dt}sLIs​(s)→Ldtdis​(t)​ sLV(s)R→LRdv(t)dt\\frac{sLV(s)}{R} \\rightarrow \\frac{L}{R}\\frac{dv(t)}{dt}RsLV(s)​→RL​dtdv(t)​ V(s)→v(t)V(s) \\rightarrow v(t)V(s)→v(t) s2LCV(s)→LCd2v(t)dt2s^2LCV(s) \\rightarrow LC\\frac{d^2v(t)}{dt^2}s2LCV(s)→LCdt2d2v(t)​","step-3-identify-powers-of-s#Step 3: Identify Powers of s":"Look for s⁰, s¹, s², etc. multiplying V(s) or I(s).","step-4-apply-inverse-correspondence#Step 4: Apply Inverse Correspondence":"Replace each s-term with its time-domain equivalent.","step-4-time-domain-differential-equation#Step 4: Time-Domain Differential Equation":"Cdvs(t)dt=RCdi(t)dt+i(t)C\\frac{dv_s(t)}{dt} = RC\\frac{di(t)}{dt} + i(t)Cdtdvs​(t)​=RCdtdi(t)​+i(t)","step-4-time-domain-differential-equation-1#Step 4: Time-Domain Differential Equation":"5e−2tu(t)=10i(t)+0.5di(t)dt5e^{-2t}u(t) = 10i(t) + 0.5\\frac{di(t)}{dt}5e−2tu(t)=10i(t)+0.5dtdi(t)​Rearrange: 0.5di(t)dt+10i(t)=5e−2tu(t)0.5\\frac{di(t)}{dt} + 10i(t) = 5e^{-2t}u(t)0.5dtdi(t)​+10i(t)=5e−2tu(t)Or: di(t)dt+20i(t)=10e−2tu(t)\\frac{di(t)}{dt} + 20i(t) = 10e^{-2t}u(t)dtdi(t)​+20i(t)=10e−2tu(t)This matches PATH B Example 2!","step-4-time-domain-differential-equation-2#Step 4: Time-Domain Differential Equation":"Cdvs(t)dt=RCdi(t)dt+LCd2i(t)dt2+i(t)C\\frac{dv_s(t)}{dt} = RC\\frac{di(t)}{dt} + LC\\frac{d^2i(t)}{dt^2} + i(t)Cdtdvs​(t)​=RCdtdi(t)​+LCdt2d2i(t)​+i(t)Rearrange: LCd2i(t)dt2+RCdi(t)dt+i(t)=Cdvs(t)dtLC\\frac{d^2i(t)}{dt^2} + RC\\frac{di(t)}{dt} + i(t) = C\\frac{dv_s(t)}{dt}LCdt2d2i(t)​+RCdtdi(t)​+i(t)=Cdtdvs​(t)​This is a second-order differential equation.\nFor a step input v_s(t) = V₀u(t), the derivative is V₀δ(t): LCd2i(t)dt2+RCdi(t)dt+i(t)=CV0δ(t)LC\\frac{d^2i(t)}{dt^2} + RC\\frac{di(t)}{dt} + i(t) = CV_0\\delta(t)LCdt2d2i(t)​+RCdtdi(t)​+i(t)=CV0​δ(t)","step-4-time-domain-differential-equation-3#Step 4: Time-Domain Differential Equation":"Ldis(t)dt=LRdv(t)dt+v(t)+LCd2v(t)dt2L\\frac{di_s(t)}{dt} = \\frac{L}{R}\\frac{dv(t)}{dt} + v(t) + LC\\frac{d^2v(t)}{dt^2}Ldtdis​(t)​=RL​dtdv(t)​+v(t)+LCdt2d2v(t)​Rearrange: LCd2v(t)dt2+LRdv(t)dt+v(t)=Ldis(t)dtLC\\frac{d^2v(t)}{dt^2} + \\frac{L}{R}\\frac{dv(t)}{dt} + v(t) = L\\frac{di_s(t)}{dt}LCdt2d2v(t)​+RL​dtdv(t)​+v(t)=Ldtdis​(t)​For step input i_s(t) = I₀u(t): LCd2v(t)dt2+LRdv(t)dt+v(t)=LI0δ(t)LC\\frac{d^2v(t)}{dt^2} + \\frac{L}{R}\\frac{dv(t)}{dt} + v(t) = LI_0\\delta(t)LCdt2d2v(t)​+RL​dtdv(t)​+v(t)=LI0​δ(t)","step-5-alternative-form-for-v_c#Step 5: Alternative Form (for v_C)":"To get differential equation for v_C(t), use: i(t)=CdvC(t)dti(t) = C\\frac{dv_C(t)}{dt}i(t)=CdtdvC​(t)​\nSubstitute: Cdvs(t)dt=RC⋅Cd2vC(t)dt2+CdvC(t)dtC\\frac{dv_s(t)}{dt} = RC \\cdot C\\frac{d^2v_C(t)}{dt^2} + C\\frac{dv_C(t)}{dt}Cdtdvs​(t)​=RC⋅Cdt2d2vC​(t)​+CdtdvC​(t)​Simplify: dvs(t)dt=RCd2vC(t)dt2+dvC(t)dt\\frac{dv_s(t)}{dt} = RC\\frac{d^2v_C(t)}{dt^2} + \\frac{dv_C(t)}{dt}dtdvs​(t)​=RCdt2d2vC​(t)​+dtdvC​(t)​Or integrate: vs(t)=RCdvC(t)dt+vC(t)v_s(t) = RC\\frac{dv_C(t)}{dt} + v_C(t)vs​(t)=RCdtdvC​(t)​+vC​(t)Which gives: RCdvC(t)dt+vC(t)=vs(t)RC\\frac{dv_C(t)}{dt} + v_C(t) = v_s(t)RCdtdvC​(t)​+vC​(t)=vs​(t)This matches PATH B Example 1!","step-5-rearrange-to-standard-form#Step 5: Rearrange to Standard Form":"Put derivatives in descending order, right-hand side for forcing function.","step-by-step-process#Step-by-Step Process":"","summary#Summary":"graph TD A[s-Domain Equationfrom PATH A] --\u003e B[Clear denominatorsmultiply by s, s², etc.] B --\u003e C[Identify powers of ss⁰, s¹, s², ...] C --\u003e D[Apply inverse correspondences^n → d^n/dt^n] D --\u003e E[Time-DomainDifferential Equation] E --\u003e F[Standard form revealsω_n, ζ, τ] style A fill:#e8f5e9 style E fill:#ffe0b2 style F fill:#fff3e0 Key insight: The s-domain algebraic equation and time-domain differential equation contain the same information in different forms!","time-domain#Time Domain:":"d2i(t)dt2+2ζωndi(t)dt+ωn2i(t)=u(t)\\frac{d^2i(t)}{dt^2} + 2\\zeta\\omega_n\\frac{di(t)}{dt} + \\omega_n^2i(t) = u(t)dt2d2i(t)​+2ζωn​dtdi(t)​+ωn2​i(t)=u(t)","why-do-this#Why Do This?":"After following PATH A, you may want to:\nUnderstand the physics - see what differential equation you actually solved Answer exam questions - “what is the differential equation?” Analyze system behavior - determine natural frequency, damping, etc. Verify your work - check against PATH B result","with-zero-initial-conditions#With zero initial conditions:":"I(s)[s2+2ζωns+ωn2]=1sI(s)[s^2 + 2\\zeta\\omega_n s + \\omega_n^2] = \\frac{1}{s}I(s)[s2+2ζωn​s+ωn2​]=s1​I(s)=1s(s2+2ζωns+ωn2)I(s) = \\frac{1}{s(s^2 + 2\\zeta\\omega_n s + \\omega_n^2)}I(s)=s(s2+2ζωn​s+ωn2​)1​This should match your PATH A result!"},"title":"10_s_domain_diffeq"},"/electrical_notes/ee_300/1_s-domain_overview/":{"data":{"both-paths-lead-to-the-same-place#Both Paths Lead to the Same Place":"graph TD A[Time Domain Circuit:Find i_t for series RLC] --\u003e B[PATH A:Transform and solve] A --\u003e C[PATH B:Derive diff eq and transform] B --\u003e D[I_s = V_s_s / R + sL + 1/sC] C --\u003e E[Differential Equation:L d²i/dt² + R di/dt + i/C = dv_s/dt] E --\u003e F[Apply Laplace Transform] F --\u003e D D --\u003e G[Apply Inverse Laplace Transform] G --\u003e H[Same Final Answer:i_t in time domain] style A fill:#ffebee style D fill:#e8f5e9 style E fill:#ffe0b2 style H fill:#c8e6c9","comparison-table#Comparison Table":"Aspect PATH A PATH B First Step Transform to s-domain Apply KVL/KCL in time domain Circuit Laws Applied In s-domain In time domain Intermediate Result Algebraic equation in s Differential equation Shows Diff Eq? No (implicit) Yes (explicit) Speed Faster for complex circuits Slower, more steps Complexity Impedance algebra Differential equation manipulation Exam Preference More common Less common Learning Value Good for practical solving Better for understanding physics Best For Series/parallel RLC, complex circuits Simple RC/RL circuits","critical-difference#Critical Difference":"graph LR A[Same Time Domain Circuit] --\u003e B[PATH A: Transform First] A --\u003e C[PATH B: Derive Diff Eq First] B --\u003e D[Algebraic Equation in sV_s_s = I_s Z_s] C --\u003e E[Differential EquationL d²i/dt² + R di/dt + i = v_s] E --\u003e F[Apply Laplace Transform] F --\u003e D D --\u003e G[Same Final Result:I_s = V_s_s / Z_s] style A fill:#ffebee style D fill:#e8f5e9 style E fill:#ffe0b2 style G fill:#c8e6c9 Important: Both paths lead to the same s-domain result, but:\nPATH A never explicitly shows the differential equation PATH B makes the differential equation visible","decision-flow-chart#Decision Flow Chart":"graph TD A{What does the problem ask for?} --\u003e B[Convert to s-domain circuit] A --\u003e C[Find differential equation] A --\u003e D[Solve for v_t or i_t] B --\u003e E[Use PATH A] C --\u003e F{Do you need to showthe differential equation?} D --\u003e G{Is circuit simpleRC or RL?} F --\u003e|Yes| H[Use PATH B] F --\u003e|No| I[Use PATH Athen derive diff eq if needed] G --\u003e|Yes| J[Either path worksPATH B may be clearer] G --\u003e|No| K[Use PATH Amuch faster] E --\u003e L[Go to File 04-06] H --\u003e M[Go to File 07-09] I --\u003e L J --\u003e N[Choose based on preference] K --\u003e L style E fill:#e8f5e9 style H fill:#ffe0b2 style L fill:#e1f5ff style M fill:#e1f5ff","introduction#Introduction":"When analyzing circuits using Laplace transforms, there are two fundamentally different approaches you can take. Understanding which path to use and when is critical for efficient problem-solving.\nThis document provides an overview of both paths and helps you choose the right approach for your problem.","key-characteristics-of-path-a#Key Characteristics of PATH A":"Advantages:\nMost common in exams and textbooks Faster for complex circuits Works directly with impedances No need to explicitly write differential equation Algebraic manipulation only (after transformation) When to Use:\nProblem says “convert to s-domain” Complex circuits with multiple components Time pressure situations When you’re comfortable with impedance concepts What You Get: An equation like: Vs(s)=I(s)[R+sL+1sC]V_s(s) = I(s)[R + sL + \\frac{1}{sC}]Vs​(s)=I(s)[R+sL+sC1​]\nThis is algebraic in s, not a differential equation.","key-characteristics-of-path-b#Key Characteristics of PATH B":"Advantages:\nShows the physics more clearly Explicitly reveals the differential equation Better for understanding system behavior Natural for simple circuits When to Use:\nProblem explicitly asks for differential equation Simple circuits (RC or RL) You need to understand the underlying physics Educational/learning context What You Get: First a differential equation like: LCd2i(t)dt2+RCdi(t)dt+i(t)=vs(t)LC\\frac{d^2i(t)}{dt^2} + RC\\frac{di(t)}{dt} + i(t) = v_s(t)LCdt2d2i(t)​+RCdtdi(t)​+i(t)=vs​(t)\nThen after Laplace transform: LCs2I(s)+RCsI(s)+I(s)=Vs(s)LCs^2I(s) + RCsI(s) + I(s) = V_s(s)LCs2I(s)+RCsI(s)+I(s)=Vs​(s)","navigation-guide#Navigation Guide":"To learn PATH A (Direct s-Domain):\nRead 02-component-transformations.md (essential foundation) Read 04-path-a-time-to-sdomain.md Read 05-path-a-kvl-kcl-sdomain.md Read 03-initial-conditions.md Read 06-path-a-complete-process.md (complete examples) To learn PATH B (Differential Equation First):\nRead 02-component-transformations.md (still needed) Read 07-path-b-time-domain-analysis.md Read 08-path-b-laplace-transform.md Read 03-initial-conditions.md Read 09-path-b-complete-process.md (complete examples) To understand the connection:\nRead 10-sdomain-to-differential-equation.md (how to go backwards from PATH A to see the differential equation)","overview-and-analysis-paths#Overview and Analysis Paths":"Overview and Analysis Paths","path-a-direct-s-domain-transformation#PATH A: Direct s-Domain Transformation":"Go directly from time-domain circuit to s-domain, then apply circuit laws.\nResult: Algebraic equation in s (NOT a differential equation)","path-a-direct-s-domain-transformation-1#PATH A: Direct s-Domain Transformation":"graph TD A[Time Domain Circuit] --\u003e B[Transform Components to s-DomainR→R, C→1/sC, L→sL] B --\u003e C[Draw s-Domain Circuit] C --\u003e D[Apply KVL or KCL in s-Domain] D --\u003e E[Algebraic Equation in s] E --\u003e F[Add Initial Conditionswhen given] F --\u003e G[Solve for V_s or I_s] G --\u003e H[Ready for Inverse Laplace Transform] style A fill:#ffebee style C fill:#fff3e0 style E fill:#e8f5e9 style H fill:#c8e6c9","path-b-differential-equation-first#PATH B: Differential Equation First":"Apply circuit laws in time domain first, derive differential equation, then transform.\nResult: Explicitly written differential equation, then algebraic equation in s","path-b-differential-equation-first-1#PATH B: Differential Equation First":"graph TD A[Time Domain Circuit] --\u003e B[Apply KVL or KCL in Time Domain] B --\u003e C[Substitute Component Equationsv=Ri, v=L di/dt, i=C dv/dt] C --\u003e D[Manipulate to Single Variable] D --\u003e E[Differential Equation] E --\u003e F[Apply Laplace Transform] F --\u003e G[Use Differentiation PropertyL{df/dt} = sF_s - f_0] G --\u003e H[Substitute Initial Conditions] H --\u003e I[Algebraic Equation in s] I --\u003e J[Solve for V_s or I_s] J --\u003e K[Ready for Inverse Laplace Transform] style A fill:#ffebee style E fill:#ffe0b2 style I fill:#e8f5e9 style K fill:#c8e6c9","summary#Summary":"PATH A = Time domain → s-domain → Algebraic equation → Solve PATH B = Time domain → Differential equation → Laplace → Algebraic equation → Solve Both are valid Both give the same answer PATH A is more common and faster PATH B shows the physics more clearly Choose based on problem requirements and personal preference Next Steps: Proceed to 02-component-transformations.md to learn the fundamental transformation rules needed for both paths.","the-two-paths#The Two Paths":"","typical-exam-problem-structure#Typical Exam Problem Structure":"graph TD A[Problem Given:Time domain circuit diagram] --\u003e B[Part 1: Convert to s-domainDraw s-domain circuit] B --\u003e C[Part 2: Apply KVL or KCLGet equation in s] C --\u003e D[Part 3: NOW initial conditions givenAdd to circuit and equation] D --\u003e E[Part 4: Solve for V_s or I_s] E --\u003e F[Part 5: Apply inverse LaplaceFind v_t or i_t] style A fill:#ffebee style B fill:#fff3e0 style C fill:#e8f5e9 style D fill:#ffe0b2 style F fill:#c8e6c9 This structure follows PATH A because:\nYou transform before initial conditions are given You work in s-domain throughout Differential equation is not required","what-about-initial-conditions#What About Initial Conditions?":"Both paths handle initial conditions the same way:\nIn PATH A:\nTransform circuit first (without initial conditions) Apply circuit laws When initial conditions are given, add them as sources Update your equation In PATH B:\nWrite differential equation When initial conditions are given, use them in Laplace transform They appear in the differentiation property: L{dfdt}=sF(s)−f(0)\\mathcal{L}\\{\\frac{df}{dt}\\} = sF(s) - f(0)L{dtdf​}=sF(s)−f(0) Key Point: Initial conditions are often given AFTER you’ve set up the basic equation. This is intentional in exam problems.","which-path-should-you-learn-first#Which Path Should You Learn First?":"Recommendation: Learn PATH A first\nReasons:\nMore common in exams and homework More efficient for most circuits Builds impedance intuition Easier to verify results Then learn PATH B to:\nUnderstand what differential equation you’re actually solving Gain deeper physical insight Handle problems that explicitly ask for differential equations"},"title":"1_s-domain_overview"},"/electrical_notes/ee_300/2_component_transformations/":{"data":{"capacitor-impedance-units#Capacitor Impedance Units":"[ZC]=1[s][C]=1s−1⋅F=1s−1⋅sΩ=Ω[Z_C] = \\frac{1}{[s][C]} = \\frac{1}{s^{-1} \\cdot F} = \\frac{1}{s^{-1} \\cdot \\frac{s}{\\Omega}} = \\Omega[ZC​]=[s][C]1​=s−1⋅F1​=s−1⋅Ωs​1​=Ω [CHECK]","capacitor-transformation#Capacitor Transformation":"","check-correct-capacitor-transformation#[CHECK] CORRECT: Capacitor Transformation":"C = 0.1F → Z = 1/(sC) = 1/(0.1s) = 10/s","check-correct-including-s#[CHECK] CORRECT: Including s":"Z_total = R + sL + 1/(sC)","check-correct-inductor-transformation#[CHECK] CORRECT: Inductor Transformation":"L = 2H → Z = sL = 2s","common-current-source-functions#Common Current Source Functions":"Same transform pairs as voltage sources, just replace VVV with III:\nTime Domain s-Domain Transform I0u(t)I_0 u(t)I0​u(t) I0s\\frac{I_0}{s}sI0​​ I0e−atu(t)I_0 e^{-at}u(t)I0​e−atu(t) I0s+a\\frac{I_0}{s+a}s+aI0​​ I0sin⁡(ωt)u(t)I_0 \\sin(\\omega t)u(t)I0​sin(ωt)u(t) I0ωs2+ω2\\frac{I_0\\omega}{s^2+\\omega^2}s2+ω2I0​ω​ I0cos⁡(ωt)u(t)I_0 \\cos(\\omega t)u(t)I0​cos(ωt)u(t) I0ss2+ω2\\frac{I_0 s}{s^2+\\omega^2}s2+ω2I0​s​","common-mistakes-to-avoid#Common Mistakes to Avoid":"","common-voltage-source-functions#Common Voltage Source Functions":"Time Domain s-Domain Transform Name V0u(t)V_0 u(t)V0​u(t) V0s\\frac{V_0}{s}sV0​​ Step function V0e−atu(t)V_0 e^{-at}u(t)V0​e−atu(t) V0s+a\\frac{V_0}{s+a}s+aV0​​ Exponential V0sin⁡(ωt)u(t)V_0 \\sin(\\omega t)u(t)V0​sin(ωt)u(t) V0ωs2+ω2\\frac{V_0\\omega}{s^2+\\omega^2}s2+ω2V0​ω​ Sine wave V0cos⁡(ωt)u(t)V_0 \\cos(\\omega t)u(t)V0​cos(ωt)u(t) V0ss2+ω2\\frac{V_0 s}{s^2+\\omega^2}s2+ω2V0​s​ Cosine wave V0t⋅u(t)V_0 t \\cdot u(t)V0​t⋅u(t) V0s2\\frac{V_0}{s^2}s2V0​​ Ramp function V0δ(t)V_0 \\delta(t)V0​δ(t) V0V_0V0​ Impulse function","complete-transformation-table#Complete Transformation Table":"Component Time Domain s-Domain Impedance Z(s) Notes Resistor RRR RRR Unchanged Capacitor CCC 1sC\\frac{1}{sC}sC1​ Inversely proportional to s Inductor LLL sLsLsL Proportional to s Voltage Source vs(t)v_s(t)vs​(t) Vs(s)=L{vs(t)}V_s(s) = \\mathcal{L}\\{v_s(t)\\}Vs​(s)=L{vs​(t)} Transform the function Current Source is(t)i_s(t)is​(t) Is(s)=L{is(t)}I_s(s) = \\mathcal{L}\\{i_s(t)\\}Is​(s)=L{is​(t)} Transform the function","component-transformations-time-domain-to-s-domain#Component Transformations: Time Domain to s-Domain":"Component Transformations: Time Domain to s-Domain","current-source-transformation#Current Source Transformation":"","example-1-series-rc-circuit#Example 1: Series RC Circuit":"Time Domain:\nv_s(t) = 5u(t) V ---[R = 10Ω]---[C = 0.1F]--- ground s-Domain:\nV_s(s) = 5/s V ---[10Ω]---[10/s Ω]--- ground Calculations:\nSource: vs(t)=5u(t)→Vs(s)=5sv_s(t) = 5u(t) \\rightarrow V_s(s) = \\frac{5}{s}vs​(t)=5u(t)→Vs​(s)=s5​ Resistor: R=10ΩR = 10ΩR=10Ω (unchanged) Capacitor: ZC=1sC=1s⋅0.1=10sZ_C = \\frac{1}{sC} = \\frac{1}{s \\cdot 0.1} = \\frac{10}{s}ZC​=sC1​=s⋅0.11​=s10​ Total impedance: Ztotal=R+ZC=10+10s=10s+10sZ_{total} = R + Z_C = 10 + \\frac{10}{s} = \\frac{10s + 10}{s}Ztotal​=R+ZC​=10+s10​=s10s+10​","example-2-parallel-rl-circuit#Example 2: Parallel RL Circuit":"Time Domain:\ni_s(t) = 2e^{-3t}u(t) A | +----+----+ | | | R=4Ω L=2H | | | ground ground s-Domain:\nI_s(s) = 2/(s+3) A | +----+----+ | | | 4Ω 2s Ω | | | ground ground Calculations:\nSource: is(t)=2e−3tu(t)→Is(s)=2s+3i_s(t) = 2e^{-3t}u(t) \\rightarrow I_s(s) = \\frac{2}{s+3}is​(t)=2e−3tu(t)→Is​(s)=s+32​ Resistor: R=4ΩR = 4ΩR=4Ω (unchanged) Inductor: ZL=sL=2sZ_L = sL = 2sZL​=sL=2s Total impedance: Ztotal=R⋅ZLR+ZL=4⋅2s4+2s=8s2(2+s)=4ss+2Z_{total} = \\frac{R \\cdot Z_L}{R + Z_L} = \\frac{4 \\cdot 2s}{4 + 2s} = \\frac{8s}{2(2 + s)} = \\frac{4s}{s+2}Ztotal​=R+ZL​R⋅ZL​​=4+2s4⋅2s​=2(2+s)8s​=s+24s​","example-3-series-rlc-circuit#Example 3: Series RLC Circuit":"Time Domain:\nv_s(t) = 10\\cos(5t)u(t) V ---[R=2Ω]---[L=0.4H]---[C=0.05F]--- ground s-Domain:\nV_s(s) = 10s/(s²+25) V ---[2Ω]---[0.4s Ω]---[20/s Ω]--- ground Calculations:\nSource: vs(t)=10cos⁡(5t)u(t)→Vs(s)=10ss2+25v_s(t) = 10\\cos(5t)u(t) \\rightarrow V_s(s) = \\frac{10s}{s^2+25}vs​(t)=10cos(5t)u(t)→Vs​(s)=s2+2510s​ Resistor: R=2ΩR = 2ΩR=2Ω (unchanged) Inductor: ZL=sL=0.4sZ_L = sL = 0.4sZL​=sL=0.4s Capacitor: ZC=1sC=10.05s=20sZ_C = \\frac{1}{sC} = \\frac{1}{0.05s} = \\frac{20}{s}ZC​=sC1​=0.05s1​=s20​ Total impedance: Ztotal=2+0.4s+20s=2s+0.4s2+20s=0.4s2+2s+20sZ_{total} = 2 + 0.4s + \\frac{20}{s} = \\frac{2s + 0.4s^2 + 20}{s} = \\frac{0.4s^2 + 2s + 20}{s}Ztotal​=2+0.4s+s20​=s2s+0.4s2+20​=s0.4s2+2s+20​","frequency-behavior-comparison#Frequency Behavior Comparison":"graph TD A[Frequency Response] --\u003e B[Capacitor: Z = 1/sC] A --\u003e C[Inductor: Z = sL] A --\u003e D[Resistor: Z = R] B --\u003e B1[DC s→0: Open Circuit] B --\u003e B2[High Freq s→∞: Short Circuit] C --\u003e C1[DC s→0: Short Circuit] C --\u003e C2[High Freq s→∞: Open Circuit] D --\u003e D1[All Frequencies: Constant R] style B1 fill:#ffebee style B2 fill:#e1f5ff style C1 fill:#e1f5ff style C2 fill:#ffebee style D1 fill:#e8f5e9","inductor-impedance-units#Inductor Impedance Units":"[ZL]=[s][L]=s−1⋅H=s−1⋅(Ω⋅s)=Ω[Z_L] = [s][L] = s^{-1} \\cdot H = s^{-1} \\cdot (\\Omega \\cdot s) = \\Omega[ZL​]=[s][L]=s−1⋅H=s−1⋅(Ω⋅s)=Ω [CHECK]","inductor-transformation#Inductor Transformation":"","introduction#Introduction":"This document covers the fundamental transformation rules for converting circuit components from the time domain to the s-domain (Laplace domain). These transformations are essential for both PATH A and PATH B.","parallel-impedances#Parallel Impedances":"Just like resistors: 1Ztotal=1Z1+1Z2+1Z3+⋯\\frac{1}{Z_{total}} = \\frac{1}{Z_1} + \\frac{1}{Z_2} + \\frac{1}{Z_3} + \\cdotsZtotal​1​=Z1​1​+Z2​1​+Z3​1​+⋯For two impedances: Ztotal=Z1Z2Z1+Z2Z_{total} = \\frac{Z_1 Z_2}{Z_1 + Z_2}Ztotal​=Z1​+Z2​Z1​Z2​​Example - Parallel RLC: 1Ztotal=1R+1sL+sC\\frac{1}{Z_{total}} = \\frac{1}{R} + \\frac{1}{sL} + sCZtotal​1​=R1​+sL1​+sC","quick-reference-transformation-rules#Quick Reference: Transformation Rules":"graph TD A[Component in Time Domain] --\u003e B{What type?} B --\u003e|Resistor R| C[Keep as R] B --\u003e|Capacitor C| D[Replace with 1/sC] B --\u003e|Inductor L| E[Replace with sL] B --\u003e|Voltage Source v_s_t| F[Transform to V_s_s] B --\u003e|Current Source i_s_t| G[Transform to I_s_s] C --\u003e H[s-Domain Circuit] D --\u003e H E --\u003e H F --\u003e H G --\u003e H style A fill:#ffebee style H fill:#e8f5e9","resistor-transformation#Resistor Transformation":"","s-domain-impedance#s-Domain Impedance":"ZR(s)=RZ_R(s) = RZR​(s)=R","s-domain-impedance-1#s-Domain Impedance":"ZC(s)=1sCZ_C(s) = \\frac{1}{sC}ZC​(s)=sC1​","s-domain-impedance-2#s-Domain Impedance":"ZL(s)=sLZ_L(s) = sLZL​(s)=sL","s-domain-ohms-law#s-Domain Ohm\u0026rsquo;s Law":"VR(s)=R⋅IR(s)V_R(s) = R \\cdot I_R(s)VR​(s)=R⋅IR​(s)","s-domain-ohms-law-1#s-Domain Ohm\u0026rsquo;s Law":"VC(s)=1sC⋅IC(s)V_C(s) = \\frac{1}{sC} \\cdot I_C(s)VC​(s)=sC1​⋅IC​(s) IC(s)=sC⋅VC(s)I_C(s) = sC \\cdot V_C(s)IC​(s)=sC⋅VC​(s)","s-domain-ohms-law-2#s-Domain Ohm\u0026rsquo;s Law":"VL(s)=sL⋅IL(s)V_L(s) = sL \\cdot I_L(s)VL​(s)=sL⋅IL​(s) IL(s)=VL(s)sLI_L(s) = \\frac{V_L(s)}{sL}IL​(s)=sLVL​(s)​","series-and-parallel-impedances#Series and Parallel Impedances":"","series-impedances#Series Impedances":"Just like resistors: Ztotal=Z1+Z2+Z3+⋯Z_{total} = Z_1 + Z_2 + Z_3 + \\cdotsZtotal​=Z1​+Z2​+Z3​+⋯Example - Series RLC: Ztotal=R+sL+1sCZ_{total} = R + sL + \\frac{1}{sC}Ztotal​=R+sL+sC1​","summary#Summary":"Component Transformation Frequency Behavior Resistor R→RR \\rightarrow RR→R Independent of frequency Capacitor C→1sCC \\rightarrow \\frac{1}{sC}C→sC1​ High Z at low freq, Low Z at high freq Inductor L→sLL \\rightarrow sLL→sL Low Z at low freq, High Z at high freq Voltage Source vs(t)→Vs(s)v_s(t) \\rightarrow V_s(s)vs​(t)→Vs​(s) Apply Laplace transform Current Source is(t)→Is(s)i_s(t) \\rightarrow I_s(s)is​(t)→Is​(s) Apply Laplace transform Note: Initial conditions are NOT included in these basic transformations. They are added separately as voltage or current sources. See 03-initial-conditions.md for details.\nNext Steps:\nFor PATH A: Proceed to 04-path-a-time-to-sdomain.md For PATH B: Proceed to 07-path-b-time-domain-analysis.md For initial conditions: See 03-initial-conditions.md","the-basic-principle#The Basic Principle":"In the s-domain, we replace time-domain relationships with frequency-domain (s-domain) impedances.\ngraph LR A[Time Domainv_t and i_t relationships] --\u003e B[Laplace Transform] B --\u003e C[s-DomainV_s and I_s with impedances] style A fill:#ffebee style C fill:#e8f5e9","time-domain-relationship#Time Domain Relationship":"vR(t)=R⋅iR(t)v_R(t) = R \\cdot i_R(t)vR​(t)=R⋅iR​(t) iR(t)=vR(t)Ri_R(t) = \\frac{v_R(t)}{R}iR​(t)=RvR​(t)​","time-domain-relationships#Time Domain Relationships":"iC(t)=CdvC(t)dti_C(t) = C \\frac{dv_C(t)}{dt}iC​(t)=CdtdvC​(t)​ vC(t)=1C∫0tiC(τ)dτ+vC(0)v_C(t) = \\frac{1}{C}\\int_{0}^{t} i_C(\\tau)d\\tau + v_C(0)vC​(t)=C1​∫0t​iC​(τ)dτ+vC​(0)","time-domain-relationships-1#Time Domain Relationships":"vL(t)=LdiL(t)dtv_L(t) = L \\frac{di_L(t)}{dt}vL​(t)=LdtdiL​(t)​ iL(t)=1L∫0tvL(τ)dτ+iL(0)i_L(t) = \\frac{1}{L}\\int_{0}^{t} v_L(\\tau)d\\tau + i_L(0)iL​(t)=L1​∫0t​vL​(τ)dτ+iL​(0)","transformation#Transformation":"graph LR A[Resistor R Ω] --\u003e|No change| B[Resistor R Ω] style A fill:#ffebee style B fill:#e8f5e9 Key Points:\nResistors remain unchanged in s-domain Same value, same units (Ohms) Simplest component to transform","transformation-1#Transformation":"graph LR A[Capacitor C farads] --\u003e|Transform| B[Impedance 1/sC Ω] style A fill:#ffebee style B fill:#e8f5e9 Key Points:\nImpedance is inversely proportional to both s and C At low frequencies (s → 0): impedance → ∞ (open circuit) At high frequencies (s → ∞): impedance → 0 (short circuit) Unit: Ohms (Ω)","transformation-2#Transformation":"graph LR A[Inductor L henries] --\u003e|Transform| B[Impedance sL Ω] style A fill:#ffebee style B fill:#e8f5e9 Key Points:\nImpedance is proportional to both s and L At low frequencies (s → 0): impedance → 0 (short circuit) At high frequencies (s → ∞): impedance → ∞ (open circuit) Unit: Ohms (Ω)","transformation-examples#Transformation Examples":"","transformation-process#Transformation Process":"graph LR A[v_s_t = 10u_t V] --\u003e|Laplace Transform| B[V_s_s = 10/s V] style A fill:#ffebee style B fill:#e8f5e9 Important: Always include u(t)u(t)u(t) when the source turns on at t=0t=0t=0.","unit-verification#Unit Verification":"All impedances must have units of Ohms (Ω).","voltage-source-transformation#Voltage Source Transformation":"","why-1sc#Why 1/sC?":"Taking Laplace transform of the capacitor current equation: iC(t)=CdvC(t)dti_C(t) = C \\frac{dv_C(t)}{dt}iC​(t)=CdtdvC​(t)​IC(s)=C[sVC(s)−vC(0)]I_C(s) = C[sV_C(s) - v_C(0)]IC​(s)=C[sVC​(s)−vC​(0)]Without initial condition (or with it as a separate source): IC(s)=sC⋅VC(s)I_C(s) = sC \\cdot V_C(s)IC​(s)=sC⋅VC​(s)Therefore: VC(s)=1sC⋅IC(s)V_C(s) = \\frac{1}{sC} \\cdot I_C(s)VC​(s)=sC1​⋅IC​(s)This is Ohm’s law with impedance ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​","why-sl#Why sL?":"Taking Laplace transform of the inductor voltage equation: vL(t)=LdiL(t)dtv_L(t) = L \\frac{di_L(t)}{dt}vL​(t)=LdtdiL​(t)​VL(s)=L[sIL(s)−iL(0)]V_L(s) = L[sI_L(s) - i_L(0)]VL​(s)=L[sIL​(s)−iL​(0)]Without initial condition (or with it as a separate source): VL(s)=sL⋅IL(s)V_L(s) = sL \\cdot I_L(s)VL​(s)=sL⋅IL​(s)This is Ohm’s law with impedance ZL=sLZ_L = sLZL​=sL","x-wrong-capacitor-transformation#[X] WRONG: Capacitor Transformation":"C = 0.1F → Z = 0.1sC (NO!) C = 0.1F → Z = sC (NO!) C = 0.1F → Z = C (NO!)","x-wrong-forgetting-the-s-variable#[X] WRONG: Forgetting the s Variable":"Z_total = R + L + 1/C (NO! Missing s)","x-wrong-inductor-transformation#[X] WRONG: Inductor Transformation":"L = 2H → Z = L/s (NO!) L = 2H → Z = 1/(sL) (NO!) L = 2H → Z = L (NO!)"},"title":"2_component_transformations"},"/electrical_notes/ee_300/3_initial_conditions/":{"data":{"adding-initial-conditions-to-equations#Adding Initial Conditions to Equations":"","capacitor-initial-condition-polarity#Capacitor Initial Condition Polarity":"The voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ has polarity matching the stored voltage:\nIf capacitor top plate is positive → voltage source + on top The source represents the voltage the capacitor starts with","capacitor-initial-conditions#Capacitor Initial Conditions":"","check-correct#[CHECK] CORRECT:":"v_C(0) = 5V → Add voltage source 5/s V","check-correct-1#[CHECK] CORRECT:":"i_L(0) = 2A, L = 3H → Add voltage source Li_L(0) = 6V","check-correct-2#[CHECK] CORRECT:":"i_L(0) = 2A → Add current source 2/s A","circuit-representation#Circuit Representation":"Without initial condition:\n---[ 1/sC ]--- With initial condition vC(0)v_C(0)vC​(0):\n---[ 1/sC ]---[+]--- [v_C(0)/s] [-] The polarity: positive terminal is where the capacitor was positively charged.","circuit-representation---parallel-form#Circuit Representation - Parallel Form":"With initial condition iL(0)i_L(0)iL​(0) (parallel form):\n[ sL ] ---+----||----+--- | | [i_L(0)/s]→ | | The current source flows in the direction of initial current.","circuit-representation---series-form#Circuit Representation - Series Form":"Without initial condition:\n---[ sL ]--- With initial condition iL(0)i_L(0)iL​(0) (series form):\n---[ sL ]---[+]--- [Li_L(0)] [-] Polarity: opposes the change in current (back-EMF)","common-mistakes#Common Mistakes":"","complete-transformation-examples#Complete Transformation Examples":"","derivation#Derivation":"From the capacitor current equation: iC(t)=CdvC(t)dti_C(t) = C \\frac{dv_C(t)}{dt}iC​(t)=CdtdvC​(t)​Taking Laplace transform: IC(s)=C[sVC(s)−vC(0)]I_C(s) = C[sV_C(s) - v_C(0)]IC​(s)=C[sVC​(s)−vC​(0)]Rearranging: IC(s)=sC⋅VC(s)−C⋅vC(0)I_C(s) = sC \\cdot V_C(s) - C \\cdot v_C(0)IC​(s)=sC⋅VC​(s)−C⋅vC​(0)Using Ohm’s law form: VC(s)=IC(s)sC+vC(0)sV_C(s) = \\frac{I_C(s)}{sC} + \\frac{v_C(0)}{s}VC​(s)=sCIC​(s)​+svC​(0)​This shows: impedance 1sC\\frac{1}{sC}sC1​ with voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ in series.","derivation---parallel-form#Derivation - Parallel Form":"Using the integral form: iL(t)=1L∫0tvL(τ)dτ+iL(0)i_L(t) = \\frac{1}{L}\\int_{0}^{t} v_L(\\tau)d\\tau + i_L(0)iL​(t)=L1​∫0t​vL​(τ)dτ+iL​(0)Taking Laplace transform: IL(s)=VL(s)sL+iL(0)sI_L(s) = \\frac{V_L(s)}{sL} + \\frac{i_L(0)}{s}IL​(s)=sLVL​(s)​+siL​(0)​This shows: impedance sLsLsL with current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​ in parallel.","derivation---series-form#Derivation - Series Form":"From the inductor voltage equation: vL(t)=LdiL(t)dtv_L(t) = L \\frac{di_L(t)}{dt}vL​(t)=LdtdiL​(t)​Taking Laplace transform: VL(s)=L[sIL(s)−iL(0)]V_L(s) = L[sI_L(s) - i_L(0)]VL​(s)=L[sIL​(s)−iL​(0)]Rearranging: VL(s)=sL⋅IL(s)−L⋅iL(0)V_L(s) = sL \\cdot I_L(s) - L \\cdot i_L(0)VL​(s)=sL⋅IL​(s)−L⋅iL​(0)This shows: impedance sLsLsL with voltage source LiL(0)Li_L(0)LiL​(0) in series.","equivalence-of-two-forms#Equivalence of Two Forms":"The series and parallel forms are equivalent by source transformation:\nLiL(0) in series with sL≡iL(0)s in parallel with sLLi_L(0) \\text{ in series with } sL \\equiv \\frac{i_L(0)}{s} \\text{ in parallel with } sLLiL​(0) in series with sL≡siL​(0)​ in parallel with sLVerification: LiL(0)sL=iL(0)s\\frac{Li_L(0)}{sL} = \\frac{i_L(0)}{s}sLLiL​(0)​=siL​(0)​ [CHECK]","example-1-series-rc-with-initial-conditions#Example 1: Series RC with Initial Conditions":"Given:\nR=50ΩR = 50ΩR=50Ω, C=20μFC = 20μFC=20μF vC(0)=10Vv_C(0) = 10VvC​(0)=10V vs(t)=100u(t)Vv_s(t) = 100u(t)Vvs​(t)=100u(t)V s-Domain circuit:\nV_s(s)=100/s ---[50Ω]---[50000/s Ω]---[+]--- ground [10/s V] [-] Calculations:\nZC=1sC=1s⋅20×10−6=50000sZ_C = \\frac{1}{sC} = \\frac{1}{s \\cdot 20 \\times 10^{-6}} = \\frac{50000}{s}ZC​=sC1​=s⋅20×10−61​=s50000​ Initial condition: vC(0)s=10s\\frac{v_C(0)}{s} = \\frac{10}{s}svC​(0)​=s10​","example-2-series-rl-with-initial-conditions-kvl#Example 2: Series RL with Initial Conditions (KVL)":"Given:\nR=10ΩR = 10ΩR=10Ω, L=0.5HL = 0.5HL=0.5H iL(0)=2Ai_L(0) = 2AiL​(0)=2A vs(t)=20e−tu(t)Vv_s(t) = 20e^{-t}u(t)Vvs​(t)=20e−tu(t)V s-Domain circuit:\nV_s(s)=20/(s+1) ---[10Ω]---[0.5s Ω]---[+]--- ground [1 V] [-] Calculations:\nZL=sL=0.5sZ_L = sL = 0.5sZL​=sL=0.5s Initial condition: LiL(0)=0.5×2=1VLi_L(0) = 0.5 \\times 2 = 1VLiL​(0)=0.5×2=1V","example-3-parallel-rlc-with-initial-conditions-kcl#Example 3: Parallel RLC with Initial Conditions (KCL)":"Given:\nR=5ΩR = 5ΩR=5Ω, L=1HL = 1HL=1H, C=0.1FC = 0.1FC=0.1F vC(0)=0Vv_C(0) = 0VvC​(0)=0V, iL(0)=3Ai_L(0) = 3AiL​(0)=3A is(t)=4u(t)Ai_s(t) = 4u(t)Ais​(t)=4u(t)A s-Domain circuit:\nI_s(s) = 4/s | +----+----+----+ | | | | 5Ω [s Ω][3/s A] ---[10/s]---[+]--- | | || | | [0] ground +----+---+ ground Since vC(0)=0v_C(0) = 0vC​(0)=0, the capacitor has no initial condition source.\nThe inductor uses parallel form for KCL: iL(0)s=3s\\frac{i_L(0)}{s} = \\frac{3}{s}siL​(0)​=s3​","example-capacitor-with-initial-voltage#Example: Capacitor with Initial Voltage":"Given: C=0.1FC = 0.1FC=0.1F, vC(0)=5Vv_C(0) = 5VvC​(0)=5V\ns-Domain representation:\n---[ 10/s Ω ]---[+]--- [5/s V] [-] Where:\nZC=1sC=10.1s=10sZ_C = \\frac{1}{sC} = \\frac{1}{0.1s} = \\frac{10}{s}ZC​=sC1​=0.1s1​=s10​ Initial condition source = vC(0)s=5s\\frac{v_C(0)}{s} = \\frac{5}{s}svC​(0)​=s5​","example-inductor-with-initial-current#Example: Inductor with Initial Current":"Given: L=2HL = 2HL=2H, iL(0)=3Ai_L(0) = 3AiL​(0)=3A\nSeries form (for KVL):\n---[ 2s Ω ]---[+]--- [6 V] [-] Where:\nZL=sL=2sZ_L = sL = 2sZL​=sL=2s Initial condition source = LiL(0)=2×3=6VLi_L(0) = 2 \\times 3 = 6VLiL​(0)=2×3=6V Parallel form (for KCL):\n[ 2s Ω ] ---+----||----+--- | | [3/s A]→ | | Where:\nZL=sL=2sZ_L = sL = 2sZL​=sL=2s Initial condition source = iL(0)s=3s\\frac{i_L(0)}{s} = \\frac{3}{s}siL​(0)​=s3​","for-kcl-node-analysis#For KCL (Node Analysis)":"Basic equation without initial conditions: Is(s)=V(s)Z1+V(s)Z2+⋯I_s(s) = \\frac{V(s)}{Z_1} + \\frac{V(s)}{Z_2} + \\cdotsIs​(s)=Z1​V(s)​+Z2​V(s)​+⋯With initial conditions (capacitor): Is(s)=V(s)−vC(0)sZC+V(s)Z1+⋯I_s(s) = \\frac{V(s) - \\frac{v_C(0)}{s}}{Z_C} + \\frac{V(s)}{Z_1} + \\cdotsIs​(s)=ZC​V(s)−svC​(0)​​+Z1​V(s)​+⋯With initial conditions (inductor, parallel form): Is(s)+Iinitial,L(s)=V(s)ZL+V(s)Z1+⋯I_s(s) + I_{initial,L}(s) = \\frac{V(s)}{Z_L} + \\frac{V(s)}{Z_1} + \\cdotsIs​(s)+Iinitial,L​(s)=ZL​V(s)​+Z1​V(s)​+⋯Where Iinitial,L(s)=iL(0)sI_{initial,L}(s) = \\frac{i_L(0)}{s}Iinitial,L​(s)=siL​(0)​","for-kvl-series-circuits#For KVL (Series Circuits)":"Basic equation without initial conditions: Vs(s)=I(s)[Z1+Z2+⋯ ]V_s(s) = I(s)[Z_1 + Z_2 + \\cdots]Vs​(s)=I(s)[Z1​+Z2​+⋯]With initial conditions: Vs(s)=I(s)[Z1+Z2+⋯ ]+Vinitial,C(s)+Vinitial,L(s)V_s(s) = I(s)[Z_1 + Z_2 + \\cdots] + V_{initial,C}(s) + V_{initial,L}(s)Vs​(s)=I(s)[Z1​+Z2​+⋯]+Vinitial,C​(s)+Vinitial,L​(s)Where:\nVinitial,C(s)=vC(0)sV_{initial,C}(s) = \\frac{v_C(0)}{s}Vinitial,C​(s)=svC​(0)​ Vinitial,L(s)=LiL(0)V_{initial,L}(s) = Li_L(0)Vinitial,L​(s)=LiL​(0)","inductor-initial-condition-polarity#Inductor Initial Condition Polarity":"Series form: The voltage source LiL(0)Li_L(0)LiL​(0) opposes current change\nActs like back-EMF Polarity opposes the direction you’d expect from applied voltage Parallel form: The current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​ flows in the same direction as initial current\nRepresents the current the inductor wants to maintain","inductor-initial-conditions#Inductor Initial Conditions":"","initial-conditions-in-s-domain-analysis#Initial Conditions in s-Domain Analysis":"Initial Conditions in s-Domain Analysis","introduction#Introduction":"Initial conditions represent the stored energy in capacitors and inductors at time t=0t = 0t=0. This document explains how to properly include initial conditions in s-domain circuit analysis.","next-steps#Next Steps":"For PATH A: See 04-path-a-time-to-sdomain.md for complete transformation process For PATH B: See 08-path-b-laplace-transform.md for how initial conditions appear in Laplace transforms For examples: See 06-path-a-complete-process.md and 09-path-b-complete-process.md","polarity-conventions#Polarity Conventions":"","s-domain-representation#s-Domain Representation":"Add a voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ in series with the capacitor impedance 1sC\\frac{1}{sC}sC1​.\ngraph LR A[Capacitor Cwith v_C0] --\u003e|Transform| B[1/sC in series withvoltage source v_C0/s] style A fill:#ffebee style B fill:#e8f5e9","s-domain-representation-two-options#s-Domain Representation (Two Options)":"Option A - Series Voltage Source (for KVL/Mesh): Add voltage source LiL(0)Li_L(0)LiL​(0) in series with impedance sLsLsL\nOption B - Parallel Current Source (for KCL/Node): Add current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​ in parallel with impedance sLsLsL\ngraph TD A[Inductor Lwith i_L0] --\u003e B{Which form?} B --\u003e|KVL/Mesh| C[Series:sL with voltage Li_L0] B --\u003e|KCL/Node| D[Parallel:sL with current i_L0/s] C --\u003e E[Both are equivalent] D --\u003e E style A fill:#ffebee style C fill:#e8f5e9 style D fill:#e8f5e9","summary-table#Summary Table":"Component Initial Condition s-Domain Addition When to Use Capacitor vC(0)v_C(0)vC​(0) Series voltage vC(0)s\\frac{v_C(0)}{s}svC​(0)​ Always Inductor (KVL) iL(0)i_L(0)iL​(0) Series voltage LiL(0)Li_L(0)LiL​(0) Mesh analysis Inductor (KCL) iL(0)i_L(0)iL​(0) Parallel current iL(0)s\\frac{i_L(0)}{s}siL​(0)​ Node analysis","time-domain-representation#Time Domain Representation":"At t=0−t = 0^-t=0−, the capacitor has voltage vC(0)v_C(0)vC​(0) stored.","time-domain-representation-1#Time Domain Representation":"At t=0−t = 0^-t=0−, the inductor has current iL(0)i_L(0)iL​(0) flowing through it.","when-are-initial-conditions-given#When Are Initial Conditions Given?":"graph TD A[Circuit Problem] --\u003e B{When are initialconditions specified?} B --\u003e|At the start| C[Include immediatelyin transformation] B --\u003e|After s-domain setup| D[Add after gettingbasic equation] B --\u003e|Not specified| E[Either zero or must solvefrom t \u003c 0 circuit] C --\u003e F[Less common] D --\u003e G[More common in exams] E --\u003e H[Check problem statement] style D fill:#ffe0b2 style G fill:#e8f5e9 Most exam problems: Give initial conditions AFTER you’ve drawn the s-domain circuit and written the basic equation.","when-to-use-which-form#When to Use Which Form":"graph TD A{What analysis method?} --\u003e B[Using KVLMesh Analysis] A --\u003e C[Using KCLNode Analysis] B --\u003e D[Capacitor: Series voltage v_C0/sInductor: Series voltage Li_L0] C --\u003e E[Capacitor: Series voltage v_C0/sInductor: Parallel current i_L0/s] style D fill:#e8f5e9 style E fill:#e8f5e9 General Rule:\nKVL/Mesh: Use series voltage sources for both components KCL/Node: Use series voltage for capacitor, parallel current for inductor","why-initial-conditions-matter#Why Initial Conditions Matter":"Energy storage elements (capacitors and inductors) have “memory”:\nCapacitors store energy in electric fields → voltage across capacitor at t=0t=0t=0 Inductors store energy in magnetic fields → current through inductor at t=0t=0t=0 These initial states affect the circuit response and must be included for accurate analysis.","x-wrong-capacitor-initial-condition#[X] WRONG: Capacitor Initial Condition":"v_C(0) = 5V → Add voltage source 5V (NO! Missing /s)","x-wrong-inductor-initial-condition-parallel#[X] WRONG: Inductor Initial Condition (Parallel)":"i_L(0) = 2A → Add current source 2A (NO! Missing /s)","x-wrong-inductor-initial-condition-series#[X] WRONG: Inductor Initial Condition (Series)":"i_L(0) = 2A, L = 3H → Add voltage source 2V (NO! Missing L)","zero-initial-conditions#Zero Initial Conditions":"If initial conditions are not specified, you typically assume:\nvC(0)=0v_C(0) = 0vC​(0)=0 (capacitor uncharged) iL(0)=0i_L(0) = 0iL​(0)=0 (inductor unenergized) This means the circuit was de-energized before t=0t=0t=0.\nException: If the problem describes steady-state operation before t=0t=0t=0, you must solve for initial conditions from the t\u003c0t \u003c 0t\u003c0 circuit."},"title":"3_initial_conditions"},"/electrical_notes/ee_300/4_time_to_s-domain/":{"data":{"combining-impedances-in-s-domain#Combining Impedances in s-Domain":"","common-circuit-topologies#Common Circuit Topologies":"","current-divider#Current Divider":"graph TD A[I_in_s] --\u003e B{Node} B --\u003e C[Z1I1_s] B --\u003e D[Z2I2_s] C --\u003e E[Ground] D --\u003e E style A fill:#ffebee style C fill:#e8f5e9 Formula: I1(s)=Iin(s)⋅Z2Z1+Z2I_1(s) = I_{in}(s) \\cdot \\frac{Z_2}{Z_1 + Z_2}I1​(s)=Iin​(s)⋅Z1​+Z2​Z2​​","example-1-series-rc-circuit#Example 1: Series RC Circuit":"","example-2-parallel-rl-circuit#Example 2: Parallel RL Circuit":"","example-3-series-rlc-circuit#Example 3: Series RLC Circuit":"","impedance-simplification-strategies#Impedance Simplification Strategies":"","next-steps#Next Steps":"Proceed to: 05-path-a-kvl-kcl-sdomain.md to learn how to apply circuit laws to your s-domain circuit.\nIf you need initial conditions: You’ll add them after setting up the basic equation (see 03-initial-conditions.md).","overview#Overview":"PATH A is the direct transformation approach where you convert the entire circuit to s-domain first, then apply circuit analysis laws. This is the most common method in exams and professional practice.\ngraph TD A[Time Domain Circuit] --\u003e B[Transform Each Component] B --\u003e C[Draw s-Domain Circuit] C --\u003e D[Apply Circuit Laws in s-Domain] D --\u003e E[Algebraic Equation in s] style A fill:#ffebee style C fill:#fff3e0 style E fill:#e8f5e9","parallel-impedances#Parallel Impedances":"Just like resistors in parallel: 1Ztotal=1Z1+1Z2+1Z3+⋯\\frac{1}{Z_{total}} = \\frac{1}{Z_1} + \\frac{1}{Z_2} + \\frac{1}{Z_3} + \\cdotsZtotal​1​=Z1​1​+Z2​1​+Z3​1​+⋯For two impedances: Ztotal=Z1Z2Z1+Z2Z_{total} = \\frac{Z_1 Z_2}{Z_1 + Z_2}Ztotal​=Z1​+Z2​Z1​Z2​​Example: ZRLC,parallel=11R+1sL+sCZ_{RLC,parallel} = \\frac{1}{\\frac{1}{R} + \\frac{1}{sL} + sC}ZRLC,parallel​=R1​+sL1​+sC1​","path-a-time-domain-to-s-domain-circuit-transformation#PATH A: Time Domain to s-Domain Circuit Transformation":"PATH A: Time Domain to s-Domain Circuit Transformation","s-domain-circuit-without-initial-conditions#s-Domain Circuit (without initial conditions)":"V_s(s) = 10/s V ----[100Ω]----[10⁵/s Ω]---- ground Total impedance: Ztotal=R+ZC=100+105s=100s+105sZ_{total} = R + Z_C = 100 + \\frac{10^5}{s} = \\frac{100s + 10^5}{s}Ztotal​=R+ZC​=100+s105​=s100s+105​","s-domain-circuit-without-initial-conditions-1#s-Domain Circuit (without initial conditions)":"I_s(s) = 2/(s+3) A | +----+----+ | | 4Ω 2s Ω | | ground ground Total impedance (parallel): Ztotal=R⋅ZLR+ZL=4⋅2s4+2s=8s2(2+s)=4ss+2Z_{total} = \\frac{R \\cdot Z_L}{R + Z_L} = \\frac{4 \\cdot 2s}{4 + 2s} = \\frac{8s}{2(2+s)} = \\frac{4s}{s+2}Ztotal​=R+ZL​R⋅ZL​​=4+2s4⋅2s​=2(2+s)8s​=s+24s​","s-domain-circuit-without-initial-conditions-2#s-Domain Circuit (without initial conditions)":"V_s(s) = 10s/(s²+25) V ----[2Ω]----[0.4s Ω]----[20/s Ω]---- ground Total impedance: Ztotal=R+ZL+ZC=2+0.4s+20sZ_{total} = R + Z_L + Z_C = 2 + 0.4s + \\frac{20}{s}Ztotal​=R+ZL​+ZC​=2+0.4s+s20​Combining over common denominator: Ztotal=2s+0.4s2+20s=0.4s2+2s+20sZ_{total} = \\frac{2s + 0.4s^2 + 20}{s} = \\frac{0.4s^2 + 2s + 20}{s}Ztotal​=s2s+0.4s2+20​=s0.4s2+2s+20​","series-impedances#Series Impedances":"Just like resistors in series: Ztotal=Z1+Z2+Z3+⋯Z_{total} = Z_1 + Z_2 + Z_3 + \\cdotsZtotal​=Z1​+Z2​+Z3​+⋯Example: ZRLC,series=R+sL+1sCZ_{RLC,series} = R + sL + \\frac{1}{sC}ZRLC,series​=R+sL+sC1​","step-1-identify-all-circuit-components#Step 1: Identify All Circuit Components":"Before transforming, inventory your circuit:\nPassive elements: Resistors, capacitors, inductors Active elements: Voltage sources, current sources Connections: Series, parallel, nodes","step-2-transform-each-component#Step 2: Transform Each Component":"Apply transformation rules from 02-component-transformations.md:\nComponent Time Domain s-Domain Resistor R Ω R Ω Capacitor C farads 1/(sC) Ω Inductor L henries sL Ω Voltage Source v_s(t) V_s(s) = ℒ{v_s(t)} Current Source i_s(t) I_s(s) = ℒ{i_s(t)} Important: Do NOT include initial conditions yet. They will be added later.","step-3-draw-the-s-domain-circuit#Step 3: Draw the s-Domain Circuit":"Create a new circuit diagram with:\nAll impedances replacing reactive components Transformed sources Same topology (connections) as original Label all nodes and currents clearly graph LR A[Original Time Domain Circuit] --\u003e B[Replace R with R] A --\u003e C[Replace C with 1/sC] A --\u003e D[Replace L with sL] A --\u003e E[Transform Sources] B --\u003e F[s-Domain Circuit] C --\u003e F D --\u003e F E --\u003e F style A fill:#ffebee style F fill:#e8f5e9","step-by-step-process#Step-by-Step Process":"","strategy-1-find-common-denominator#Strategy 1: Find Common Denominator":"When adding impedances with fractions:\nR+1sC=RsC+1sCR + \\frac{1}{sC} = \\frac{RsC + 1}{sC}R+sC1​=sCRsC+1​sL+1sC=s2LC+1sCsL + \\frac{1}{sC} = \\frac{s^2LC + 1}{sC}sL+sC1​=sCs2LC+1​","strategy-2-factor-first#Strategy 2: Factor First":"R+sL+1sC=RsC+s2LC+1sCR + sL + \\frac{1}{sC} = \\frac{RsC + s^2LC + 1}{sC}R+sL+sC1​=sCRsC+s2LC+1​Factor if possible: =LC(s2+RLs+1LC)sC= \\frac{LC(s^2 + \\frac{R}{L}s + \\frac{1}{LC})}{sC}=sCLC(s2+LR​s+LC1​)​","strategy-3-parallel-simplification#Strategy 3: Parallel Simplification":"For parallel R and C: Zparallel=R⋅1sCR+1sC=RsCRsC+1sC=RRsC+1Z_{parallel} = \\frac{R \\cdot \\frac{1}{sC}}{R + \\frac{1}{sC}} = \\frac{\\frac{R}{sC}}{\\frac{RsC + 1}{sC}} = \\frac{R}{RsC + 1}Zparallel​=R+sC1​R⋅sC1​​=sCRsC+1​sCR​​=RsC+1R​","summary#Summary":"PATH A transformation process:\n✓ Identify all components ✓ Transform each component using impedance rules ✓ Draw s-domain circuit (no initial conditions yet) ✓ Combine impedances if helpful → Ready for KVL/KCL analysis Key Advantage: You now work entirely with algebra - no differential equations needed!","time-domain-circuit#Time Domain Circuit":"v_s(t) = 10u(t) V ----[R = 100Ω]----[C = 10µF]---- ground","time-domain-circuit-1#Time Domain Circuit":"i_s(t) = 2e^(-3t)u(t) A | +----+----+ | | R=4Ω L=2H | | ground ground","time-domain-circuit-2#Time Domain Circuit":"v_s(t) = 10cos(5t)u(t) V ----[R=2Ω]----[L=0.4H]----[C=0.05F]---- ground","transformation#Transformation":"Component transformations:\nSource: v_s(t) = 10u(t) → V_s(s) = 10/s V Resistor: R = 100Ω → R = 100Ω (unchanged) Capacitor: C = 10µF → Z_C = 1/(sC) = 1/(s·10\\times10-⁶) = 10⁵/s Ω","transformation-1#Transformation":"Component transformations:\nSource: i_s(t) = 2e^(-3t)u(t) → I_s(s) = 2/(s+3) A Resistor: R = 4Ω (unchanged) Inductor: L = 2H → Z_L = sL = 2s Ω","transformation-2#Transformation":"Component transformations:\nSource: v_s(t) = 10cos(5t)u(t) → V_s(s) = 10s/(s²+25) V Resistor: R = 2Ω (unchanged) Inductor: L = 0.4H → Z_L = 0.4s Ω Capacitor: C = 0.05F → Z_C = 1/(0.05s) = 20/s Ω","transformation-checklist#Transformation Checklist":"Before proceeding to circuit laws:\nAll resistors identified (unchanged in s-domain) All capacitors converted to 1/(sC) All inductors converted to sL All voltage sources transformed using Laplace table All current sources transformed using Laplace table Circuit topology preserved (same connections) All nodes labeled Current directions marked Initial conditions NOT yet added (comes later)","voltage-divider#Voltage Divider":"graph TD A[V_in_s] --\u003e B[Z1] B --\u003e C[Node] C --\u003e D[Z2] D --\u003e E[Ground] C --\u003e F[V_out_s] style A fill:#ffebee style F fill:#e8f5e9 Formula: Vout(s)=Vin(s)⋅Z2Z1+Z2V_{out}(s) = V_{in}(s) \\cdot \\frac{Z_2}{Z_1 + Z_2}Vout​(s)=Vin​(s)⋅Z1​+Z2​Z2​​","what-you-have-now#What You Have Now":"After completing this step, you should have:\nA complete s-domain circuit diagram with all impedances No initial condition sources yet (added in Step 3) Ready to apply KVL or KCL (covered in next file)","when-to-use-path-a#When to Use PATH A":"Use this path when:\nProblem says “convert to s-domain” Complex circuits with multiple components You’re comfortable with impedance concepts Time pressure (faster than PATH B) You want to work directly with frequency-domain concepts Advantages:\nFaster for complex circuits Direct impedance manipulation No need to explicitly write differential equations Purely algebraic after transformation More intuitive for frequency-domain thinking"},"title":"4_time_to_s-domain"},"/electrical_notes/ee_300/5_kvl_kcl_s-domain/":{"data":{"algebraic-tips#Algebraic Tips":"","apply-kcl-at-top-node#Apply KCL at Top Node":"Currents leaving node: Is(s)=IR(s)+IL(s)I_s(s) = I_R(s) + I_L(s)Is​(s)=IR​(s)+IL​(s)Express in terms of V(s):\nIR(s)=V(s)R=V(s)4I_R(s) = \\frac{V(s)}{R} = \\frac{V(s)}{4}IR​(s)=RV(s)​=4V(s)​ IL(s)=V(s)ZL=V(s)2sI_L(s) = \\frac{V(s)}{Z_L} = \\frac{V(s)}{2s}IL​(s)=ZL​V(s)​=2sV(s)​ KCL equation: 2s+3=V(s)4+V(s)2s\\frac{2}{s+3} = \\frac{V(s)}{4} + \\frac{V(s)}{2s}s+32​=4V(s)​+2sV(s)​Factor out V(s): 2s+3=V(s)[14+12s]\\frac{2}{s+3} = V(s)\\left[\\frac{1}{4} + \\frac{1}{2s}\\right]s+32​=V(s)[41​+2s1​]Common denominator: 2s+3=V(s)[s+24s]\\frac{2}{s+3} = V(s)\\left[\\frac{s + 2}{4s}\\right]s+32​=V(s)[4ss+2​]Solve for V(s): V(s)=2s+3⋅4ss+2=8s(s+3)(s+2)V(s) = \\frac{2}{s+3} \\cdot \\frac{4s}{s+2} = \\frac{8s}{(s+3)(s+2)}V(s)=s+32​⋅s+24s​=(s+3)(s+2)8s​","apply-kcl-at-top-node-1#Apply KCL at Top Node":"Is(s)=IR(s)+IL(s)+IC(s)I_s(s) = I_R(s) + I_L(s) + I_C(s)Is​(s)=IR​(s)+IL​(s)+IC​(s)Express in terms of V(s):\nIR(s)=V(s)5I_R(s) = \\frac{V(s)}{5}IR​(s)=5V(s)​ IL(s)=V(s)2sI_L(s) = \\frac{V(s)}{2s}IL​(s)=2sV(s)​ IC(s)=V(s)⋅s10I_C(s) = V(s) \\cdot \\frac{s}{10}IC​(s)=V(s)⋅10s​ (since Z_C = 10/s, so 1/Z_C = s/10) KCL equation: 4s=V(s)5+V(s)2s+sV(s)10\\frac{4}{s} = \\frac{V(s)}{5} + \\frac{V(s)}{2s} + \\frac{sV(s)}{10}s4​=5V(s)​+2sV(s)​+10sV(s)​Factor out V(s): 4s=V(s)[15+12s+s10]\\frac{4}{s} = V(s)\\left[\\frac{1}{5} + \\frac{1}{2s} + \\frac{s}{10}\\right]s4​=V(s)[51​+2s1​+10s​]Common denominator (10s): 4s=V(s)[2s+5+s210s]\\frac{4}{s} = V(s)\\left[\\frac{2s + 5 + s^2}{10s}\\right]s4​=V(s)[10s2s+5+s2​]4s=V(s)[s2+2s+510s]\\frac{4}{s} = V(s)\\left[\\frac{s^2 + 2s + 5}{10s}\\right]s4​=V(s)[10ss2+2s+5​]Solve for V(s): V(s)=4s⋅10ss2+2s+5=40s2+2s+5V(s) = \\frac{4}{s} \\cdot \\frac{10s}{s^2 + 2s + 5} = \\frac{40}{s^2 + 2s + 5}V(s)=s4​⋅s2+2s+510s​=s2+2s+540​","apply-kvl#Apply KVL":"Vs(s)=I(s)⋅R+I(s)⋅ZLV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_LVs​(s)=I(s)⋅R+I(s)⋅ZL​5s+2=I(s)[10+0.5s]\\frac{5}{s+2} = I(s)[10 + 0.5s]s+25​=I(s)[10+0.5s]Solve for I(s): I(s)=5(s+2)(10+0.5s)I(s) = \\frac{5}{(s+2)(10 + 0.5s)}I(s)=(s+2)(10+0.5s)5​I(s)=50.5(s+2)(20+s)=10(s+2)(s+20)I(s) = \\frac{5}{0.5(s+2)(20+s)} = \\frac{10}{(s+2)(s+20)}I(s)=0.5(s+2)(20+s)5​=(s+2)(s+20)10​","apply-kvl-clockwise#Apply KVL (clockwise)":"Going around loop: Vs(s)−I(s)⋅R−I(s)⋅ZC=0V_s(s) - I(s) \\cdot R - I(s) \\cdot Z_C = 0Vs​(s)−I(s)⋅R−I(s)⋅ZC​=0Vs(s)=I(s)⋅R+I(s)⋅ZCV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_CVs​(s)=I(s)⋅R+I(s)⋅ZC​10s=I(s)[100+105s]\\frac{10}{s} = I(s)[100 + \\frac{10^5}{s}]s10​=I(s)[100+s105​]Common denominator: 10s=I(s)[100s+105s]\\frac{10}{s} = I(s)\\left[\\frac{100s + 10^5}{s}\\right]s10​=I(s)[s100s+105​]Solve for I(s): I(s)=10s⋅s100s+105=10100s+105I(s) = \\frac{10}{s} \\cdot \\frac{s}{100s + 10^5} = \\frac{10}{100s + 10^5}I(s)=s10​⋅100s+105s​=100s+10510​Simplify: I(s)=10100(s+1000)=0.1s+1000I(s) = \\frac{10}{100(s + 1000)} = \\frac{0.1}{s + 1000}I(s)=100(s+1000)10​=s+10000.1​","approach-1-simplify-first#Approach 1: Simplify First":"Combine series/parallel impedances before applying KVL/KCL.\nExample: If R₂ and C are in parallel within a series circuit:\nFind Z_parallel = (R₂ \\times Z_C)/(R₂ + Z_C) Now circuit is series: R₁ with Z_parallel Apply KVL","approach-2-multiple-equations#Approach 2: Multiple Equations":"Write separate KVL/KCL for each loop/node, then solve system.","approach-3-node-voltage-method#Approach 3: Node-Voltage Method":"Choose one analysis method and stick with it throughout.","basic-principle#Basic Principle":"KVL: The sum of voltages around any closed loop equals zero.\n∑Vrises(s)−∑Vdrops(s)=0\\sum V_{rises}(s) - \\sum V_{drops}(s) = 0∑Vrises​(s)−∑Vdrops​(s)=0Or equivalently: ∑Vsources(s)=∑Vdrops(s)\\sum V_{sources}(s) = \\sum V_{drops}(s)∑Vsources​(s)=∑Vdrops​(s)","basic-principle-1#Basic Principle":"KCL: The sum of currents entering a node equals the sum leaving.\n∑Iin(s)=∑Iout(s)\\sum I_{in}(s) = \\sum I_{out}(s)∑Iin​(s)=∑Iout​(s)Or: ∑Isources(s)=∑Ibranches(s)\\sum I_{sources}(s) = \\sum I_{branches}(s)∑Isources​(s)=∑Ibranches​(s)","common-mistakes-to-avoid#Common Mistakes to Avoid":"","current-through-impedances#Current Through Impedances":"Using Ohm’s Law: I(s)=V(s)Z(s)I(s) = \\frac{V(s)}{Z(s)}I(s)=Z(s)V(s)​Where V(s) is the voltage across the impedance.","find-voltage-across-capacitor#Find Voltage Across Capacitor":"VC(s)=I(s)⋅ZC=0.1s+1000⋅105sV_C(s) = I(s) \\cdot Z_C = \\frac{0.1}{s+1000} \\cdot \\frac{10^5}{s}VC​(s)=I(s)⋅ZC​=s+10000.1​⋅s105​VC(s)=104s(s+1000)V_C(s) = \\frac{10^4}{s(s+1000)}VC​(s)=s(s+1000)104​","for-parallel-circuits-kcl#For Parallel Circuits (KCL)":"Total admittance: Ytotal=Y1+Y2+⋯+Yn=1Z1+1Z2+⋯Y_{total} = Y_1 + Y_2 + \\cdots + Y_n = \\frac{1}{Z_1} + \\frac{1}{Z_2} + \\cdotsYtotal​=Y1​+Y2​+⋯+Yn​=Z1​1​+Z2​1​+⋯Total impedance: Ztotal=1YtotalZ_{total} = \\frac{1}{Y_{total}}Ztotal​=Ytotal​1​Voltage: V(s)=Is(s)⋅ZtotalV(s) = I_s(s) \\cdot Z_{total}V(s)=Is​(s)⋅Ztotal​Current through element i: Ii(s)=V(s)Zi(s)I_i(s) = \\frac{V(s)}{Z_i(s)}Ii​(s)=Zi​(s)V(s)​","for-series-circuits-kvl#For Series Circuits (KVL)":"Total impedance: Ztotal=Z1+Z2+⋯+ZnZ_{total} = Z_1 + Z_2 + \\cdots + Z_nZtotal​=Z1​+Z2​+⋯+Zn​Current: I(s)=Vs(s)ZtotalI(s) = \\frac{V_s(s)}{Z_{total}}I(s)=Ztotal​Vs​(s)​Voltage across element i: Vi(s)=I(s)⋅Zi(s)V_i(s) = I(s) \\cdot Z_i(s)Vi​(s)=I(s)⋅Zi​(s)","kcl-example-1-parallel-rl-circuit#KCL Example 1: Parallel RL Circuit":"","kcl-example-2-parallel-rlc-circuit#KCL Example 2: Parallel RLC Circuit":"","kcl-step-by-step-process#KCL Step-by-Step Process":"","key-equations-summary#Key Equations Summary":"","kirchhoffs-current-law-kcl-in-s-domain#Kirchhoff\u0026rsquo;s Current Law (KCL) in s-Domain":"","kirchhoffs-voltage-law-kvl-in-s-domain#Kirchhoff\u0026rsquo;s Voltage Law (KVL) in s-Domain":"","kvl-example-1-series-rc-circuit#KVL Example 1: Series RC Circuit":"","kvl-example-2-series-rl-circuit#KVL Example 2: Series RL Circuit":"","kvl-step-by-step-process#KVL Step-by-Step Process":"","mistake-1-forgetting-to-factor#Mistake 1: Forgetting to Factor":"WRONG: Leaving terms like: Vs(s)=I(s)⋅R+I(s)⋅ZLV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_LVs​(s)=I(s)⋅R+I(s)⋅ZL​\nRIGHT: Factor immediately: Vs(s)=I(s)[R+ZL]V_s(s) = I(s)[R + Z_L]Vs​(s)=I(s)[R+ZL​]","mistake-2-sign-errors#Mistake 2: Sign Errors":"Always use consistent sign convention:\nPassive sign convention for impedances Check source polarity carefully","mistake-3-wrong-current-direction#Mistake 3: Wrong Current Direction":"Current through impedance must match the voltage polarity you’re calculating.","mistake-4-mixing-series-and-parallel#Mistake 4: Mixing Series and Parallel":"For series: add impedances directly For parallel: use reciprocal formula or product-over-sum","mistake-5-forgetting-s-in-impedances#Mistake 5: Forgetting s in Impedances":"WRONG: Z=R+L+1/CZ = R + L + 1/CZ=R+L+1/C\nRIGHT: Z=R+sL+1/(sC)Z = R + sL + 1/(sC)Z=R+sL+1/(sC)","mixed-analysis-series-parallel-circuits#Mixed Analysis: Series-Parallel Circuits":"For complex topologies, you may need to combine methods.","next-steps#Next Steps":"Without initial conditions: You now have your complete equation! Skip to 06-path-a-complete-process.md for full examples.\nWith initial conditions: Proceed to 03-initial-conditions.md to learn how to add them to your equation.","overview#Overview":"Once you have your s-domain circuit (from 04-path-a-time-to-sdomain.md), you apply Kirchhoff’s laws exactly as you would in DC circuit analysis - but now you’re working with impedances and complex frequency s.\ngraph TD A[s-Domain Circuitwith Impedances] --\u003e B{What are you solving for?} B --\u003e|Voltage or Series| C[Use KVLMesh/Loop Analysis] B --\u003e|Current or Parallel| D[Use KCLNode Analysis] C --\u003e E[Algebraic Equation in s] D --\u003e E style A fill:#fff3e0 style E fill:#e8f5e9","path-a-applying-kvlkcl-in-s-domain#PATH A: Applying KVL/KCL in s-Domain":"PATH A: Applying KVL/KCL in s-Domain","s-domain-circuit#s-Domain Circuit":"V_s(s) = 10/s ----[R=100Ω]----[Z_C=10⁵/s Ω]---- ground ← I(s) →","s-domain-circuit-1#s-Domain Circuit":"V_s(s) = 5/(s+2) ----[R=10Ω]----[Z_L=0.5s Ω]---- ground ← I(s) →","s-domain-circuit-2#s-Domain Circuit":"I_s(s) = 2/(s+3) | +----V(s)----+ | | R=4Ω Z_L=2s Ω | | ground ground","s-domain-circuit-3#s-Domain Circuit":"I_s(s) = 4/s | +----V(s)----+----+----+ | | | | R=5Ω Z_L Z_C | =2s =10/s ground gnd gnd","step-1-choose-loop-direction#Step 1: Choose Loop Direction":"Pick clockwise or counterclockwise - stick with it.","step-1-identify-node#Step 1: Identify Node":"Choose the node where branches meet.","step-2-define-node-voltage#Step 2: Define Node Voltage":"Let V(s) = voltage at the node (relative to ground).","step-2-mark-current-direction#Step 2: Mark Current Direction":"Draw current I(s) flowing around the loop.","step-3-write-current-terms#Step 3: Write Current Terms":"For each branch connected to node: Ibranch(s)=Vnode(s)Zbranch(s)I_{branch}(s) = \\frac{V_{node}(s)}{Z_{branch}(s)}Ibranch​(s)=Zbranch​(s)Vnode​(s)​","step-3-write-voltage-terms#Step 3: Write Voltage Terms":"For each component, going in loop direction:\nVoltage source: + if going − to +, − if going + to − Impedance: Use passive sign convention Voltage drop = I(s) \\times Z(s) in direction of current","step-4-apply-kcl-equation#Step 4: Apply KCL Equation":"Isource(s)=∑V(s)Zi(s)I_{source}(s) = \\sum \\frac{V(s)}{Z_i(s)}Isource​(s)=∑Zi​(s)V(s)​Factor out V(s): Isource(s)=V(s)∑1Zi(s)I_{source}(s) = V(s) \\sum \\frac{1}{Z_i(s)}Isource​(s)=V(s)∑Zi​(s)1​","step-4-apply-kvl-equation#Step 4: Apply KVL Equation":"Vsource(s)=I(s)⋅Z1(s)+I(s)⋅Z2(s)+⋯V_{source}(s) = I(s) \\cdot Z_1(s) + I(s) \\cdot Z_2(s) + \\cdotsVsource​(s)=I(s)⋅Z1​(s)+I(s)⋅Z2​(s)+⋯Factor out I(s): Vsource(s)=I(s)[Z1(s)+Z2(s)+⋯ ]V_{source}(s) = I(s)[Z_1(s) + Z_2(s) + \\cdots]Vsource​(s)=I(s)[Z1​(s)+Z2​(s)+⋯]","summary#Summary":"KVL/KCL in s-domain:\n✓ Choose appropriate method (KVL for series, KCL for parallel) ✓ Write equation using Ohm’s law with impedances ✓ Factor out unknown (I(s) or V(s)) ✓ Simplify algebraically ✓ Solve for desired variable → Result is algebraic equation in s Key insight: This is ALGEBRA, not differential equations! That’s the power of s-domain analysis.","tip-1-always-factor-out-the-unknown#Tip 1: Always Factor Out the Unknown":"Immediately factor out I(s) or V(s):\nVs(s)=I(s)⋅Z1+I(s)⋅Z2=I(s)[Z1+Z2]V_s(s) = I(s) \\cdot Z_1 + I(s) \\cdot Z_2 = I(s)[Z_1 + Z_2]Vs​(s)=I(s)⋅Z1​+I(s)⋅Z2​=I(s)[Z1​+Z2​]","tip-2-find-common-denominators-early#Tip 2: Find Common Denominators Early":"100+105s=100s+105s100 + \\frac{10^5}{s} = \\frac{100s + 10^5}{s}100+s105​=s100s+105​","tip-3-simplify-before-solving#Tip 3: Simplify Before Solving":"10100s+105=10100(s+1000)=0.1s+1000\\frac{10}{100s + 10^5} = \\frac{10}{100(s + 1000)} = \\frac{0.1}{s + 1000}100s+10510​=100(s+1000)10​=s+10000.1​","tip-4-check-units#Tip 4: Check Units":"All impedances must be in Ohms (Ω).","tip-5-verify-with-limiting-cases#Tip 5: Verify with Limiting Cases":"At s → 0 (DC): capacitors = open, inductors = short At s → ∞ (high freq): capacitors = short, inductors = open","voltage-drop-across-impedances#Voltage Drop Across Impedances":"In s-domain, Ohm’s Law applies: V(s)=I(s)⋅Z(s)V(s) = I(s) \\cdot Z(s)V(s)=I(s)⋅Z(s)Where:\nV(s) = voltage across impedance I(s) = current through impedance Z(s) = impedance value","what-you-have-now#What You Have Now":"After applying KVL or KCL, you have:\nAn algebraic equation in s (not a differential equation!) Expression for V(s) or I(s) in terms of sources and impedances No initial conditions yet (added in next step if needed)","when-to-use-kcl#When to Use KCL":"Use KCL for:\nParallel circuits (elements share same voltage) Node analysis When solving for voltage Circuits with few nodes","when-to-use-kvl#When to Use KVL":"Use KVL for:\nSeries circuits (elements share same current) Mesh/loop analysis When solving for current Circuits with few loops"},"title":"5_kvl_kcl_s-domain"},"/electrical_notes/ee_300/6_whole_process_s-domain/":{"data":{"complete-example-1-series-rc-circuit-zero-initial-conditions#Complete Example 1: Series RC Circuit (Zero Initial Conditions)":"","complete-example-2-series-rl-circuit-non-zero-initial-condition#Complete Example 2: Series RL Circuit (Non-Zero Initial Condition)":"","complete-example-3-parallel-rlc-circuit-non-zero-initial-conditions#Complete Example 3: Parallel RLC Circuit (Non-Zero Initial Conditions)":"","complete-example-4-typical-exam-problem-format#Complete Example 4: Typical Exam Problem Format":"","key-takeaways#Key Takeaways":"PATH A gives you algebraic equations, not differential equations Initial conditions are added as sources after the basic equation is set up The process is systematic and repeatable for any circuit The result is always ready for inverse Laplace transform - that’s a separate step Most exam problems follow this exact format - transform first, then add ICs","next-steps#Next Steps":"For PATH B (differential equation first): See 07-path-b-time-domain-analysis.md For inverse Laplace transform: See your existing inverse transform documentation For converting s-domain back to differential equations: See 10-sdomain-to-differential-equation.md","overview#Overview":"This document presents the complete PATH A process from start to finish with detailed worked examples. PATH A takes you directly from time domain to s-domain, applies circuit laws, and prepares for inverse Laplace transform.\ngraph TD A[Time Domain Circuit] --\u003e B[Step 1: Transform to s-Domain] B --\u003e C[Step 2: Apply KVL/KCL] C --\u003e D[Step 3: Add Initial Conditionswhen given] D --\u003e E[Step 4: Solve for Vs or Is] E --\u003e F[Step 5: Ready for InverseLaplace Transform] style A fill:#ffebee style B fill:#fff3e0 style C fill:#e1f5ff style D fill:#ffe0b2 style E fill:#e8f5e9 style F fill:#c8e6c9","path-a-complete-process-with-examples#PATH A: Complete Process with Examples":"PATH A: Complete Process with Examples","practice-strategy#Practice Strategy":"To master PATH A:\nPractice transforming components (memorize the impedance formulas) Practice applying KVL/KCL in s-domain (factor out unknowns!) Practice adding initial conditions correctly (remember the /s for capacitors!) Practice algebraic simplification (common denominators, factoring) Work through examples without looking at solutions","problem-statement#Problem Statement":"Find the voltage across the capacitor v_C(t) for t \\geq 0.\nGiven:\nv_s(t) = 10u(t) V R = 100Ω C = 10µF Initial condition: v_C(0) = 0 (capacitor uncharged)","problem-statement-1#Problem Statement":"Find the current i(t) for t \\geq 0.\nGiven:\nv_s(t) = 5e^(-2t)u(t) V R = 10Ω L = 0.5H Initial condition (given later): i_L(0) = 2A","problem-statement-2#Problem Statement":"Find the voltage v(t) across all elements for t \\geq 0.\nGiven:\ni_s(t) = 4u(t) A R = 5Ω L = 1H C = 0.1F Initial conditions (given later): v_C(0) = 0V, i_L(0) = 3A","problem-statement-3#Problem Statement":"This example follows the typical exam format where initial conditions are given AFTER you’ve set up the s-domain circuit.\nPart (a): Convert the circuit to s-domain and draw the s-domain equivalent circuit.\nPart (b): Apply KVL and find an expression for I(s).\nPart (c): Now you are told: v_C(0) = 5V, i_L(0) = 0A. Add these to your circuit and find the complete expression for I(s).\nGiven circuit:\nv_s(t) = 20u(t) V ----[R=8Ω]----[L=2H]----[C=0.025F]---- ground","solution-to-part-a-transform-to-s-domain#Solution to Part (a): Transform to s-Domain":"Component transformations:\nv_s(t) = 20u(t) → V_s(s) = 20/s V R = 8Ω (unchanged) L = 2H → Z_L = 2s Ω C = 0.025F → Z_C = 1/(0.025s) = 40/s Ω s-Domain circuit:\nV_s(s) = 20/s V ----[8Ω]----[2s Ω]----[40/s Ω]---- ground","solution-to-part-b-apply-kvl#Solution to Part (b): Apply KVL":"Let I(s) = current flowing clockwise\nKVL equation: Vs(s)=I(s)⋅R+I(s)⋅ZL+I(s)⋅ZCV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_L + I(s) \\cdot Z_CVs​(s)=I(s)⋅R+I(s)⋅ZL​+I(s)⋅ZC​\n20s=I(s)[8+2s+40s]\\frac{20}{s} = I(s)\\left[8 + 2s + \\frac{40}{s}\\right]s20​=I(s)[8+2s+s40​]\nCommon denominator: 20s=I(s)[8s+2s2+40s]\\frac{20}{s} = I(s)\\left[\\frac{8s + 2s^2 + 40}{s}\\right]s20​=I(s)[s8s+2s2+40​]\n20s=I(s)[2s2+8s+40s]\\frac{20}{s} = I(s)\\left[\\frac{2s^2 + 8s + 40}{s}\\right]s20​=I(s)[s2s2+8s+40​]\nSolve for I(s): I(s)=20s⋅s2s2+8s+40I(s) = \\frac{20}{s} \\cdot \\frac{s}{2s^2 + 8s + 40}I(s)=s20​⋅2s2+8s+40s​\nI(s)=202s2+8s+40=202(s2+4s+20)I(s) = \\frac{20}{2s^2 + 8s + 40} = \\frac{20}{2(s^2 + 4s + 20)}I(s)=2s2+8s+4020​=2(s2+4s+20)20​\nI(s)=10s2+4s+20I(s) = \\frac{10}{s^2 + 4s + 20}I(s)=s2+4s+2010​\nPart (b) answer: I(s)=10s2+4s+20I(s) = \\frac{10}{s^2 + 4s + 20}I(s)=s2+4s+2010​","solution-to-part-c-add-initial-conditions#Solution to Part (c): Add Initial Conditions":"Now given: v_C(0) = 5V, i_L(0) = 0A\nFor capacitor: Add voltage source v_C(0)/s = 5/s V in series with Z_C\nFor inductor: Li_L(0) = 2(0) = 0V, so no source needed\nUpdated s-Domain circuit:\nV_s(s) = 20/s V ----[8Ω]----[2s Ω]----[40/s Ω]----[+5/s V]---- ground Updated KVL equation: Vs(s)=I(s)⋅R+I(s)⋅ZL+I(s)⋅ZC+vC(0)sV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_L + I(s) \\cdot Z_C + \\frac{v_C(0)}{s}Vs​(s)=I(s)⋅R+I(s)⋅ZL​+I(s)⋅ZC​+svC​(0)​\n20s=I(s)[8+2s+40s]+5s\\frac{20}{s} = I(s)\\left[8 + 2s + \\frac{40}{s}\\right] + \\frac{5}{s}s20​=I(s)[8+2s+s40​]+s5​\n20s−5s=I(s)[2s2+8s+40s]\\frac{20}{s} - \\frac{5}{s} = I(s)\\left[\\frac{2s^2 + 8s + 40}{s}\\right]s20​−s5​=I(s)[s2s2+8s+40​]\n15s=I(s)[2s2+8s+40s]\\frac{15}{s} = I(s)\\left[\\frac{2s^2 + 8s + 40}{s}\\right]s15​=I(s)[s2s2+8s+40​]\nSolve for I(s): I(s)=15s⋅s2s2+8s+40I(s) = \\frac{15}{s} \\cdot \\frac{s}{2s^2 + 8s + 40}I(s)=s15​⋅2s2+8s+40s​\nI(s)=152(s2+4s+20)=7.5s2+4s+20I(s) = \\frac{15}{2(s^2 + 4s + 20)} = \\frac{7.5}{s^2 + 4s + 20}I(s)=2(s2+4s+20)15​=s2+4s+207.5​\nPart (c) answer: I(s)=7.5s2+4s+20I(s) = \\frac{7.5}{s^2 + 4s + 20}I(s)=s2+4s+207.5​\nNote: The initial condition changed the numerator from 10 to 7.5.","step-1-transform-to-s-domain#STEP 1: Transform to s-Domain":"Component transformations:\nVoltage source: v_s(t) = 10u(t) → V_s(s) = 10/s V Resistor: R = 100Ω → R = 100Ω (unchanged) Capacitor: C = 10µF = 10\\times10-⁶ F → Z_C = 1/(sC) = 1/(s·10\\times10-⁶) = 10⁶/(10s) = 10⁵/s Ω s-Domain circuit (no initial conditions yet):\nV_s(s) = 10/s V ----[100Ω]----[10⁵/s Ω]---- ground","step-1-transform-to-s-domain-1#STEP 1: Transform to s-Domain":"Component transformations:\nVoltage source: v_s(t) = 5e^(-2t)u(t) → V_s(s) = 5/(s+2) V Resistor: R = 10Ω → R = 10Ω (unchanged) Inductor: L = 0.5H → Z_L = sL = 0.5s Ω s-Domain circuit (no initial conditions yet):\nV_s(s) = 5/(s+2) V ----[10Ω]----[0.5s Ω]---- ground","step-1-transform-to-s-domain-2#STEP 1: Transform to s-Domain":"Component transformations:\nCurrent source: i_s(t) = 4u(t) → I_s(s) = 4/s A Resistor: R = 5Ω (unchanged) Inductor: L = 1H → Z_L = s Ω Capacitor: C = 0.1F → Z_C = 1/(0.1s) = 10/s Ω s-Domain circuit (no initial conditions yet):\nI_s(s) = 4/s A | +----+----+----+ | | | | 5Ω s Ω 10/s Ω | | | | gnd gnd gnd gnd","step-2-apply-kcl-at-top-node#STEP 2: Apply KCL at Top Node":"Let V(s) = voltage at the node\nKCL equation: Is(s)=IR(s)+IL(s)+IC(s)I_s(s) = I_R(s) + I_L(s) + I_C(s)Is​(s)=IR​(s)+IL​(s)+IC​(s)\nExpress currents in terms of V(s):\nIR(s)=V(s)R=V(s)5I_R(s) = \\frac{V(s)}{R} = \\frac{V(s)}{5}IR​(s)=RV(s)​=5V(s)​ IL(s)=V(s)ZL=V(s)sI_L(s) = \\frac{V(s)}{Z_L} = \\frac{V(s)}{s}IL​(s)=ZL​V(s)​=sV(s)​ IC(s)=V(s)ZC=V(s)10/s=sV(s)10I_C(s) = \\frac{V(s)}{Z_C} = \\frac{V(s)}{10/s} = \\frac{sV(s)}{10}IC​(s)=ZC​V(s)​=10/sV(s)​=10sV(s)​ Substitute: 4s=V(s)5+V(s)s+sV(s)10\\frac{4}{s} = \\frac{V(s)}{5} + \\frac{V(s)}{s} + \\frac{sV(s)}{10}s4​=5V(s)​+sV(s)​+10sV(s)​\nFactor out V(s): 4s=V(s)[15+1s+s10]\\frac{4}{s} = V(s)\\left[\\frac{1}{5} + \\frac{1}{s} + \\frac{s}{10}\\right]s4​=V(s)[51​+s1​+10s​]\nCommon denominator (10s): 4s=V(s)[2s+10+s210s]\\frac{4}{s} = V(s)\\left[\\frac{2s + 10 + s^2}{10s}\\right]s4​=V(s)[10s2s+10+s2​]\n4s=V(s)[s2+2s+1010s]\\frac{4}{s} = V(s)\\left[\\frac{s^2 + 2s + 10}{10s}\\right]s4​=V(s)[10ss2+2s+10​]\nSolve for V(s) (without initial conditions): V(s)=4s⋅10ss2+2s+10V(s) = \\frac{4}{s} \\cdot \\frac{10s}{s^2 + 2s + 10}V(s)=s4​⋅s2+2s+1010s​\nV(s)=40s2+2s+10V(s) = \\frac{40}{s^2 + 2s + 10}V(s)=s2+2s+1040​","step-2-apply-kvl-in-s-domain#STEP 2: Apply KVL in s-Domain":"Let I(s) = current flowing clockwise\nKVL equation: Vs(s)=I(s)⋅R+I(s)⋅ZCV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_CVs​(s)=I(s)⋅R+I(s)⋅ZC​10s=I(s)[100+105s]\\frac{10}{s} = I(s)\\left[100 + \\frac{10^5}{s}\\right]s10​=I(s)[100+s105​]Common denominator: 10s=I(s)[100s+105s]\\frac{10}{s} = I(s)\\left[\\frac{100s + 10^5}{s}\\right]s10​=I(s)[s100s+105​]Solve for I(s): I(s)=10s⋅s100s+105=10100s+105I(s) = \\frac{10}{s} \\cdot \\frac{s}{100s + 10^5} = \\frac{10}{100s + 10^5}I(s)=s10​⋅100s+105s​=100s+10510​Simplify: I(s)=10100(s+1000)=0.1s+1000I(s) = \\frac{10}{100(s + 1000)} = \\frac{0.1}{s + 1000}I(s)=100(s+1000)10​=s+10000.1​Find V_C(s): VC(s)=I(s)⋅ZC=0.1s+1000⋅105sV_C(s) = I(s) \\cdot Z_C = \\frac{0.1}{s+1000} \\cdot \\frac{10^5}{s}VC​(s)=I(s)⋅ZC​=s+10000.1​⋅s105​VC(s)=104s(s+1000)V_C(s) = \\frac{10^4}{s(s+1000)}VC​(s)=s(s+1000)104​","step-2-apply-kvl-in-s-domain-1#STEP 2: Apply KVL in s-Domain":"Let I(s) = current flowing clockwise\nKVL equation: Vs(s)=I(s)⋅R+I(s)⋅ZLV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_LVs​(s)=I(s)⋅R+I(s)⋅ZL​\n5s+2=I(s)[10+0.5s]\\frac{5}{s+2} = I(s)[10 + 0.5s]s+25​=I(s)[10+0.5s]\nSolve for I(s) (without initial condition): I(s)=5(s+2)(10+0.5s)I(s) = \\frac{5}{(s+2)(10 + 0.5s)}I(s)=(s+2)(10+0.5s)5​\nFactor denominator: I(s)=50.5(s+2)(20+s)=10(s+2)(s+20)I(s) = \\frac{5}{0.5(s+2)(20+s)} = \\frac{10}{(s+2)(s+20)}I(s)=0.5(s+2)(20+s)5​=(s+2)(s+20)10​","step-3-add-initial-conditions#STEP 3: Add Initial Conditions":"Given: v_C(0) = 0\nSince the initial condition is zero, no additional source is needed. The equation is complete.","step-3-add-initial-conditions-1#STEP 3: Add Initial Conditions":"Now given: i_L(0) = 2A\nFor series circuit with inductor, add voltage source Li_L(0) in series with Z_L.\nInitial condition voltage source: Vinitial=LiL(0)=0.5×2=1VV_{initial} = Li_L(0) = 0.5 \\times 2 = 1VVinitial​=LiL​(0)=0.5×2=1V\nUpdated s-Domain circuit:\nV_s(s) = 5/(s+2) V ----[10Ω]----[0.5s Ω]----[+1V]---- ground (opposes current) Updated KVL equation: Vs(s)=I(s)⋅R+I(s)⋅ZL+VinitialV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_L + V_{initial}Vs​(s)=I(s)⋅R+I(s)⋅ZL​+Vinitial​\n5s+2=I(s)[10+0.5s]+1\\frac{5}{s+2} = I(s)[10 + 0.5s] + 1s+25​=I(s)[10+0.5s]+1\nRearrange: 5s+2−1=I(s)[10+0.5s]\\frac{5}{s+2} - 1 = I(s)[10 + 0.5s]s+25​−1=I(s)[10+0.5s]\n5−(s+2)s+2=I(s)[10+0.5s]\\frac{5 - (s+2)}{s+2} = I(s)[10 + 0.5s]s+25−(s+2)​=I(s)[10+0.5s]\n3−ss+2=I(s)[10+0.5s]\\frac{3-s}{s+2} = I(s)[10 + 0.5s]s+23−s​=I(s)[10+0.5s]","step-3-add-initial-conditions-2#STEP 3: Add Initial Conditions":"Now given: v_C(0) = 0V, i_L(0) = 3A\nFor capacitor: Since v_C(0) = 0, no voltage source needed.\nFor inductor (parallel form for KCL): Add current source i_L(0)/s = 3/s A in parallel with Z_L\nUpdated s-Domain circuit:\nI_s(s) = 4/s A | +----+----+----+ | | | | 5Ω [s Ω] 10/s Ω | [3/s A↓] | gnd gnd gnd gnd The inductor initial condition current source supplies current to the node.\nUpdated KCL equation: Is(s)+IL,initial(s)=IR(s)+IL(s)+IC(s)I_s(s) + I_{L,initial}(s) = I_R(s) + I_L(s) + I_C(s)Is​(s)+IL,initial​(s)=IR​(s)+IL​(s)+IC​(s)\n4s+3s=V(s)5+V(s)s+sV(s)10\\frac{4}{s} + \\frac{3}{s} = \\frac{V(s)}{5} + \\frac{V(s)}{s} + \\frac{sV(s)}{10}s4​+s3​=5V(s)​+sV(s)​+10sV(s)​\n7s=V(s)[s2+2s+1010s]\\frac{7}{s} = V(s)\\left[\\frac{s^2 + 2s + 10}{10s}\\right]s7​=V(s)[10ss2+2s+10​]","step-4-solve-for-is---complete#STEP 4: Solve for I(s) - Complete":"I(s)=3−s(s+2)(10+0.5s)I(s) = \\frac{3-s}{(s+2)(10+0.5s)}I(s)=(s+2)(10+0.5s)3−s​\nI(s)=3−s0.5(s+2)(s+20)=2(3−s)(s+2)(s+20)I(s) = \\frac{3-s}{0.5(s+2)(s+20)} = \\frac{2(3-s)}{(s+2)(s+20)}I(s)=0.5(s+2)(s+20)3−s​=(s+2)(s+20)2(3−s)​\nI(s)=6−2s(s+2)(s+20)I(s) = \\frac{6-2s}{(s+2)(s+20)}I(s)=(s+2)(s+20)6−2s​","step-4-solve-for-v_cs---complete#STEP 4: Solve for V_C(s) - Complete":"VC(s)=104s(s+1000)=10000s(s+1000)V_C(s) = \\frac{10^4}{s(s+1000)} = \\frac{10000}{s(s+1000)}VC​(s)=s(s+1000)104​=s(s+1000)10000​","step-4-solve-for-vs---complete#STEP 4: Solve for V(s) - Complete":"V(s)=7s⋅10ss2+2s+10V(s) = \\frac{7}{s} \\cdot \\frac{10s}{s^2 + 2s + 10}V(s)=s7​⋅s2+2s+1010s​\nV(s)=70s2+2s+10V(s) = \\frac{70}{s^2 + 2s + 10}V(s)=s2+2s+1070​","step-5-ready-for-inverse-laplace-transform#STEP 5: Ready for Inverse Laplace Transform":"Final result: VC(s)=10000s(s+1000)V_C(s) = \\frac{10000}{s(s+1000)}VC​(s)=s(s+1000)10000​This would be solved using partial fraction expansion: VC(s)=As+Bs+1000V_C(s) = \\frac{A}{s} + \\frac{B}{s+1000}VC​(s)=sA​+s+1000B​And then inverse transformed to find v_C(t).","step-5-ready-for-inverse-laplace-transform-1#STEP 5: Ready for Inverse Laplace Transform":"Final result: I(s)=6−2s(s+2)(s+20)I(s) = \\frac{6-2s}{(s+2)(s+20)}I(s)=(s+2)(s+20)6−2s​\nThis would be solved using partial fractions, then inverse transformed to find i(t).","step-5-ready-for-inverse-laplace-transform-2#STEP 5: Ready for Inverse Laplace Transform":"Final result: V(s)=70s2+2s+10V(s) = \\frac{70}{s^2 + 2s + 10}V(s)=s2+2s+1070​\nComplete the square in denominator: s² + 2s + 10 = (s+1)² + 9\nV(s)=70(s+1)2+9V(s) = \\frac{70}{(s+1)^2 + 9}V(s)=(s+1)2+970​\nThis has the form of a damped sinusoid and can be inverse transformed to find v(t).","summary-of-path-a-process#Summary of PATH A Process":"graph TD A[Start: Time Domain Circuit] --\u003e B[STEP 1: TransformR→R, C→1/sC, L→sLSources→Laplace] B --\u003e C[STEP 2: Apply KVL or KCLGet algebraic equation] C --\u003e D{Initial conditionsgiven?} D --\u003e|No| E[STEP 4: Equation completeSolve for Vs or Is] D --\u003e|Yes| F[STEP 3: Add IC sourcesUpdate equation] F --\u003e E E --\u003e G[STEP 5: Ready forInverse Laplace Transform] style A fill:#ffebee style B fill:#fff3e0 style C fill:#e1f5ff style F fill:#ffe0b2 style E fill:#e8f5e9 style G fill:#c8e6c9","time-domain-circuit#Time Domain Circuit":"v_s(t) = 10u(t) V ----[R=100Ω]----[C=10µF]---- ground","time-domain-circuit-1#Time Domain Circuit":"v_s(t) = 5e^(-2t)u(t) V ----[R=10Ω]----[L=0.5H]---- ground","time-domain-circuit-2#Time Domain Circuit":"i_s(t) = 4u(t) A | +----+----+----+ | | | | R=5Ω L=1H C=0.1F | | | | gnd gnd gnd gnd"},"title":"6_whole_process_s-domain"},"/electrical_notes/ee_300/7_time_domain_analysis/":{"data":{"alternative-differential-equation-for-current#Alternative: Differential Equation for Current":"If solving for current i(t):\nFrom KVL: vs(t)=Ri(t)+vC(t)v_s(t) = Ri(t) + v_C(t)vs​(t)=Ri(t)+vC​(t)\nCapacitor: vC(t)=1C∫i(τ)dτ+vC(0)v_C(t) = \\frac{1}{C}\\int i(\\tau)d\\tau + v_C(0)vC​(t)=C1​∫i(τ)dτ+vC​(0)\nSubstitute: vs(t)=Ri(t)+1C∫i(τ)dτ+vC(0)v_s(t) = Ri(t) + \\frac{1}{C}\\int i(\\tau)d\\tau + v_C(0)vs​(t)=Ri(t)+C1​∫i(τ)dτ+vC​(0)Differentiate to eliminate integral: dvs(t)dt=Rdi(t)dt+i(t)C\\frac{dv_s(t)}{dt} = R\\frac{di(t)}{dt} + \\frac{i(t)}{C}dtdvs​(t)​=Rdtdi(t)​+Ci(t)​Rdi(t)dt+i(t)C=dvs(t)dtR\\frac{di(t)}{dt} + \\frac{i(t)}{C} = \\frac{dv_s(t)}{dt}Rdtdi(t)​+Ci(t)​=dtdvs​(t)​For step input v_s(t) = 10u(t), the derivative is the impulse: dvs(t)dt=10δ(t)\\frac{dv_s(t)}{dt} = 10\\delta(t)dtdvs​(t)​=10δ(t)","capacitor#Capacitor":"Current as derivative of voltage: iC(t)=CdvC(t)dti_C(t) = C \\frac{dv_C(t)}{dt}iC​(t)=CdtdvC​(t)​Voltage as integral of current: vC(t)=1C∫0tiC(τ)dτ+vC(0)v_C(t) = \\frac{1}{C}\\int_{0}^{t} i_C(\\tau)d\\tau + v_C(0)vC​(t)=C1​∫0t​iC​(τ)dτ+vC​(0)","circuit#Circuit":"v_s(t) = 10u(t) V ----[R=100Ω]----[C=10µF]---- ground Find: Differential equation for v_C(t)","circuit-1#Circuit":"v_s(t) = 5e^(-2t)u(t) V ----[R=10Ω]----[L=0.5H]---- ground Find: Differential equation for i(t)","circuit-2#Circuit":"v_s(t) = 10cos(5t)u(t) V ----[R=2Ω]----[L=0.4H]----[C=0.05F]---- ground Find: Differential equation for i(t)","circuit-3#Circuit":"i_s(t) = 2u(t) A | +----+----+ | | R=4Ω C=0.25F | | ground ground Find: Differential equation for v(t)","common-mistakes#Common Mistakes":"","component-equations-in-time-domain#Component Equations in Time Domain":"","example-1-series-rc-circuit-first-order#Example 1: Series RC Circuit (First-Order)":"","example-2-series-rl-circuit-first-order#Example 2: Series RL Circuit (First-Order)":"","example-3-series-rlc-circuit-second-order#Example 3: Series RLC Circuit (Second-Order)":"","example-4-parallel-rc-circuit#Example 4: Parallel RC Circuit":"","first-order-standard-form#First-Order Standard Form":"τdy(t)dt+y(t)=K⋅u(t)\\tau\\frac{dy(t)}{dt} + y(t) = K \\cdot u(t)τdtdy(t)​+y(t)=K⋅u(t)Where:\nτ = time constant K = gain y(t) = output variable u(t) = input (forcing function)","first-order-systems#First-Order Systems":"RC circuit: 1 capacitor RL circuit: 1 inductor Result: First derivative is highest","higher-order-systems#Higher-Order Systems":"Multiple L’s and C’s Order = total number of L’s and C’s (if independent)","identifying-system-order#Identifying System Order":"The order of the differential equation equals the number of independent energy storage elements (L and C).","inductor#Inductor":"Voltage as derivative of current: vL(t)=LdiL(t)dtv_L(t) = L \\frac{di_L(t)}{dt}vL​(t)=LdtdiL​(t)​Current as integral of voltage: iL(t)=1L∫0tvL(τ)dτ+iL(0)i_L(t) = \\frac{1}{L}\\int_{0}^{t} v_L(\\tau)d\\tau + i_L(0)iL​(t)=L1​∫0t​vL​(τ)dτ+iL​(0)","mistake-1-forgetting-to-differentiate#Mistake 1: Forgetting to Differentiate":"If you have an integral and want a differential equation, you MUST differentiate.","mistake-2-wrong-derivative#Mistake 2: Wrong Derivative":"ddt[1C∫i(τ)dτ]=i(t)C\\frac{d}{dt}\\left[\\frac{1}{C}\\int i(\\tau)d\\tau\\right] = \\frac{i(t)}{C}dtd​[C1​∫i(τ)dτ]=Ci(t)​NOT: 1Ci(t)dt\\frac{1}{C}i(t)dtC1​i(t)dt","mistake-3-mixing-variables#Mistake 3: Mixing Variables":"Don’t have both v(t) and i(t) in final equation. Express everything in terms of one variable.","mistake-4-sign-errors#Mistake 4: Sign Errors":"Be consistent with passive sign convention and current directions.","next-steps#Next Steps":"Proceed to: 08-path-b-laplace-transform.md to learn how to transform your differential equation to s-domain.","overview#Overview":"PATH B is the differential equation first approach where you apply circuit laws in the time domain, derive a differential equation, then transform it to s-domain using Laplace transform.\ngraph TD A[Time Domain Circuit] --\u003e B[Apply KVL/KCL in Time Domain] B --\u003e C[Substitute Component Equations] C --\u003e D[Manipulate to Single Variable] D --\u003e E[Differential Equation] style A fill:#ffebee style E fill:#ffe0b2","path-b-time-domain-analysis-and-differential-equations#PATH B: Time Domain Analysis and Differential Equations":"PATH B: Time Domain Analysis and Differential Equations","resistor#Resistor":"Voltage-current relationship: vR(t)=R⋅iR(t)v_R(t) = R \\cdot i_R(t)vR​(t)=R⋅iR​(t)iR(t)=vR(t)Ri_R(t) = \\frac{v_R(t)}{R}iR​(t)=RvR​(t)​","second-order-standard-form#Second-Order Standard Form":"d2y(t)dt2+2ζωndy(t)dt+ωn2y(t)=K⋅u(t)\\frac{d^2y(t)}{dt^2} + 2\\zeta\\omega_n\\frac{dy(t)}{dt} + \\omega_n^2y(t) = K \\cdot u(t)dt2d2y(t)​+2ζωn​dtdy(t)​+ωn2​y(t)=K⋅u(t)Where:\nω_n = natural frequency ζ = damping ratio K = gain","second-order-systems#Second-Order Systems":"LC circuit: 1 capacitor + 1 inductor RLC circuit: 1 capacitor + 1 inductor Result: Second derivative is highest","standard-forms#Standard Forms":"","step-1-apply-kcl-at-top-node#Step 1: Apply KCL at Top Node":"is(t)=iR(t)+iC(t)i_s(t) = i_R(t) + i_C(t)is​(t)=iR​(t)+iC​(t)","step-1-apply-kvl#Step 1: Apply KVL":"vs(t)=vR(t)+vC(t)v_s(t) = v_R(t) + v_C(t)vs​(t)=vR​(t)+vC​(t)","step-1-apply-kvl-1#Step 1: Apply KVL":"vs(t)=vR(t)+vL(t)v_s(t) = v_R(t) + v_L(t)vs​(t)=vR​(t)+vL​(t)","step-1-apply-kvl-2#Step 1: Apply KVL":"vs(t)=vR(t)+vL(t)+vC(t)v_s(t) = v_R(t) + v_L(t) + v_C(t)vs​(t)=vR​(t)+vL​(t)+vC​(t)","step-1-apply-kvl-or-kcl-in-time-domain#Step 1: Apply KVL or KCL in Time Domain":"For series circuits: Use KVL ∑vsources(t)=∑vdrops(t)\\sum v_{sources}(t) = \\sum v_{drops}(t)∑vsources​(t)=∑vdrops​(t)For parallel circuits: Use KCL ∑isources(t)=∑ibranches(t)\\sum i_{sources}(t) = \\sum i_{branches}(t)∑isources​(t)=∑ibranches​(t)","step-2-substitute-component-equations#Step 2: Substitute Component Equations":"Replace each voltage or current with its component relationship.","step-2-substitute-component-equations-1#Step 2: Substitute Component Equations":"For resistor: vR(t)=R⋅i(t)=100i(t)v_R(t) = R \\cdot i(t) = 100i(t)vR​(t)=R⋅i(t)=100i(t)\nFor capacitor: i(t)=CdvC(t)dt=10×10−6dvC(t)dti(t) = C\\frac{dv_C(t)}{dt} = 10 \\times 10^{-6}\\frac{dv_C(t)}{dt}i(t)=CdtdvC​(t)​=10×10−6dtdvC​(t)​\nTherefore: vR(t)=100⋅10×10−6dvC(t)dt=10−3dvC(t)dtv_R(t) = 100 \\cdot 10 \\times 10^{-6}\\frac{dv_C(t)}{dt} = 10^{-3}\\frac{dv_C(t)}{dt}vR​(t)=100⋅10×10−6dtdvC​(t)​=10−3dtdvC​(t)​","step-2-substitute-component-equations-2#Step 2: Substitute Component Equations":"Resistor: vR(t)=Ri(t)=10i(t)v_R(t) = Ri(t) = 10i(t)vR​(t)=Ri(t)=10i(t) Inductor: vL(t)=Ldi(t)dt=0.5di(t)dtv_L(t) = L\\frac{di(t)}{dt} = 0.5\\frac{di(t)}{dt}vL​(t)=Ldtdi(t)​=0.5dtdi(t)​","step-2-substitute-component-equations-3#Step 2: Substitute Component Equations":"Resistor: vR(t)=Ri(t)=2i(t)v_R(t) = Ri(t) = 2i(t)vR​(t)=Ri(t)=2i(t) Inductor: vL(t)=Ldi(t)dt=0.4di(t)dtv_L(t) = L\\frac{di(t)}{dt} = 0.4\\frac{di(t)}{dt}vL​(t)=Ldtdi(t)​=0.4dtdi(t)​ Capacitor: vC(t)=1C∫i(τ)dτ+vC(0)=10.05∫i(τ)dτ+vC(0)=20∫i(τ)dτ+vC(0)v_C(t) = \\frac{1}{C}\\int i(\\tau)d\\tau + v_C(0) = \\frac{1}{0.05}\\int i(\\tau)d\\tau + v_C(0) = 20\\int i(\\tau)d\\tau + v_C(0)vC​(t)=C1​∫i(τ)dτ+vC​(0)=0.051​∫i(τ)dτ+vC​(0)=20∫i(τ)dτ+vC​(0)","step-2-substitute-component-equations-4#Step 2: Substitute Component Equations":"Resistor: iR(t)=v(t)R=v(t)4i_R(t) = \\frac{v(t)}{R} = \\frac{v(t)}{4}iR​(t)=Rv(t)​=4v(t)​ Capacitor: iC(t)=Cdv(t)dt=0.25dv(t)dti_C(t) = C\\frac{dv(t)}{dt} = 0.25\\frac{dv(t)}{dt}iC​(t)=Cdtdv(t)​=0.25dtdv(t)​","step-3-choose-your-variable#Step 3: Choose Your Variable":"Decide what you’re solving for (current or voltage) and manipulate the equation to express everything in terms of that single variable.","step-3-substitute-into-kcl#Step 3: Substitute into KCL":"is(t)=v(t)4+0.25dv(t)dti_s(t) = \\frac{v(t)}{4} + 0.25\\frac{dv(t)}{dt}is​(t)=4v(t)​+0.25dtdv(t)​","step-3-substitute-into-kvl#Step 3: Substitute into KVL":"vs(t)=10−3dvC(t)dt+vC(t)v_s(t) = 10^{-3}\\frac{dv_C(t)}{dt} + v_C(t)vs​(t)=10−3dtdvC​(t)​+vC​(t)","step-3-substitute-into-kvl-1#Step 3: Substitute into KVL":"vs(t)=10i(t)+0.5di(t)dtv_s(t) = 10i(t) + 0.5\\frac{di(t)}{dt}vs​(t)=10i(t)+0.5dtdi(t)​","step-3-substitute-into-kvl-2#Step 3: Substitute into KVL":"vs(t)=2i(t)+0.4di(t)dt+20∫i(τ)dτ+vC(0)v_s(t) = 2i(t) + 0.4\\frac{di(t)}{dt} + 20\\int i(\\tau)d\\tau + v_C(0)vs​(t)=2i(t)+0.4dtdi(t)​+20∫i(τ)dτ+vC​(0)","step-4-differentiate-to-eliminate-integral#Step 4: Differentiate to Eliminate Integral":"dvs(t)dt=2di(t)dt+0.4d2i(t)dt2+20i(t)\\frac{dv_s(t)}{dt} = 2\\frac{di(t)}{dt} + 0.4\\frac{d^2i(t)}{dt^2} + 20i(t)dtdvs​(t)​=2dtdi(t)​+0.4dt2d2i(t)​+20i(t)","step-4-eliminate-integrals-if-present#Step 4: Eliminate Integrals (if present)":"If integrals appear, differentiate the entire equation to eliminate them.","step-4-rearrange-to-standard-form#Step 4: Rearrange to Standard Form":"10−3dvC(t)dt+vC(t)=vs(t)10^{-3}\\frac{dv_C(t)}{dt} + v_C(t) = v_s(t)10−3dtdvC​(t)​+vC​(t)=vs​(t)Divide by 10-³: dvC(t)dt+1000vC(t)=1000vs(t)\\frac{dv_C(t)}{dt} + 1000v_C(t) = 1000v_s(t)dtdvC​(t)​+1000vC​(t)=1000vs​(t)For v_s(t) = 10u(t): dvC(t)dt+1000vC(t)=10000u(t)\\frac{dv_C(t)}{dt} + 1000v_C(t) = 10000u(t)dtdvC​(t)​+1000vC​(t)=10000u(t)This is a first-order differential equation.","step-4-rearrange-to-standard-form-1#Step 4: Rearrange to Standard Form":"0.5di(t)dt+10i(t)=vs(t)0.5\\frac{di(t)}{dt} + 10i(t) = v_s(t)0.5dtdi(t)​+10i(t)=vs​(t)Divide by 0.5: di(t)dt+20i(t)=2vs(t)\\frac{di(t)}{dt} + 20i(t) = 2v_s(t)dtdi(t)​+20i(t)=2vs​(t)For v_s(t) = 5e^(-2t)u(t): di(t)dt+20i(t)=10e−2tu(t)\\frac{di(t)}{dt} + 20i(t) = 10e^{-2t}u(t)dtdi(t)​+20i(t)=10e−2tu(t)This is a first-order differential equation.","step-4-rearrange-to-standard-form-2#Step 4: Rearrange to Standard Form":"0.25dv(t)dt+v(t)4=is(t)0.25\\frac{dv(t)}{dt} + \\frac{v(t)}{4} = i_s(t)0.25dtdv(t)​+4v(t)​=is​(t)Multiply by 4: dv(t)dt+v(t)=4is(t)\\frac{dv(t)}{dt} + v(t) = 4i_s(t)dtdv(t)​+v(t)=4is​(t)For i_s(t) = 2u(t): dv(t)dt+v(t)=8u(t)\\frac{dv(t)}{dt} + v(t) = 8u(t)dtdv(t)​+v(t)=8u(t)This is a first-order differential equation.","step-5-arrange-in-standard-form#Step 5: Arrange in Standard Form":"Put all terms with the unknown on the left, source terms on the right.","step-5-rearrange-to-standard-form#Step 5: Rearrange to Standard Form":"0.4d2i(t)dt2+2di(t)dt+20i(t)=dvs(t)dt0.4\\frac{d^2i(t)}{dt^2} + 2\\frac{di(t)}{dt} + 20i(t) = \\frac{dv_s(t)}{dt}0.4dt2d2i(t)​+2dtdi(t)​+20i(t)=dtdvs​(t)​Divide by 0.4: d2i(t)dt2+5di(t)dt+50i(t)=2.5dvs(t)dt\\frac{d^2i(t)}{dt^2} + 5\\frac{di(t)}{dt} + 50i(t) = 2.5\\frac{dv_s(t)}{dt}dt2d2i(t)​+5dtdi(t)​+50i(t)=2.5dtdvs​(t)​For v_s(t) = 10cos(5t)u(t): dvs(t)dt=−50sin⁡(5t)u(t)+10cos⁡(5t)δ(t)\\frac{dv_s(t)}{dt} = -50\\sin(5t)u(t) + 10\\cos(5t)\\delta(t)dtdvs​(t)​=−50sin(5t)u(t)+10cos(5t)δ(t)This is a second-order differential equation.","step-by-step-process#Step-by-Step Process":"","summary#Summary":"PATH B time-domain process:\n✓ Apply KVL or KCL in time domain ✓ Substitute component equations (v=Ri, v=Ldi/dt, i=Cdv/dt) ✓ Manipulate to single variable ✓ Differentiate to eliminate integrals ✓ Arrange in standard form → Result: Explicit differential equation Key advantage: You see exactly what differential equation governs the circuit behavior!","tip-1-choose-your-variable-wisely#Tip 1: Choose Your Variable Wisely":"Solve for the variable that makes the math simplest:\nSeries circuits: solve for current (same everywhere) Parallel circuits: solve for voltage (same everywhere)","tip-2-eliminate-integrals-early#Tip 2: Eliminate Integrals Early":"If you have integrals, differentiate the entire equation immediately.","tip-3-work-systematically#Tip 3: Work Systematically":"Write circuit law (KVL/KCL) Substitute ALL component equations Collect like terms Differentiate if needed Arrange in standard form","tip-4-check-your-order#Tip 4: Check Your Order":"Count energy storage elements = order of differential equation","tip-5-handle-initial-conditions#Tip 5: Handle Initial Conditions":"Initial conditions (v_C(0), i_L(0)) appear as:\nConstants in integrated form They’ll be incorporated when applying Laplace transform","tips-for-deriving-differential-equations#Tips for Deriving Differential Equations":"","what-you-have-now#What You Have Now":"After completing PATH B time-domain analysis:\nAn explicit differential equation showing system dynamics Clear understanding of system order Physical insight into how the circuit behaves Ready to apply Laplace transform (next step)","when-to-use-path-b#When to Use PATH B":"Use this path when:\nProblem explicitly asks for the differential equation You need to understand the underlying physics Simple circuits (RC or RL) Educational/learning context You want to see the system’s natural behavior Advantages:\nShows the physics clearly Explicitly reveals the differential equation Better for understanding system behavior Natural for simple circuits Makes the order of the system obvious"},"title":"7_time_domain_analysis"},"/electrical_notes/ee_300/8_laplace_transform/":{"data":{"apply-laplace-transform#Apply Laplace Transform":"sV(s)−v(0)+V(s)=8ssV(s) - v(0) + V(s) = \\frac{8}{s}sV(s)−v(0)+V(s)=s8​","common-laplace-transforms-reference#Common Laplace Transforms (Reference)":"Time Domain f(t) Laplace Domain F(s) u(t) 1/s e^(-at)u(t) 1/(s+a) t·u(t) 1/s² t^n·u(t) n!/s^(n+1) sin(ωt)u(t) ω/(s²+ω²) cos(ωt)u(t) s/(s²+ω²) e^(-at)sin(ωt)u(t) ω/[(s+a)²+ω²] e^(-at)cos(ωt)u(t) (s+a)/[(s+a)²+ω²] δ(t) 1","common-mistakes#Common Mistakes":"","comparing-path-a-and-path-b-results#Comparing PATH A and PATH B Results":"graph TD A[Same Circuit] --\u003e B[PATH A:Transform then KVL/KCL] A --\u003e C[PATH B:Diff Eq then Laplace] B --\u003e D[Same s-Domain Equation] C --\u003e D D --\u003e E[Vs or Is ready forinverse transform] style A fill:#ffebee style D fill:#e8f5e9 style E fill:#c8e6c9 Key Point: Both paths give identical results in s-domain!","differential-equation#Differential Equation":"dv(t)dt+v(t)=8u(t)\\frac{dv(t)}{dt} + v(t) = 8u(t)dtdv(t)​+v(t)=8u(t)Initial condition: v(0) = 3V","differentiation-property-first-derivative#Differentiation Property (First Derivative)":"L{df(t)dt}=sF(s)−f(0−)\\mathcal{L}\\left\\{\\frac{df(t)}{dt}\\right\\} = sF(s) - f(0^-)L{dtdf(t)​}=sF(s)−f(0−)Where:\nF(s) = Laplace transform of f(t) f(0-) = initial value at t = 0- For t \u003e 0 problems with f(0-) = f(0+): L{df(t)dt}=sF(s)−f(0)\\mathcal{L}\\left\\{\\frac{df(t)}{dt}\\right\\} = sF(s) - f(0)L{dtdf(t)​}=sF(s)−f(0)","differentiation-property-second-derivative#Differentiation Property (Second Derivative)":"L{d2f(t)dt2}=s2F(s)−sf(0)−f′(0)\\mathcal{L}\\left\\{\\frac{d^2f(t)}{dt^2}\\right\\} = s^2F(s) - sf(0) - f'(0)L{dt2d2f(t)​}=s2F(s)−sf(0)−f′(0)Where:\nf(0) = initial value f’(0) = initial derivative","effect-on-solution#Effect on Solution":"Initial conditions create additional terms in the s-domain equation:\nZero initial conditions: sF(s)+aF(s)=forcingsF(s) + aF(s) = \\text{forcing}sF(s)+aF(s)=forcingNon-zero initial conditions: sF(s)+aF(s)=forcing+IC termssF(s) + aF(s) = \\text{forcing} + \\text{IC terms}sF(s)+aF(s)=forcing+IC terms","example-1-first-order-rc-circuit#Example 1: First-Order RC Circuit":"","example-2-first-order-rl-circuit#Example 2: First-Order RL Circuit":"","example-3-second-order-rlc-circuit#Example 3: Second-Order RLC Circuit":"","example-4-first-order-with-non-zero-initial-condition#Example 4: First-Order with Non-Zero Initial Condition":"","integration-property#Integration Property":"L{∫0tf(τ)dτ}=F(s)s\\mathcal{L}\\left\\{\\int_0^t f(\\tau)d\\tau\\right\\} = \\frac{F(s)}{s}L{∫0t​f(τ)dτ}=sF(s)​","laplace-transform-properties#Laplace Transform Properties":"","linearity-property#Linearity Property":"L{af(t)+bg(t)}=aF(s)+bG(s)\\mathcal{L}\\{af(t) + bg(t)\\} = aF(s) + bG(s)L{af(t)+bg(t)}=aF(s)+bG(s)This means you can transform each term separately.","mistake-1-forgetting-initial-conditions#Mistake 1: Forgetting Initial Conditions":"WRONG: L{df/dt}=sF(s)\\mathcal{L}\\{df/dt\\} = sF(s)L{df/dt}=sF(s)\nRIGHT: L{df/dt}=sF(s)−f(0)\\mathcal{L}\\{df/dt\\} = sF(s) - f(0)L{df/dt}=sF(s)−f(0)","mistake-2-wrong-second-derivative-property#Mistake 2: Wrong Second Derivative Property":"WRONG: L{d2f/dt2}=s2F(s)−f(0)\\mathcal{L}\\{d²f/dt²\\} = s²F(s) - f(0)L{d2f/dt2}=s2F(s)−f(0)\nRIGHT: L{d2f/dt2}=s2F(s)−sf(0)−f′(0)\\mathcal{L}\\{d²f/dt²\\} = s²F(s) - sf(0) - f'(0)L{d2f/dt2}=s2F(s)−sf(0)−f′(0)","mistake-3-algebraic-errors-with-initial-conditions#Mistake 3: Algebraic Errors with Initial Conditions":"Keep initial condition terms until the end. Don’t drop them accidentally.","mistake-4-wrong-transform-of-input#Mistake 4: Wrong Transform of Input":"Make sure you’re using the correct Laplace transform for your input function.","natural-vs-forced-response#Natural vs. Forced Response":"The solution F(s) contains:\nForced response: From the input/source Natural response: From initial conditions Both appear in the final s-domain expression.","next-steps#Next Steps":"Proceed to: 09-path-b-complete-process.md for complete worked examples of the entire PATH B process from start to finish.\nFor inverse transform: Use your existing inverse Laplace transform documentation.","overview#Overview":"After deriving your differential equation in time domain (from 07-path-b-time-domain-analysis.md), you now apply the Laplace transform to convert it to an algebraic equation in s-domain.\ngraph TD A[Differential Equationin Time Domain] --\u003e B[Apply Laplace Transform] B --\u003e C[Use Differentiation Property] C --\u003e D[Substitute Initial Conditions] D --\u003e E[Algebraic Equation in s] style A fill:#ffe0b2 style E fill:#e8f5e9","path-b-applying-laplace-transform-to-differential-equations#PATH B: Applying Laplace Transform to Differential Equations":"PATH B: Applying Laplace Transform to Differential Equations","result#Result":"VC(s)=10000s(s+1000)V_C(s) = \\frac{10000}{s(s + 1000)}VC​(s)=s(s+1000)10000​Note: This matches the result from PATH A Example 1!","result-1#Result":"I(s)=2s+14(s+2)(s+20)I(s) = \\frac{2s + 14}{(s+2)(s+20)}I(s)=(s+2)(s+20)2s+14​","result-2#Result":"V(s)=3s+8s(s+1)V(s) = \\frac{3s + 8}{s(s+1)}V(s)=s(s+1)3s+8​The initial condition appears in the numerator!","solve-for-vs#Solve for V(s)":"V(s)[s+1]=8s+3V(s)[s + 1] = \\frac{8}{s} + 3V(s)[s+1]=s8​+3V(s)[s+1]=8+3ssV(s)[s + 1] = \\frac{8 + 3s}{s}V(s)[s+1]=s8+3s​V(s)=8+3ss(s+1)=3s+8s(s+1)V(s) = \\frac{8 + 3s}{s(s+1)} = \\frac{3s + 8}{s(s+1)}V(s)=s(s+1)8+3s​=s(s+1)3s+8​","starting-differential-equation#Starting Differential Equation":"From Example 1 in previous file: dvC(t)dt+1000vC(t)=10000u(t)\\frac{dv_C(t)}{dt} + 1000v_C(t) = 10000u(t)dtdvC​(t)​+1000vC​(t)=10000u(t)Given initial condition: v_C(0) = 0","starting-differential-equation-1#Starting Differential Equation":"From Example 2 in previous file: di(t)dt+20i(t)=10e−2tu(t)\\frac{di(t)}{dt} + 20i(t) = 10e^{-2t}u(t)dtdi(t)​+20i(t)=10e−2tu(t)Given initial condition: i(0) = 2A","starting-differential-equation-2#Starting Differential Equation":"From Example 3 in previous file (simplified): d2i(t)dt2+5di(t)dt+50i(t)=2.5dvs(t)dt\\frac{d^2i(t)}{dt^2} + 5\\frac{di(t)}{dt} + 50i(t) = 2.5\\frac{dv_s(t)}{dt}dt2d2i(t)​+5dtdi(t)​+50i(t)=2.5dtdvs​(t)​Given initial conditions: i(0) = 0, i’(0) = 0\nFor simplicity, let’s use v_s(t) = 10u(t) (step input): d2i(t)dt2+5di(t)dt+50i(t)=0\\frac{d^2i(t)}{dt^2} + 5\\frac{di(t)}{dt} + 50i(t) = 0dt2d2i(t)​+5dtdi(t)​+50i(t)=0(The RHS becomes 0 because dv_s/dt for a step is an impulse at t=0)","step-1-apply-laplace-transform#Step 1: Apply Laplace Transform":"L{dvC(t)dt}+1000L{vC(t)}=10000L{u(t)}\\mathcal{L}\\left\\{\\frac{dv_C(t)}{dt}\\right\\} + 1000\\mathcal{L}\\{v_C(t)\\} = 10000\\mathcal{L}\\{u(t)\\}L{dtdvC​(t)​}+1000L{vC​(t)}=10000L{u(t)}","step-1-apply-laplace-transform-1#Step 1: Apply Laplace Transform":"L{di(t)dt}+20L{i(t)}=10L{e−2tu(t)}\\mathcal{L}\\left\\{\\frac{di(t)}{dt}\\right\\} + 20\\mathcal{L}\\{i(t)\\} = 10\\mathcal{L}\\{e^{-2t}u(t)\\}L{dtdi(t)​}+20L{i(t)}=10L{e−2tu(t)}","step-1-apply-laplace-transform-2#Step 1: Apply Laplace Transform":"L{d2i(t)dt2}+5L{di(t)dt}+50L{i(t)}=0\\mathcal{L}\\left\\{\\frac{d^2i(t)}{dt^2}\\right\\} + 5\\mathcal{L}\\left\\{\\frac{di(t)}{dt}\\right\\} + 50\\mathcal{L}\\{i(t)\\} = 0L{dt2d2i(t)​}+5L{dtdi(t)​}+50L{i(t)}=0","step-1-apply-laplace-transform-to-both-sides#Step 1: Apply Laplace Transform to Both Sides":"Transform the entire differential equation term by term.","step-2-use-differentiation-properties#Step 2: Use Differentiation Properties":"s2I(s)−si(0)−i′(0)+5[sI(s)−i(0)]+50I(s)=0s^2I(s) - si(0) - i'(0) + 5[sI(s) - i(0)] + 50I(s) = 0s2I(s)−si(0)−i′(0)+5[sI(s)−i(0)]+50I(s)=0","step-2-use-differentiation-property#Step 2: Use Differentiation Property":"Replace derivatives with s-domain equivalents using the differentiation property.","step-2-use-differentiation-property-1#Step 2: Use Differentiation Property":"sVC(s)−vC(0)+1000VC(s)=10000⋅1ssV_C(s) - v_C(0) + 1000V_C(s) = 10000 \\cdot \\frac{1}{s}sVC​(s)−vC​(0)+1000VC​(s)=10000⋅s1​","step-2-use-differentiation-property-2#Step 2: Use Differentiation Property":"sI(s)−i(0)+20I(s)=10⋅1s+2sI(s) - i(0) + 20I(s) = 10 \\cdot \\frac{1}{s+2}sI(s)−i(0)+20I(s)=10⋅s+21​","step-3-substitute-initial-condition#Step 3: Substitute Initial Condition":"With v_C(0) = 0: sVC(s)−0+1000VC(s)=10000ssV_C(s) - 0 + 1000V_C(s) = \\frac{10000}{s}sVC​(s)−0+1000VC​(s)=s10000​sVC(s)+1000VC(s)=10000ssV_C(s) + 1000V_C(s) = \\frac{10000}{s}sVC​(s)+1000VC​(s)=s10000​","step-3-substitute-initial-condition-1#Step 3: Substitute Initial Condition":"With i(0) = 2: sI(s)−2+20I(s)=10s+2sI(s) - 2 + 20I(s) = \\frac{10}{s+2}sI(s)−2+20I(s)=s+210​","step-3-substitute-initial-conditions#Step 3: Substitute Initial Conditions":"Insert the known initial values: f(0), f’(0), etc.","step-3-substitute-initial-conditions-1#Step 3: Substitute Initial Conditions":"With i(0) = 0 and i’(0) = 0: s2I(s)−0−0+5sI(s)−0+50I(s)=0s^2I(s) - 0 - 0 + 5sI(s) - 0 + 50I(s) = 0s2I(s)−0−0+5sI(s)−0+50I(s)=0s2I(s)+5sI(s)+50I(s)=0s^2I(s) + 5sI(s) + 50I(s) = 0s2I(s)+5sI(s)+50I(s)=0","step-4-solve-for-fs#Step 4: Solve for F(s)":"Algebraically isolate the variable of interest (I(s) or V(s)).","step-4-solve-for-is#Step 4: Solve for I(s)":"I(s)[s+20]=10s+2+2I(s)[s + 20] = \\frac{10}{s+2} + 2I(s)[s+20]=s+210​+2Common denominator: I(s)[s+20]=10+2(s+2)s+2=10+2s+4s+2=2s+14s+2I(s)[s + 20] = \\frac{10 + 2(s+2)}{s+2} = \\frac{10 + 2s + 4}{s+2} = \\frac{2s + 14}{s+2}I(s)[s+20]=s+210+2(s+2)​=s+210+2s+4​=s+22s+14​I(s)=2s+14(s+2)(s+20)=2(s+7)(s+2)(s+20)I(s) = \\frac{2s + 14}{(s+2)(s+20)} = \\frac{2(s + 7)}{(s+2)(s+20)}I(s)=(s+2)(s+20)2s+14​=(s+2)(s+20)2(s+7)​","step-4-solve-for-is-1#Step 4: Solve for I(s)":"I(s)[s2+5s+50]=0I(s)[s^2 + 5s + 50] = 0I(s)[s2+5s+50]=0This gives I(s) = 0 (natural response is zero with zero initial conditions and zero forcing).\nBetter example with forcing function: If we keep the source term properly:\nFor v_s(t) = 10u(t), we need to go back to the KVL approach and use: vs(t)=Ri(t)+Ldi(t)dt+1C∫i(τ)dτv_s(t) = Ri(t) + L\\frac{di(t)}{dt} + \\frac{1}{C}\\int i(\\tau)d\\tauvs​(t)=Ri(t)+Ldtdi(t)​+C1​∫i(τ)dτThis is actually easier to handle via PATH A for RLC circuits!","step-4-solve-for-v_cs#Step 4: Solve for V_C(s)":"Factor out V_C(s): VC(s)[s+1000]=10000sV_C(s)[s + 1000] = \\frac{10000}{s}VC​(s)[s+1000]=s10000​VC(s)=10000s(s+1000)V_C(s) = \\frac{10000}{s(s + 1000)}VC​(s)=s(s+1000)10000​","step-5-simplify#Step 5: Simplify":"Put in standard form ready for inverse Laplace transform.","step-by-step-process#Step-by-Step Process":"","substitute-initial-condition#Substitute Initial Condition":"sV(s)−3+V(s)=8ssV(s) - 3 + V(s) = \\frac{8}{s}sV(s)−3+V(s)=s8​","summary#Summary":"PATH B Laplace transform process:\n✓ Start with differential equation from time domain ✓ Apply Laplace transform term by term ✓ Use differentiation property (includes initial conditions!) ✓ Substitute known initial values ✓ Solve algebraically for F(s) → Result: Same s-domain equation as PATH A Key insight: The differentiation property automatically incorporates initial conditions into the s-domain equation!","tip-1-write-out-the-differentiation-property#Tip 1: Write Out the Differentiation Property":"Don’t try to do it in your head. Write: L{dfdt}=sF(s)−f(0)\\mathcal{L}\\left\\{\\frac{df}{dt}\\right\\} = sF(s) - f(0)L{dtdf​}=sF(s)−f(0)","tip-2-handle-initial-conditions-carefully#Tip 2: Handle Initial Conditions Carefully":"Keep track of initial condition terms separately until you substitute values.","tip-3-check-dimensions#Tip 3: Check Dimensions":"After transformation, verify that all terms have consistent units in s-domain.","tip-4-factor-early#Tip 4: Factor Early":"As soon as you have the transformed equation, factor out F(s) or I(s) or V(s).","tip-5-simplify-the-forcing-function#Tip 5: Simplify the Forcing Function":"Transform the input function separately and clearly before substituting.","tips-for-applying-laplace-transform#Tips for Applying Laplace Transform":"","understanding-initial-conditions-in-laplace-domain#Understanding Initial Conditions in Laplace Domain":"","what-you-have-now#What You Have Now":"After completing PATH B Laplace transform:\nSame s-domain equation as you would get from PATH A Clear understanding of how initial conditions enter Explicit connection between time and s-domain Ready for inverse transform (same as PATH A ending)","when-path-a-is-better#When PATH A is Better":"PATH A is advantageous when:\nComplex circuits - Multiple components Time pressure - Exams with limited time Direct solution - Don’t need to see differential equation Standard problems - Most textbook problems Multiple sources - Easier in impedance form","when-path-b-is-better#When PATH B is Better":"PATH B is advantageous when:\nEducational context - You want to see the differential equation Simple circuits - RC or RL where the diff eq is easy Problem explicitly asks for the differential equation System analysis - Understanding natural frequency, damping, etc. You’re comfortable with differential equations","where-initial-conditions-appear#Where Initial Conditions Appear":"When you use the differentiation property: L{df(t)dt}=sF(s)−f(0)\\mathcal{L}\\left\\{\\frac{df(t)}{dt}\\right\\} = sF(s) - f(0)L{dtdf(t)​}=sF(s)−f(0)The f(0) term represents the initial condition."},"title":"8_laplace_transform"},"/electrical_notes/ee_300/9_whole_process_s-domain_time_domain/":{"data":{"advantage-1-explicit-differential-equation#Advantage 1: Explicit Differential Equation":"From Example 4, we can immediately see: d2i(t)dt2+2di(t)dt+10i(t)=forcing\\frac{d^2i(t)}{dt^2} + 2\\frac{di(t)}{dt} + 10i(t) = \\text{forcing}dt2d2i(t)​+2dtdi(t)​+10i(t)=forcingStandard form: d2idt2+2ζωndidt+ωn2i=forcing\\frac{d^2i}{dt^2} + 2\\zeta\\omega_n\\frac{di}{dt} + \\omega_n^2 i = \\text{forcing}dt2d2i​+2ζωn​dtdi​+ωn2​i=forcing\nWe can identify:\nωn2=10\\omega_n^2 = 10ωn2​=10 → ωn=10≈3.16\\omega_n = \\sqrt{10} \\approx 3.16ωn​=10​≈3.16 rad/s 2ζωn=22\\zeta\\omega_n = 22ζωn​=2 → ζ=110≈0.316\\zeta = \\frac{1}{\\sqrt{10}} \\approx 0.316ζ=10​1​≈0.316 System is underdamped (ζ \u003c 1) Damped frequency: ωd=ωn1−ζ2=3\\omega_d = \\omega_n\\sqrt{1-\\zeta^2} = 3ωd​=ωn​1−ζ2​=3 rad/s This physical insight is immediately clear in PATH B!","advantage-2-understanding-order#Advantage 2: Understanding Order":"The order of the differential equation tells you:\nFirst order (one derivative) → one energy storage element Second order (two derivatives) → two energy storage elements","advantage-3-initial-condition-clarity#Advantage 3: Initial Condition Clarity":"In the differential equation, you can see exactly where initial conditions enter:\ni(0) affects the zero-order term i’(0) affects the first-derivative term","advantages-of-path-b-demonstrated#Advantages of PATH B Demonstrated":"","comparison-path-a-vs-path-b-on-same-problem#Comparison: PATH A vs PATH B on Same Problem":"","complete-example-1-series-rc-circuit#Complete Example 1: Series RC Circuit":"","complete-example-2-series-rl-circuit#Complete Example 2: Series RL Circuit":"","complete-example-3-parallel-rc-circuit#Complete Example 3: Parallel RC Circuit":"","complete-example-4-series-rlc-circuit#Complete Example 4: Series RLC Circuit":"","disadvantage-1-more-steps#Disadvantage 1: More Steps":"PATH B requires:\nKVL/KCL in time domain Component substitution Algebraic manipulation Differentiation (if needed) THEN Laplace transform PATH A skips straight to s-domain (steps 1-2 become one transformation step).","disadvantage-2-more-algebra-in-time-domain#Disadvantage 2: More Algebra in Time Domain":"Manipulating time-domain equations with integrals and derivatives is often messier than working with impedances.","disadvantage-3-must-handle-integrals#Disadvantage 3: Must Handle Integrals":"For circuits with capacitors, you often get integrals that must be eliminated by differentiation, adding complexity.","disadvantages-of-path-b-demonstrated#Disadvantages of PATH B Demonstrated":"","key-takeaways#Key Takeaways":"Both paths give identical s-domain results PATH B shows the physics more clearly PATH A is faster for most problems Choose based on problem requirements Understanding both deepens your knowledge","next-steps#Next Steps":"To see reverse operations: Read 10-sdomain-to-differential-equation.md to learn how to derive the differential equation from an s-domain algebraic equation (going backwards from PATH A).\nTo compare side-by-side: Work the same problem both ways to see how results match.","overview#Overview":"This document presents the complete PATH B process from start to finish. PATH B derives the differential equation first in time domain, then applies Laplace transform.\ngraph TD A[Time Domain Circuit] --\u003e B[Step 1: Apply KVL/KCLin Time Domain] B --\u003e C[Step 2: SubstituteComponent Equations] C --\u003e D[Step 3: DeriveDifferential Equation] D --\u003e E[Step 4: ApplyLaplace Transform] E --\u003e F[Step 5: SubstituteInitial Conditions] F --\u003e G[Step 6: Solve forVs or Is] G --\u003e H[Step 7: Ready forInverse Laplace] style A fill:#ffebee style D fill:#ffe0b2 style E fill:#fff9c4 style G fill:#e8f5e9 style H fill:#c8e6c9","path-a-steps#PATH A Steps:":"Transform: R=10Ω, Z_L=0.5s, V_s=20/s KVL: 20/s = I(s)[10 + 0.5s] Add IC: 20/s = I(s)[10 + 0.5s] + Li(0) = I(s)[10 + 0.5s] + 1 Solve: I(s) = (20/s - 1)/(10 + 0.5s) = (2s + 40)/(s(s+20)) Total: ~4 steps","path-b-complete-process-with-examples#PATH B: Complete Process with Examples":"PATH B: Complete Process with Examples","path-b-steps#PATH B Steps:":"KVL time: v_s = Ri + Ldi/dt Substitute: 20u(t) = 10i + 0.5di/dt Standard form: di/dt + 20i = 40u(t) Laplace: sI(s) - i(0) + 20I(s) = 40/s Substitute IC: sI(s) - 2 + 20I(s) = 40/s Solve: I(s) = (40/s + 2)/(s+20) = (2s + 40)/(s(s+20)) Total: ~6 steps\nConclusion: PATH A is faster for this problem.","practice-problems#Practice Problems":"Try solving these using PATH B, then verify with PATH A:","problem-1-series-rc#Problem 1: Series RC":"v_s(t) = 5u(t) V R = 50Ω, C = 20µF v_C(0) = 0 Find v_C(t)","problem-2-parallel-rl#Problem 2: Parallel RL":"i_s(t) = 3u(t) A R = 6Ω, L = 2H i_L(0) = 1A Find v(t) across parallel combination","problem-3-series-rlc#Problem 3: Series RLC":"v_s(t) = 10u(t) V R = 4Ω, L = 1H, C = 0.25F i(0) = 0, v_C(0) = 0 Find i(t)","problem-series-rl-circuit#Problem: Series RL Circuit":"v_s(t) = 20u(t) V R = 10Ω, L = 0.5H i(0) = 2A","problem-statement#Problem Statement":"Find the voltage across the capacitor v_C(t) for t \\geq 0.\nGiven:\nv_s(t) = 10u(t) V R = 100Ω C = 10µF v_C(0) = 0","problem-statement-1#Problem Statement":"Find the current i(t) for t \\geq 0.\nGiven:\nv_s(t) = 20u(t) V R = 10Ω L = 0.5H i_L(0) = 2A","problem-statement-2#Problem Statement":"Find the voltage v(t) across the parallel combination for t \\geq 0.\nGiven:\ni_s(t) = 2u(t) A R = 4Ω C = 0.25F v(0) = 0","problem-statement-3#Problem Statement":"Find the current i(t) for t \\geq 0.\nGiven:\nv_s(t) = 10u(t) V R = 2Ω L = 1H C = 0.1F i(0) = 0, i’(0) = 0","scenario-1-problem-asks-for-differential-equation#Scenario 1: Problem Asks for Differential Equation":"Problem statement: “Derive the differential equation governing the circuit, then solve using Laplace transform.”\nPATH B is required here - you must show the differential equation explicitly.","scenario-2-system-analysis#Scenario 2: System Analysis":"Problem statement: “Find the natural frequency and damping ratio of the circuit.”\nPATH B makes this obvious from the differential equation standard form.","scenario-3-educational-context#Scenario 3: Educational Context":"When learning circuit theory, PATH B helps you understand:\nHow differential equations arise from physical laws The connection between circuit topology and system order Why certain responses occur (overdamped, underdamped, etc.)","step-1-apply-kcl-at-top-node#STEP 1: Apply KCL at Top Node":"is(t)=iR(t)+iC(t)i_s(t) = i_R(t) + i_C(t)is​(t)=iR​(t)+iC​(t)","step-1-apply-kvl-in-time-domain#STEP 1: Apply KVL in Time Domain":"Going around the loop: vs(t)=vR(t)+vC(t)v_s(t) = v_R(t) + v_C(t)vs​(t)=vR​(t)+vC​(t)","step-1-apply-kvl-in-time-domain-1#STEP 1: Apply KVL in Time Domain":"vs(t)=vR(t)+vL(t)v_s(t) = v_R(t) + v_L(t)vs​(t)=vR​(t)+vL​(t)","step-1-apply-kvl-in-time-domain-2#STEP 1: Apply KVL in Time Domain":"vs(t)=vR(t)+vL(t)+vC(t)v_s(t) = v_R(t) + v_L(t) + v_C(t)vs​(t)=vR​(t)+vL​(t)+vC​(t)","step-2-substitute-component-equations#STEP 2: Substitute Component Equations":"For resistor: vR(t)=R⋅i(t)v_R(t) = R \\cdot i(t)vR​(t)=R⋅i(t)For capacitor: i(t)=CdvC(t)dti(t) = C\\frac{dv_C(t)}{dt}i(t)=CdtdvC​(t)​Therefore: vR(t)=RCdvC(t)dtv_R(t) = RC\\frac{dv_C(t)}{dt}vR​(t)=RCdtdvC​(t)​Substitute values: vR(t)=100×10×10−6dvC(t)dt=10−3dvC(t)dtv_R(t) = 100 \\times 10 \\times 10^{-6} \\frac{dv_C(t)}{dt} = 10^{-3}\\frac{dv_C(t)}{dt}vR​(t)=100×10×10−6dtdvC​(t)​=10−3dtdvC​(t)​","step-2-substitute-component-equations-1#STEP 2: Substitute Component Equations":"For resistor: vR(t)=Ri(t)=10i(t)v_R(t) = Ri(t) = 10i(t)vR​(t)=Ri(t)=10i(t)For inductor: vL(t)=Ldi(t)dt=0.5di(t)dtv_L(t) = L\\frac{di(t)}{dt} = 0.5\\frac{di(t)}{dt}vL​(t)=Ldtdi(t)​=0.5dtdi(t)​","step-2-substitute-component-equations-2#STEP 2: Substitute Component Equations":"For resistor: iR(t)=v(t)R=v(t)4i_R(t) = \\frac{v(t)}{R} = \\frac{v(t)}{4}iR​(t)=Rv(t)​=4v(t)​For capacitor: iC(t)=Cdv(t)dt=0.25dv(t)dti_C(t) = C\\frac{dv(t)}{dt} = 0.25\\frac{dv(t)}{dt}iC​(t)=Cdtdv(t)​=0.25dtdv(t)​","step-2-substitute-component-equations-3#STEP 2: Substitute Component Equations":"For resistor: vR(t)=Ri(t)=2i(t)v_R(t) = Ri(t) = 2i(t)vR​(t)=Ri(t)=2i(t)For inductor: vL(t)=Ldi(t)dt=di(t)dtv_L(t) = L\\frac{di(t)}{dt} = \\frac{di(t)}{dt}vL​(t)=Ldtdi(t)​=dtdi(t)​For capacitor: vC(t)=1C∫0ti(τ)dτ+vC(0)=10.1∫0ti(τ)dτ+vC(0)v_C(t) = \\frac{1}{C}\\int_0^t i(\\tau)d\\tau + v_C(0) = \\frac{1}{0.1}\\int_0^t i(\\tau)d\\tau + v_C(0)vC​(t)=C1​∫0t​i(τ)dτ+vC​(0)=0.11​∫0t​i(τ)dτ+vC​(0)vC(t)=10∫0ti(τ)dτ+vC(0)v_C(t) = 10\\int_0^t i(\\tau)d\\tau + v_C(0)vC​(t)=10∫0t​i(τ)dτ+vC​(0)","step-3-derive-differential-equation#STEP 3: Derive Differential Equation":"Substitute into KVL: vs(t)=10−3dvC(t)dt+vC(t)v_s(t) = 10^{-3}\\frac{dv_C(t)}{dt} + v_C(t)vs​(t)=10−3dtdvC​(t)​+vC​(t)Rearrange to standard form: 10−3dvC(t)dt+vC(t)=vs(t)10^{-3}\\frac{dv_C(t)}{dt} + v_C(t) = v_s(t)10−3dtdvC​(t)​+vC​(t)=vs​(t)Divide by 10-³: dvC(t)dt+1000vC(t)=1000vs(t)\\frac{dv_C(t)}{dt} + 1000v_C(t) = 1000v_s(t)dtdvC​(t)​+1000vC​(t)=1000vs​(t)For v_s(t) = 10u(t): dvC(t)dt+1000vC(t)=10000u(t)\\frac{dv_C(t)}{dt} + 1000v_C(t) = 10000u(t)dtdvC​(t)​+1000vC​(t)=10000u(t)This is the differential equation.","step-3-derive-differential-equation-1#STEP 3: Derive Differential Equation":"Substitute into KVL: vs(t)=10i(t)+0.5di(t)dtv_s(t) = 10i(t) + 0.5\\frac{di(t)}{dt}vs​(t)=10i(t)+0.5dtdi(t)​Rearrange: 0.5di(t)dt+10i(t)=vs(t)0.5\\frac{di(t)}{dt} + 10i(t) = v_s(t)0.5dtdi(t)​+10i(t)=vs​(t)Divide by 0.5: di(t)dt+20i(t)=2vs(t)\\frac{di(t)}{dt} + 20i(t) = 2v_s(t)dtdi(t)​+20i(t)=2vs​(t)For v_s(t) = 20u(t): di(t)dt+20i(t)=40u(t)\\frac{di(t)}{dt} + 20i(t) = 40u(t)dtdi(t)​+20i(t)=40u(t)This is the differential equation.","step-3-derive-differential-equation-2#STEP 3: Derive Differential Equation":"Substitute into KCL: is(t)=v(t)4+0.25dv(t)dti_s(t) = \\frac{v(t)}{4} + 0.25\\frac{dv(t)}{dt}is​(t)=4v(t)​+0.25dtdv(t)​Rearrange: 0.25dv(t)dt+v(t)4=is(t)0.25\\frac{dv(t)}{dt} + \\frac{v(t)}{4} = i_s(t)0.25dtdv(t)​+4v(t)​=is​(t)Multiply by 4: dv(t)dt+v(t)=4is(t)\\frac{dv(t)}{dt} + v(t) = 4i_s(t)dtdv(t)​+v(t)=4is​(t)For i_s(t) = 2u(t): dv(t)dt+v(t)=8u(t)\\frac{dv(t)}{dt} + v(t) = 8u(t)dtdv(t)​+v(t)=8u(t)This is the differential equation.","step-3-derive-differential-equation-3#STEP 3: Derive Differential Equation":"Substitute into KVL: vs(t)=2i(t)+di(t)dt+10∫0ti(τ)dτ+vC(0)v_s(t) = 2i(t) + \\frac{di(t)}{dt} + 10\\int_0^t i(\\tau)d\\tau + v_C(0)vs​(t)=2i(t)+dtdi(t)​+10∫0t​i(τ)dτ+vC​(0)Differentiate to eliminate integral: dvs(t)dt=2di(t)dt+d2i(t)dt2+10i(t)\\frac{dv_s(t)}{dt} = 2\\frac{di(t)}{dt} + \\frac{d^2i(t)}{dt^2} + 10i(t)dtdvs​(t)​=2dtdi(t)​+dt2d2i(t)​+10i(t)Rearrange: d2i(t)dt2+2di(t)dt+10i(t)=dvs(t)dt\\frac{d^2i(t)}{dt^2} + 2\\frac{di(t)}{dt} + 10i(t) = \\frac{dv_s(t)}{dt}dt2d2i(t)​+2dtdi(t)​+10i(t)=dtdvs​(t)​For v_s(t) = 10u(t), the derivative is 10δ(t): d2i(t)dt2+2di(t)dt+10i(t)=10δ(t)\\frac{d^2i(t)}{dt^2} + 2\\frac{di(t)}{dt} + 10i(t) = 10\\delta(t)dt2d2i(t)​+2dtdi(t)​+10i(t)=10δ(t)This is the second-order differential equation.","step-4-apply-laplace-transform#STEP 4: Apply Laplace Transform":"Transform both sides: L{dvC(t)dt}+1000L{vC(t)}=10000L{u(t)}\\mathcal{L}\\left\\{\\frac{dv_C(t)}{dt}\\right\\} + 1000\\mathcal{L}\\{v_C(t)\\} = 10000\\mathcal{L}\\{u(t)\\}L{dtdvC​(t)​}+1000L{vC​(t)}=10000L{u(t)}Use differentiation property: sVC(s)−vC(0)+1000VC(s)=10000⋅1ssV_C(s) - v_C(0) + 1000V_C(s) = 10000 \\cdot \\frac{1}{s}sVC​(s)−vC​(0)+1000VC​(s)=10000⋅s1​","step-4-apply-laplace-transform-1#STEP 4: Apply Laplace Transform":"L{di(t)dt}+20L{i(t)}=40L{u(t)}\\mathcal{L}\\left\\{\\frac{di(t)}{dt}\\right\\} + 20\\mathcal{L}\\{i(t)\\} = 40\\mathcal{L}\\{u(t)\\}L{dtdi(t)​}+20L{i(t)}=40L{u(t)}sI(s)−i(0)+20I(s)=40ssI(s) - i(0) + 20I(s) = \\frac{40}{s}sI(s)−i(0)+20I(s)=s40​","step-4-apply-laplace-transform-2#STEP 4: Apply Laplace Transform":"sV(s)−v(0)+V(s)=8ssV(s) - v(0) + V(s) = \\frac{8}{s}sV(s)−v(0)+V(s)=s8​","step-4-apply-laplace-transform-3#STEP 4: Apply Laplace Transform":"s2I(s)−si(0)−i′(0)+2[sI(s)−i(0)]+10I(s)=10s^2I(s) - si(0) - i'(0) + 2[sI(s) - i(0)] + 10I(s) = 10s2I(s)−si(0)−i′(0)+2[sI(s)−i(0)]+10I(s)=10","step-5-substitute-initial-conditions#STEP 5: Substitute Initial Conditions":"Given v_C(0) = 0: sVC(s)−0+1000VC(s)=10000ssV_C(s) - 0 + 1000V_C(s) = \\frac{10000}{s}sVC​(s)−0+1000VC​(s)=s10000​VC(s)[s+1000]=10000sV_C(s)[s + 1000] = \\frac{10000}{s}VC​(s)[s+1000]=s10000​","step-5-substitute-initial-conditions-1#STEP 5: Substitute Initial Conditions":"Given i(0) = 2A: sI(s)−2+20I(s)=40ssI(s) - 2 + 20I(s) = \\frac{40}{s}sI(s)−2+20I(s)=s40​I(s)[s+20]=40s+2I(s)[s + 20] = \\frac{40}{s} + 2I(s)[s+20]=s40​+2Common denominator: I(s)[s+20]=40+2ssI(s)[s + 20] = \\frac{40 + 2s}{s}I(s)[s+20]=s40+2s​","step-5-substitute-initial-conditions-2#STEP 5: Substitute Initial Conditions":"Given v(0) = 0: sV(s)+V(s)=8ssV(s) + V(s) = \\frac{8}{s}sV(s)+V(s)=s8​V(s)[s+1]=8sV(s)[s + 1] = \\frac{8}{s}V(s)[s+1]=s8​","step-5-substitute-initial-conditions-3#STEP 5: Substitute Initial Conditions":"Given i(0) = 0, i’(0) = 0: s2I(s)−0−0+2sI(s)−0+10I(s)=10s^2I(s) - 0 - 0 + 2sI(s) - 0 + 10I(s) = 10s2I(s)−0−0+2sI(s)−0+10I(s)=10I(s)[s2+2s+10]=10I(s)[s^2 + 2s + 10] = 10I(s)[s2+2s+10]=10","step-6-solve-for-is#STEP 6: Solve for I(s)":"I(s)=40+2ss(s+20)=2s+40s(s+20)I(s) = \\frac{40 + 2s}{s(s+20)} = \\frac{2s + 40}{s(s+20)}I(s)=s(s+20)40+2s​=s(s+20)2s+40​Factor: I(s)=2(s+20)s(s+20)=2sI(s) = \\frac{2(s + 20)}{s(s+20)} = \\frac{2}{s}I(s)=s(s+20)2(s+20)​=s2​","step-6-solve-for-is-1#STEP 6: Solve for I(s)":"I(s)=10s2+2s+10I(s) = \\frac{10}{s^2 + 2s + 10}I(s)=s2+2s+1010​Complete the square: s2+2s+10=(s+1)2+9s^2 + 2s + 10 = (s+1)^2 + 9s2+2s+10=(s+1)2+9I(s)=10(s+1)2+9I(s) = \\frac{10}{(s+1)^2 + 9}I(s)=(s+1)2+910​","step-6-solve-for-v_cs#STEP 6: Solve for V_C(s)":"VC(s)=10000s(s+1000)V_C(s) = \\frac{10000}{s(s+1000)}VC​(s)=s(s+1000)10000​","step-6-solve-for-vs#STEP 6: Solve for V(s)":"V(s)=8s(s+1)V(s) = \\frac{8}{s(s+1)}V(s)=s(s+1)8​","step-7-ready-for-inverse-laplace-transform#STEP 7: Ready for Inverse Laplace Transform":"Final result: VC(s)=10000s(s+1000)V_C(s) = \\frac{10000}{s(s+1000)}VC​(s)=s(s+1000)10000​Note: This exactly matches PATH A Example 1!","step-7-ready-for-inverse-laplace-transform-1#STEP 7: Ready for Inverse Laplace Transform":"Final result: I(s)=2sI(s) = \\frac{2}{s}I(s)=s2​This is simple: i(t)=2u(t)i(t) = 2u(t)i(t)=2u(t) A\nPhysical interpretation: With 20V applied across 10Ω total resistance, steady-state current is 2A. The initial condition i(0)=2A means we start at steady state!","step-7-ready-for-inverse-laplace-transform-2#STEP 7: Ready for Inverse Laplace Transform":"Final result: V(s)=8s(s+1)V(s) = \\frac{8}{s(s+1)}V(s)=s(s+1)8​","step-7-ready-for-inverse-laplace-transform-3#STEP 7: Ready for Inverse Laplace Transform":"Final result: I(s)=10(s+1)2+9=10(s+1)2+32I(s) = \\frac{10}{(s+1)^2 + 9} = \\frac{10}{(s+1)^2 + 3^2}I(s)=(s+1)2+910​=(s+1)2+3210​This has the form of a damped sinusoid: ω(s+α)2+ω2\\frac{\\omega}{(s+\\alpha)^2 + \\omega^2}(s+α)2+ω2ω​ where ω=3, α=1\nThe inverse transform will be: i(t)=103e−tsin⁡(3t)u(t)i(t) = \\frac{10}{3}e^{-t}\\sin(3t)u(t)i(t)=310​e−tsin(3t)u(t) A","summary-flow-chart#Summary Flow Chart":"graph TD A[Time Domain Circuit] --\u003e B[PATH B Process] B --\u003e C[Apply KVL/KCL in time] C --\u003e D[Substitute component equations] D --\u003e E[Derive differential equation] E --\u003e F[Apply Laplace transform] F --\u003e G[Use differentiation property] G --\u003e H[Substitute initial conditions] H --\u003e I[Algebraic equation in s] I --\u003e J[Solve for Vs or Is] J --\u003e K[Ready for inverse Laplace] style A fill:#ffebee style E fill:#ffe0b2 style F fill:#fff9c4 style I fill:#e8f5e9 style K fill:#c8e6c9 Final insight: PATH B takes longer but gives deeper understanding. PATH A is faster but hides the differential equation. Master both!","summary-table-path-a-vs-path-b#Summary Table: PATH A vs PATH B":"Aspect PATH A PATH B Speed Faster Slower Steps Fewer (~4) More (~6) Math Algebraic (impedances) Differential equations Physical insight Less direct More direct Diff eq visible? No (implicit) Yes (explicit) Learning value Good for solving Better for understanding Exam preference More common Less common Best for Complex circuits Simple circuits Initial conditions Added as sources In Laplace property System parameters Requires derivation Immediately visible","time-domain-circuit#Time Domain Circuit":"v_s(t) = 10u(t) V ----[R=100Ω]----[C=10µF]---- ground","time-domain-circuit-1#Time Domain Circuit":"v_s(t) = 20u(t) V ----[R=10Ω]----[L=0.5H]---- ground","time-domain-circuit-2#Time Domain Circuit":"i_s(t) = 2u(t) A | +----v(t)----+ | | R=4Ω C=0.25F | | ground ground","time-domain-circuit-3#Time Domain Circuit":"v_s(t) = 10u(t) V ----[R=2Ω]----[L=1H]----[C=0.1F]---- ground","when-path-b-is-actually-better#When PATH B is Actually Better":""},"title":"9_whole_process_s-domain_time_domain"},"/electrical_notes/ee_300/cheatsheet_2.0/":{"data":{"1-laplace-transform-fundamentals#1. Laplace Transform Fundamentals":"","10-critical-reminders--common-mistakes#10. Critical Reminders \u0026amp; Common Mistakes":"","11-quick-reference-table#11. Quick Reference Table":"","12-analysis-workflow-summary#12. Analysis Workflow Summary":"Circuit → Network Function:\nTransform to s-domain Zero ICs Circuit analysis Form H(s)=OutInH(s) = \\frac{\\text{Out}}{\\text{In}}H(s)=InOut​ H(s) → Poles/Zeros:\nExpress as N(s)D(s)\\frac{N(s)}{D(s)}D(s)N(s)​ N(s)=0N(s) = 0N(s)=0 → zeros D(s)=0D(s) = 0D(s)=0 → poles s-Domain → Time Domain:\nCheck PRF/IRF Factor denominator Setup PFE Find residues (cover-up) Inverse transform Add u(t)u(t)u(t) H(s) → Differential Equation:\nCross-multiply Replace s→ddts \\to \\frac{d}{dt}s→dtd​ Write ODE System Stability:\nCheck all poles All Re(s)\u003c0\\text{Re}(s) \u003c 0Re(s)\u003c0 → Stable Any Re(s)≥0\\text{Re}(s) \\geq 0Re(s)≥0 → Unstable","2-s-domain-circuit-elements#2. s-Domain Circuit Elements":"","3-circuit-response-components#3. Circuit Response Components":"","4-network-functions-transfer-functions#4. Network Functions (Transfer Functions)":"","5-poles-and-zeros#5. Poles and Zeros":"","6-inverse-laplace-transform-via-partial-fraction-expansion#6. Inverse Laplace Transform via Partial Fraction Expansion":"","7-initial-and-final-value-theorems#7. Initial and Final Value Theorems":"","8-step-by-step-problem-solving-procedures#8. Step-by-Step Problem-Solving Procedures":"","9-problem-solving-decision-tree#9. Problem-Solving Decision Tree":"","a-finding-network-function-hs-from-circuit#A. Finding Network Function H(s) from Circuit":"Transform all elements to s-domain: RRR, 1sC\\frac{1}{sC}sC1​, sLsLsL Zero ALL initial conditions (voltage sources → short, current sources → open) Transform input sources to s-domain Define input and output variables Apply circuit analysis: Voltage/current divider Series/parallel combinations Nodal analysis (KCL) Mesh analysis (KVL) Form H(s)=Output(s)Input(s)H(s) = \\frac{\\text{Output}(s)}{\\text{Input}(s)}H(s)=Input(s)Output(s)​ Simplify to rational function form","b-finding-poles-and-zeros#B. Finding Poles and Zeros":"Express H(s)=N(s)D(s)H(s) = \\frac{N(s)}{D(s)}H(s)=D(s)N(s)​ in polynomial form Find Zeros: Set N(s)=0N(s) = 0N(s)=0, solve for sss 1st order: s=−bas = -\\frac{b}{a}s=−ab​ 2nd order: s=−b±b2−4ac2as = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}s=2a−b±b2−4ac​​ Higher: Factor or numerical methods Find Poles: Set D(s)=0D(s) = 0D(s)=0, solve for sss (same methods) Check discriminant (Δ=b2−4ac\\Delta = b^2 - 4acΔ=b2−4ac) for 2nd order: Δ\u003e0\\Delta \u003e 0Δ\u003e0: Two real poles Δ=0\\Delta = 0Δ=0: Repeated real pole Δ\u003c0\\Delta \u003c 0Δ\u003c0: Complex conjugate pair","c-finding-time-response-via-inverse-laplace#C. Finding Time Response via Inverse Laplace":"Calculate Vout(s)=H(s)⋅Vin(s)V_{out}(s) = H(s) \\cdot V_{in}(s)Vout​(s)=H(s)⋅Vin​(s) Check if PRF or IRF If IRF: Perform long division first Factor denominator completely to find ALL poles Setup PFE based on pole types (distinct, complex, repeated) Find residues: Simple poles: Cover-up method Complex poles: Cover-up, then convert to magnitude/angle Repeated poles: Derivative method Inverse transform each term Add u(t)u(t)u(t) to ensure causality Identify components: Terms from H(s)H(s)H(s) poles = Natural response Terms from Vin(s)V_{in}(s)Vin​(s) poles = Forced response","case-1-distinct-real-poles#Case 1: Distinct Real Poles":"PFE Setup: F(s)=k1s−p1+k2s−p2+⋯+kns−pnF(s) = \\frac{k_1}{s-p_1} + \\frac{k_2}{s-p_2} + \\cdots + \\frac{k_n}{s-p_n}F(s)=s−p1​k1​​+s−p2​k2​​+⋯+s−pn​kn​​Cover-Up Method for Residue kik_iki​: ki=[(s−pi)F(s)]s=pik_i = \\left[(s-p_i)F(s)\\right]_{s=p_i}ki​=[(s−pi​)F(s)]s=pi​​Time Domain: f(t)=∑i=1nkiepitu(t)f(t) = \\sum_{i=1}^{n} k_i e^{p_i t} u(t)f(t)=i=1∑n​ki​epi​tu(t)","case-2-complex-conjugate-poles#Case 2: Complex Conjugate Poles":"Poles: s=−α±jβs = -\\alpha \\pm j\\betas=−α±jβ\nPFE: F(s)=ks−(−α+jβ)+k∗s−(−α−jβ)+(other terms)F(s) = \\frac{k}{s-(-\\alpha+j\\beta)} + \\frac{k^*}{s-(-\\alpha-j\\beta)} + \\text{(other terms)}F(s)=s−(−α+jβ)k​+s−(−α−jβ)k∗​+(other terms)Time Domain: f(t)=2∣k∣e−αtcos⁡(βt+∠k)u(t)+(other terms)f(t) = 2|k|e^{-\\alpha t}\\cos(\\beta t + \\angle k)u(t) + \\text{(other terms)}f(t)=2∣k∣e−αtcos(βt+∠k)u(t)+(other terms)Alternative (Real Form): f(t)=e−αt[Acos⁡(βt)+Bsin⁡(βt)]u(t)f(t) = e^{-\\alpha t}[A\\cos(\\beta t) + B\\sin(\\beta t)]u(t)f(t)=e−αt[Acos(βt)+Bsin(βt)]u(t) where A=2Re{k}A = 2\\text{Re}\\{k\\}A=2Re{k}, B=−2Im{k}B = -2\\text{Im}\\{k\\}B=−2Im{k}","case-3-repeated-poles#Case 3: Repeated Poles":"Pole at s=ps = ps=p with multiplicity mmm:\nPFE: F(s)=km(s−p)m+km−1(s−p)m−1+⋯+k1s−p+(other terms)F(s) = \\frac{k_m}{(s-p)^m} + \\frac{k_{m-1}}{(s-p)^{m-1}} + \\cdots + \\frac{k_1}{s-p} + \\text{(other terms)}F(s)=(s−p)mkm​​+(s−p)m−1km−1​​+⋯+s−pk1​​+(other terms)Residue Formulas: km=[(s−p)mF(s)]s=pk_m = \\left[(s-p)^m F(s)\\right]_{s=p}km​=[(s−p)mF(s)]s=p​ km−1=[dds(s−p)mF(s)]s=pk_{m-1} = \\left[\\frac{d}{ds}(s-p)^m F(s)\\right]_{s=p}km−1​=[dsd​(s−p)mF(s)]s=p​ km−j=[1j!djdsj(s−p)mF(s)]s=pk_{m-j} = \\left[\\frac{1}{j!}\\frac{d^j}{ds^j}(s-p)^m F(s)\\right]_{s=p}km−j​=[j!1​dsjdj​(s−p)mF(s)]s=p​Time Domain: f(t)=[kmtm−1(m−1)!+km−1tm−2(m−2)!+⋯+k1]eptu(t)+(other terms)f(t) = \\left[k_m\\frac{t^{m-1}}{(m-1)!} + k_{m-1}\\frac{t^{m-2}}{(m-2)!} + \\cdots + k_1\\right]e^{pt}u(t) + \\text{(other terms)}f(t)=[km​(m−1)!tm−1​+km−1​(m−2)!tm−2​+⋯+k1​]eptu(t)+(other terms)","case-4-improper-rational-functions#Case 4: Improper Rational Functions":"If numerator degree \\geq denominator degree:\nPerform polynomial long division: F(s)=Q(s)+R(s)D(s)F(s) = Q(s) + \\frac{R(s)}{D(s)}F(s)=Q(s)+D(s)R(s)​ Apply PFE to proper fraction R(s)D(s)\\frac{R(s)}{D(s)}D(s)R(s)​ Transform polynomial terms: L−1{sn}=δ(n)(t)\\mathcal{L}^{-1}\\{s^n\\} = \\delta^{(n)}(t)L−1{sn}=δ(n)(t) (derivatives of impulse)","case-5-delayed-functions#Case 5: Delayed Functions":"L−1{F(s)e−sT}=f(t−T)u(t−T)\\mathcal{L}^{-1}\\{F(s)e^{-sT}\\} = f(t-T)u(t-T)L−1{F(s)e−sT}=f(t−T)u(t−T)","common-errors#Common Errors":"✗ Wrong impedances: CCC is 1sC\\frac{1}{sC}sC1​ NOT sCsCsC; LLL is sLsLsL NOT 1sL\\frac{1}{sL}sL1​ ✗ Confusing poles (denominator) with zeros (numerator) ✗ Using FVT when poles at origin or in right half-plane ✗ Forgetting initial condition sources in s-domain circuit ✗ Not checking if PRF before applying IVT ✗ Mixing up natural (from H(s)H(s)H(s) poles) vs forced (from input poles) response ✗ Incorrect signs on initial condition sources","common-transform-pairs#Common Transform Pairs":"Time Domain f(t)f(t)f(t) s-Domain F(s)F(s)F(s) δ(t)\\delta(t)δ(t) 111 u(t)u(t)u(t) 1s\\frac{1}{s}s1​ ttt 1s2\\frac{1}{s^2}s21​ tnt^ntn n!sn+1\\frac{n!}{s^{n+1}}sn+1n!​ eate^{at}eat 1s−a\\frac{1}{s-a}s−a1​ teatte^{at}teat 1(s−a)2\\frac{1}{(s-a)^2}(s−a)21​ cos⁡(ωt)\\cos(\\omega t)cos(ωt) ss2+ω2\\frac{s}{s^2+\\omega^2}s2+ω2s​ sin⁡(ωt)\\sin(\\omega t)sin(ωt) ωs2+ω2\\frac{\\omega}{s^2+\\omega^2}s2+ω2ω​ e−atcos⁡(ωt)e^{-at}\\cos(\\omega t)e−atcos(ωt) s+a(s+a)2+ω2\\frac{s+a}{(s+a)^2+\\omega^2}(s+a)2+ω2s+a​ e−atsin⁡(ωt)e^{-at}\\sin(\\omega t)e−atsin(ωt) ω(s+a)2+ω2\\frac{\\omega}{(s+a)^2+\\omega^2}(s+a)2+ω2ω​","complete-linear-circuit-analysis-cheat-sheet#Complete Linear Circuit Analysis Cheat Sheet":"Complete Linear Circuit Analysis Cheat Sheet","complex-pole-response#Complex Pole Response":"Poles at s=−α±jβ ⟹ f(t)=2∣k∣e−αtcos⁡(βt+∠k)u(t)\\text{Poles at } s = -\\alpha \\pm j\\beta \\implies f(t) = 2|k|e^{-\\alpha t}\\cos(\\beta t + \\angle k)u(t)Poles at s=−α±jβ⟹f(t)=2∣k∣e−αtcos(βt+∠k)u(t)","cover-up-method#Cover-Up Method":"ki=[(s−pi)F(s)]s=pik_i = \\left[(s-p_i)F(s)\\right]_{s=p_i}ki​=[(s−pi​)F(s)]s=pi​​","d-converting-hs-to-differential-equation#D. Converting H(s) to Differential Equation":"Start with H(s)=Vout(s)Vin(s)=N(s)D(s)H(s) = \\frac{V_{out}(s)}{V_{in}(s)} = \\frac{N(s)}{D(s)}H(s)=Vin​(s)Vout​(s)​=D(s)N(s)​ Cross-multiply: Vout(s)⋅D(s)=Vin(s)⋅N(s)V_{out}(s) \\cdot D(s) = V_{in}(s) \\cdot N(s)Vout​(s)⋅D(s)=Vin​(s)⋅N(s) Replace sss operators: s→ddts \\to \\frac{d}{dt}s→dtd​ s2→d2dt2s^2 \\to \\frac{d^2}{dt^2}s2→dt2d2​ sn→dndtns^n \\to \\frac{d^n}{dt^n}sn→dtndn​ Write ODE: D(ddt)vout(t)=N(ddt)vin(t)D\\left(\\frac{d}{dt}\\right) v_{out}(t) = N\\left(\\frac{d}{dt}\\right) v_{in}(t)D(dtd​)vout​(t)=N(dtd​)vin​(t) Key: Denominator (poles) → output side (left), Numerator (zeros) → input side (right)","definition#Definition":"F(s)=L{f(t)}=∫0∞f(t)e−stdtwhere s=σ+jωF(s) = \\mathcal{L}\\{f(t)\\} = \\int_0^\\infty f(t)e^{-st} dt \\quad \\text{where } s = \\sigma + j\\omegaF(s)=L{f(t)}=∫0∞​f(t)e−stdtwhere s=σ+jω","definition-1#Definition":"H(s)=Output(s)Input(s)[with ALL initial conditions = 0]H(s) = \\frac{\\text{Output}(s)}{\\text{Input}(s)} \\quad \\text{[with ALL initial conditions = 0]}H(s)=Input(s)Output(s)​[with ALL initial conditions = 0]","definitions#Definitions":"ZEROS: Solutions to N(s)=0N(s) = 0N(s)=0 (numerator roots)\nFrequencies where H(s)=0H(s) = 0H(s)=0 Signals at these frequencies are blocked from output Correspond to input side of differential equation POLES: Solutions to D(s)=0D(s) = 0D(s)=0 (denominator roots, characteristic equation)\nFrequencies where H(s)→∞H(s) \\to \\inftyH(s)→∞ Determine natural response modes Always present in output Correspond to output side of differential equation","differentiation-property#Differentiation Property":"L{dfdt}=sF(s)−f(0−)\\mathcal{L}\\left\\{\\frac{df}{dt}\\right\\} = sF(s) - f(0^-)L{dtdf​}=sF(s)−f(0−)","e-solving-differential-equations-with-laplace#E. Solving Differential Equations with Laplace":"Take Laplace transform of entire equation Apply differentiation property: L{f(n)}=snF(s)−sn−1f(0−)−⋯−f(n−1)(0−)\\mathcal{L}\\{f^{(n)}\\} = s^n F(s) - s^{n-1}f(0^-) - \\cdots - f^{(n-1)}(0^-)L{f(n)}=snF(s)−sn−1f(0−)−⋯−f(n−1)(0−) Substitute known initial conditions Solve algebraically for F(s)F(s)F(s) Apply inverse Laplace (PFE + residues) Verify using IVT/FVT if applicable","element-impedances#Element Impedances":"Element Time Domain s-Domain Impedance Initial Condition Model Resistor v=Riv = Riv=Ri ZR=RZ_R = RZR​=R None Capacitor i=Cdvdti = C\\frac{dv}{dt}i=Cdtdv​ ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​ Series: vc(0−)s\\frac{v_c(0^-)}{s}svc​(0−)​\nParallel: Cvc(0−)Cv_c(0^-)Cvc​(0−) Inductor v=Ldidtv = L\\frac{di}{dt}v=Ldtdi​ ZL=sLZ_L = sLZL​=sL Series: LiL(0−)Li_L(0^-)LiL​(0−)","essential-properties#Essential Properties":"Linearity: L{af(t)+bg(t)}=aF(s)+bG(s)\\mathcal{L}\\{af(t) + bg(t)\\} = aF(s) + bG(s)L{af(t)+bg(t)}=aF(s)+bG(s)Frequency Shift: L{e−atf(t)}=F(s+a)\\mathcal{L}\\{e^{-at}f(t)\\} = F(s+a)L{e−atf(t)}=F(s+a)Time Shift: L{f(t−T)u(t−T)}=e−sTF(s)\\mathcal{L}\\{f(t-T)u(t-T)\\} = e^{-sT}F(s)L{f(t−T)u(t−T)}=e−sTF(s)Differentiation (CRITICAL): L{dfdt}=sF(s)−f(0−)\\mathcal{L}\\left\\{\\frac{df}{dt}\\right\\} = sF(s) - f(0^-)L{dtdf​}=sF(s)−f(0−) L{d2fdt2}=s2F(s)−sf(0−)−f′(0−)\\mathcal{L}\\left\\{\\frac{d^2f}{dt^2}\\right\\} = s^2F(s) - sf(0^-) - f'(0^-)L{dt2d2f​}=s2F(s)−sf(0−)−f′(0−)Integration: L{∫0tf(τ)dτ}=1sF(s)\\mathcal{L}\\left\\{\\int_0^t f(\\tau)d\\tau\\right\\} = \\frac{1}{s}F(s)L{∫0t​f(τ)dτ}=s1​F(s)","f-complete-circuit-analysis-with-initial-conditions#F. Complete Circuit Analysis with Initial Conditions":"Analyze t\u003c0t \u003c 0t\u003c0 circuit: Find vC(0−)v_C(0^-)vC​(0−) and iL(0−)i_L(0^-)iL​(0−) Draw s-domain circuit for t≥0t \\geq 0t≥0: Replace elements with impedances Add initial condition sources: Capacitor: vc(0−)s\\frac{v_c(0^-)}{s}svc​(0−)​ in series with 1sC\\frac{1}{sC}sC1​ Inductor: LiL(0−)Li_L(0^-)LiL​(0−) in series with sLsLsL Transform input sources Apply circuit analysis (KVL, KCL, nodal, mesh) in s-domain Solve for desired V(s)V(s)V(s) or I(s)I(s)I(s) Apply inverse Laplace transform (Optional) Verify with IVT: v(0+)v(0^+)v(0+) or FVT: v(∞)v(\\infty)v(∞)","final-value-theorem-fvt#Final Value Theorem (FVT)":"f(∞)=lim⁡s→0sF(s)f(\\infty) = \\lim_{s \\to 0} sF(s)f(∞)=s→0lim​sF(s)Requirements: ALL poles of sF(s)sF(s)sF(s) must have Re(s)\u003c0\\text{Re}(s) \u003c 0Re(s)\u003c0 (left half-plane)\n⚠️ Warning: FVT is invalid if poles exist at s=0s = 0s=0 or in right half-plane","initial-value-theorem-ivt#Initial Value Theorem (IVT)":"f(0+)=lim⁡s→∞sF(s)f(0^+) = \\lim_{s \\to \\infty} sF(s)f(0+)=s→∞lim​sF(s)Requirements: F(s)F(s)F(s) must be PRF (proper rational function)","kirchhoffs-laws-in-s-domain#Kirchhoff\u0026rsquo;s Laws in s-Domain":"KVL: ∑Vi(s)=0\\sum V_i(s) = 0∑Vi​(s)=0 (around closed loops) KCL: ∑Ii(s)=0\\sum I_i(s) = 0∑Ii​(s)=0 (at nodes)","must-remember#Must Remember":"✓ Always zero initial conditions when finding H(s)H(s)H(s) ✓ H(s)H(s)H(s) describes ZSR only, not ZIR ✓ Include u(t)u(t)u(t) in all time-domain responses ✓ Complex poles always come in conjugate pairs ✓ Check FVT applicability before using (poles must be in left half-plane) ✓ Factor denominator completely before PFE","natural-vs-forced-response#Natural vs Forced Response":"Natural Response:\nFrom poles of H(s)H(s)H(s) (network function) Circuit’s inherent modes Independent of input type Determined by R, L, C values Forced Response:\nFrom poles of input signal Vin(s)V_{in}(s)Vin​(s) Same frequency as input Amplitude scaled by H(s)H(s)H(s) at input frequency","network-function#Network Function":"H(s)=N(s)D(s)=Output(s)Input(s)[ICs = 0]H(s) = \\frac{N(s)}{D(s)} = \\frac{\\text{Output}(s)}{\\text{Input}(s)} \\quad \\text{[ICs = 0]}H(s)=D(s)N(s)​=Input(s)Output(s)​[ICs = 0]","pole-response-relationships#Pole-Response Relationships":"Pole Location Time Response Stability Real: s=−αs = -\\alphas=−α (α\u003e0\\alpha \u003e 0α\u003e0) ke−αtke^{-\\alpha t}ke−αt (decay) Stable Real: s=+αs = +\\alphas=+α ke+αtke^{+\\alpha t}ke+αt (growth) Unstable Complex: s=−α±jωds = -\\alpha \\pm j\\omega_ds=−α±jωd​ Ae−αtcos⁡(ωdt+ϕ)Ae^{-\\alpha t}\\cos(\\omega_d t + \\phi)Ae−αtcos(ωd​t+ϕ) Stable if α\u003e0\\alpha \u003e 0α\u003e0 Imaginary: s=±jω0s = \\pm j\\omega_0s=±jω0​ Acos⁡(ω0t+ϕ)A\\cos(\\omega_0 t + \\phi)Acos(ω0​t+ϕ) Marginally stable Origin: s=0s = 0s=0 kkk (constant/step) Marginally stable Stability Rule: System is stable if ALL poles have Re(s)\u003c0\\text{Re}(s) \u003c 0Re(s)\u003c0 (left half-plane)","poles-and-zeros#Poles and Zeros":"Zeros: N(s)=0Poles: D(s)=0\\text{Zeros: } N(s) = 0 \\qquad \\text{Poles: } D(s) = 0Zeros: N(s)=0Poles: D(s)=0","rational-function-form#Rational Function Form":"H(s)=N(s)D(s)=amsm+am−1sm−1+⋯+a0bnsn+bn−1sn−1+⋯+b0H(s) = \\frac{N(s)}{D(s)} = \\frac{a_m s^m + a_{m-1}s^{m-1} + \\cdots + a_0}{b_n s^n + b_{n-1}s^{n-1} + \\cdots + b_0}H(s)=D(s)N(s)​=bn​sn+bn−1​sn−1+⋯+b0​am​sm+am−1​sm−1+⋯+a0​​","resonance-condition#Resonance Condition":"When input frequency = pole frequency: Output term becomes t⋅estt \\cdot e^{st}t⋅est (grows with time)","s-domain-impedances#s-Domain Impedances":"ZR=RZC=1sCZL=sLZ_R = R \\qquad Z_C = \\frac{1}{sC} \\qquad Z_L = sLZR​=RZC​=sC1​ZL​=sL","terminology#Terminology":"PRF (Proper Rational Function): Numerator degree \u003c denominator degree IRF (Improper Rational Function): Numerator degree \\geq denominator degree","total-response-breakdown#Total Response Breakdown":"Total Response=ZIR+ZSR\\text{Total Response} = \\text{ZIR} + \\text{ZSR}Total Response=ZIR+ZSRZero-Input Response (ZIR):\nCaused by initial conditions only (stored energy) No external sources Purely natural response Zero-State Response (ZSR):\nCaused by external inputs only All initial conditions = 0 Contains natural + forced response","types#Types":"Transfer Function: H(s)=Vout(s)Vin(s)H(s) = \\frac{V_{out}(s)}{V_{in}(s)}H(s)=Vin​(s)Vout​(s)​ or Iout(s)Iin(s)\\frac{I_{out}(s)}{I_{in}(s)}Iin​(s)Iout​(s)​ (different ports) Driving-Point Impedance: Z(s)=V(s)I(s)Z(s) = \\frac{V(s)}{I(s)}Z(s)=I(s)V(s)​ (same port) Driving-Point Admittance: Y(s)=I(s)V(s)=1Z(s)Y(s) = \\frac{I(s)}{V(s)} = \\frac{1}{Z(s)}Y(s)=V(s)I(s)​=Z(s)1​ (same port)","value-theorems#Value Theorems":"f(0+)=lim⁡s→∞sF(s)(PRF only)f(0^+) = \\lim_{s \\to \\infty} sF(s) \\quad \\text{(PRF only)}f(0+)=s→∞lim​sF(s)(PRF only) f(∞)=lim⁡s→0sF(s)(stable only)f(\\infty) = \\lim_{s \\to 0} sF(s) \\quad \\text{(stable only)}f(∞)=s→0lim​sF(s)(stable only)","when-given-a-circuit#When given a CIRCUIT:":"Need H(s)H(s)H(s)? → Procedure A (zero ICs!) Need poles/zeros? → First find H(s)H(s)H(s), then Procedure B Need time response? → Find H(s)H(s)H(s), then Procedure C Have initial conditions? → Procedure F","when-given-differential-equation#When given DIFFERENTIAL EQUATION:":"Need H(s)H(s)H(s)? → Laplace transform both sides, solve for Output/Input Need solution? → Procedure E Need poles/zeros? → First get H(s)H(s)H(s), then Procedure B","when-given-hs#When given H(s):":"Need poles/zeros? → Procedure B Need differential equation? → Procedure D Need time response? → Procedure C (need input too)"},"title":"cheatsheet_2.0"},"/electrical_notes/ee_300/exam_1_cheatsheet_pandoc/":{"data":{"1-linearity#1. Linearity":"","2-frequency-shift-multiply-by-#2. Frequency Shift (Multiply by )":"","3-time-shift-delay-property#3. Time Shift (Delay Property)":"","4-differentiation-property-critical-for-circuits#4. Differentiation Property \u003cstrong\u003eCRITICAL FOR CIRCUITS\u003c/strong\u003e":"","5-integration-property#5. Integration Property":"","6-multiply-by--property#6. Multiply by  Property":"","capacitor-s-domain-model-detailed#Capacitor S-Domain Model (Detailed)":"Series representation:\nv(0-)/s + 1/sC ----[+|-]----[====]---- (voltage (impedance) source) Parallel representation:\n1/sC Cv(0-) ----[====]----[--|\u003e]---- (impedance) (current source) Equation: IC(s)=sCV(s)−Cv(0−)I_C(s) = sCV(s) - Cv(0^-)IC​(s)=sCV(s)−Cv(0−)","case-1-distinct-real-poles#Case 1: Distinct Real Poles":"","case-2-complex-conjugate-poles#Case 2: Complex Conjugate Poles":"","case-3-multiple-order-poles#Case 3: Multiple-Order Poles":"","case-4-improper-rational-functions-irf#Case 4: Improper Rational Functions (IRF)":"","case-5-delayed-functions--terms#Case 5: Delayed Functions ( terms)":"Comprehensive Laplace Transform Cheat Sheet for Linear Circuit AnalysisTable of Contents Laplace Transform Fundamentals Six Essential Properties Inverse Laplace Transform Circuit Analysis with Laplace Initial and Final Value Theorems Step-by-Step Problem Solving Guide Laplace Transform Fundamentals Definition The Laplace Transform converts time-domain functions f(t)f(t)f(t) into s-domain functions F(s)F(s)F(s):\nF(s)=L{f(t)}=∫0∞f(t)e−stdtF(s) = \\mathcal{L}\\{f(t)\\} = \\int_0^\\infty f(t)e^{-st} dtF(s)=L{f(t)}=∫0∞​f(t)e−stdtwhere s=σ+jωs = \\sigma + j\\omegas=σ+jω is a complex variable.\nWhy Use Laplace Transforms? Converts differential equations → algebraic equations Handles initial conditions automatically Simplifies circuit analysis dramatically Common Laplace Transform Pairs Time Domain f(t)f(t)f(t) S-Domain F(s)F(s)F(s) ROC (Region of Convergence) δ(t)\\delta(t)δ(t) (unit impulse) 111 All sss u(t)u(t)u(t) (unit step) 1s\\frac{1}{s}s1​ Re(s)\u003e0\\text{Re}(s) \u003e 0Re(s)\u003e0 ttt (unit ramp) 1s2\\frac{1}{s^2}s21​ Re(s)\u003e0\\text{Re}(s) \u003e 0Re(s)\u003e0 tnt^ntn n!sn+1\\frac{n!}{s^{n+1}}sn+1n!​ Re(s)\u003e0\\text{Re}(s) \u003e 0Re(s)\u003e0 eate^{at}eat 1s−a\\frac{1}{s-a}s−a1​ Re(s)\u003ea\\text{Re}(s) \u003e aRe(s)\u003ea teatte^{at}teat 1(s−a)2\\frac{1}{(s-a)^2}(s−a)21​ Re(s)\u003ea\\text{Re}(s) \u003e aRe(s)\u003ea cos⁡(ωt)\\cos(\\omega t)cos(ωt) ss2+ω2\\frac{s}{s^2+\\omega^2}s2+ω2s​ Re(s)\u003e0\\text{Re}(s) \u003e 0Re(s)\u003e0 sin⁡(ωt)\\sin(\\omega t)sin(ωt) ωs2+ω2\\frac{\\omega}{s^2+\\omega^2}s2+ω2ω​ Re(s)\u003e0\\text{Re}(s) \u003e 0Re(s)\u003e0 e−atcos⁡(ωt)e^{-at}\\cos(\\omega t)e−atcos(ωt) s+a(s+a)2+ω2\\frac{s+a}{(s+a)^2+\\omega^2}(s+a)2+ω2s+a​ Re(s)\u003e−a\\text{Re}(s) \u003e -aRe(s)\u003e−a e−atsin⁡(ωt)e^{-at}\\sin(\\omega t)e−atsin(ωt) ω(s+a)2+ω2\\frac{\\omega}{(s+a)^2+\\omega^2}(s+a)2+ω2ω​ Re(s)\u003e−a\\text{Re}(s) \u003e -aRe(s)\u003e−a Poles and Zeros Poles: Values of sss where F(s)→∞F(s) \\to \\inftyF(s)→∞ (denominator = 0) Zeros: Values of sss where F(s)=0F(s) = 0F(s)=0 (numerator = 0) Poles determine the nature of the time response (exponential decay, oscillation, etc.) Six Essential Properties 1. Linearity L{af(t)+bg(t)}=aF(s)+bG(s)\\mathcal{L}\\{af(t) + bg(t)\\} = aF(s) + bG(s)L{af(t)+bg(t)}=aF(s)+bG(s)Use this to: Break complex functions into simpler parts and transform each separately.\n2. Frequency Shift (Multiply by e−ate^{-at}e−at) L{e−atf(t)}=F(s+a)\\mathcal{L}\\{e^{-at}f(t)\\} = F(s+a)L{e−atf(t)}=F(s+a)Use this to: Handle exponential envelopes. Replace sss with s+as+as+a in F(s)F(s)F(s).\nExample: L{e−2tcos⁡(3t)}=s+2(s+2)2+9\\mathcal{L}\\{e^{-2t}\\cos(3t)\\} = \\frac{s+2}{(s+2)^2+9}L{e−2tcos(3t)}=(s+2)2+9s+2​3. Time Shift (Delay Property) L{f(t−T)u(t−T)}=e−sTF(s)\\mathcal{L}\\{f(t-T)u(t-T)\\} = e^{-sT}F(s)L{f(t−T)u(t−T)}=e−sTF(s)Use this to: Handle delayed signals. The term e−sTe^{-sT}e−sT indicates a delay of TTT seconds.\n4. Differentiation Property CRITICAL FOR CIRCUITS L{dfdt}=sF(s)−f(0−)\\mathcal{L}\\left\\{\\frac{df}{dt}\\right\\} = sF(s) - f(0^-)L{dtdf​}=sF(s)−f(0−)L{d2fdt2}=s2F(s)−sf(0−)−f′(0−)\\mathcal{L}\\left\\{\\frac{d^2f}{dt^2}\\right\\} = s^2F(s) - sf(0^-) - f'(0^-)L{dt2d2f​}=s2F(s)−sf(0−)−f′(0−)Use this to: Transform differential equations. Initial conditions appear as source terms!\n5. Integration Property L{∫0tf(τ)dτ}=1sF(s)\\mathcal{L}\\left\\{\\int_0^t f(\\tau)d\\tau\\right\\} = \\frac{1}{s}F(s)L{∫0t​f(τ)dτ}=s1​F(s)Use this to: Handle integrals in your equations (less common in basic circuit analysis).\n6. Multiply by ttt Property L{tf(t)}=−dF(s)ds\\mathcal{L}\\{tf(t)\\} = -\\frac{dF(s)}{ds}L{tf(t)}=−dsdF(s)​Use this to: Handle terms multiplied by ttt, or deal with multiple-order poles in inverse transforms.\nInverse Laplace Transform Goal Convert F(s)F(s)F(s) back to f(t)f(t)f(t) using Partial Fraction Expansion (PFE).\nTerminology PRF (Proper Rational Function): Order of numerator \u003c order of denominator IRF (Improper Rational Function): Order of numerator \\geq order of denominator General Form After PFE F(s)=k1s−p1+k2s−p2+⋯+kns−pnF(s) = \\frac{k_1}{s-p_1} + \\frac{k_2}{s-p_2} + \\cdots + \\frac{k_n}{s-p_n}F(s)=s−p1​k1​​+s−p2​k2​​+⋯+s−pn​kn​​where:\npip_ipi​ = pole locations (determine exponential rates) kik_iki​ = residues (determine weights/amplitudes) Case 1: Distinct Real Poles PFE Form: F(s)=k1s−p1+k2s−p2+⋯+kns−pnF(s) = \\frac{k_1}{s-p_1} + \\frac{k_2}{s-p_2} + \\cdots + \\frac{k_n}{s-p_n}F(s)=s−p1​k1​​+s−p2​k2​​+⋯+s−pn​kn​​Time Domain: f(t)=k1ep1tu(t)+k2ep2tu(t)+⋯+knepntu(t)f(t) = k_1e^{p_1t}u(t) + k_2e^{p_2t}u(t) + \\cdots + k_ne^{p_nt}u(t)f(t)=k1​ep1​tu(t)+k2​ep2​tu(t)+⋯+kn​epn​tu(t)Finding Residues: Cover-Up Method\nThe cover-up method is a quick technique for finding residues in partial fraction expansion.\nBasic Principle: To find residue kik_iki​ for pole at s=pis = p_is=pi​:\nki=(s−pi)F(s)∣s=pik_i = \\left.(s-p_i)F(s)\\right|_{s=p_i}ki​=(s−pi​)F(s)∣s=pi​​Step-by-Step Procedure:\nMultiply both sides of F(s)F(s)F(s) by the factor (s−pi)(s-p_i)(s−pi​) corresponding to the pole you’re solving for “Cover up” (mentally or physically) the factor (s−pi)(s-p_i)(s−pi​) in the original denominator Substitute s=pis = p_is=pi​ into what remains Evaluate the expression to get kik_iki​ Why It Works: Multiplying by (s−pi)(s-p_i)(s−pi​) cancels that factor in the denominator. When we set s=pis = p_is=pi​, all other fractions in the PFE become zero (they have (s−pi)(s-p_i)(s−pi​) in their numerators), leaving only kik_iki​.\nDetailed Example: F(s)=3s+5(s+1)(s+2)F(s) = \\frac{3s+5}{(s+1)(s+2)}F(s)=(s+1)(s+2)3s+5​Set up PFE: 3s+5(s+1)(s+2)=k1s+1+k2s+2\\frac{3s+5}{(s+1)(s+2)} = \\frac{k_1}{s+1} + \\frac{k_2}{s+2}(s+1)(s+2)3s+5​=s+1k1​​+s+2k2​​Find k1k_1k1​ (pole at s=−1s=-1s=−1):\nMultiply by (s+1)(s+1)(s+1): k1+k2(s+1)s+2=3s+5s+2k_1 + \\frac{k_2(s+1)}{s+2} = \\frac{3s+5}{s+2}k1​+s+2k2​(s+1)​=s+23s+5​ Set s=−1s = -1s=−1 (the second term vanishes): k1=3(−1)+5(−1)+2=21=2k_1 = \\frac{3(-1)+5}{(-1)+2} = \\frac{2}{1} = 2k1​=(−1)+23(−1)+5​=12​=2 Find k2k_2k2​ (pole at s=−2s=-2s=−2):\nMultiply by (s+2)(s+2)(s+2): k1(s+2)s+1+k2=3s+5s+1\\frac{k_1(s+2)}{s+1} + k_2 = \\frac{3s+5}{s+1}s+1k1​(s+2)​+k2​=s+13s+5​ Set s=−2s = -2s=−2 (the first term vanishes): k2=3(−2)+5(−2)+1=−1−1=1k_2 = \\frac{3(-2)+5}{(-2)+1} = \\frac{-1}{-1} = 1k2​=(−2)+13(−2)+5​=−1−1​=1 Result: f(t)=2e−tu(t)+e−2tu(t)f(t) = 2e^{-t}u(t) + e^{-2t}u(t)f(t)=2e−tu(t)+e−2tu(t)\nPractical Shortcut (the actual “cover-up”):\nFor F(s)=N(s)(s−p1)(s−p2)...(s−pn)F(s) = \\frac{N(s)}{(s-p_1)(s-p_2)...(s-p_n)}F(s)=(s−p1​)(s−p2​)...(s−pn​)N(s)​\nTo find kik_iki​:\nCover up (s−pi)(s-p_i)(s−pi​) in the denominator Replace all remaining sss with pip_ipi​ Calculate the result Visual Example: F(s)=10(s+2)(s+3)(s+5)F(s) = \\frac{10}{(s+2)(s+3)(s+5)}F(s)=(s+2)(s+3)(s+5)10​Find k2k_2k2​ at s=−3s = -3s=−3:\nCover up (s+3)(s+3)(s+3) in denominator: 10(s+2)(s+5)\\frac{10}{(s+2)(s+5)}(s+2)(s+5)10​ Substitute s=−3s = -3s=−3: 10(−3+2)(−3+5)=10(−1)(2)=−5\\frac{10}{(-3+2)(-3+5)} = \\frac{10}{(-1)(2)} = -5(−3+2)(−3+5)10​=(−1)(2)10​=−5 Three-Pole Example: F(s)=s+7(s+1)(s+2)(s+4)F(s) = \\frac{s+7}{(s+1)(s+2)(s+4)}F(s)=(s+1)(s+2)(s+4)s+7​Find all residues:\nk1k_1k1​ at s=−1s=-1s=−1: k1=(−1)+7(−1+2)(−1+4)=6(1)(3)=2k_1 = \\frac{(-1)+7}{(-1+2)(-1+4)} = \\frac{6}{(1)(3)} = 2k1​=(−1+2)(−1+4)(−1)+7​=(1)(3)6​=2k2k_2k2​ at s=−2s=-2s=−2: k2=(−2)+7(−2+1)(−2+4)=5(−1)(2)=−52k_2 = \\frac{(-2)+7}{(-2+1)(-2+4)} = \\frac{5}{(-1)(2)} = -\\frac{5}{2}k2​=(−2+1)(−2+4)(−2)+7​=(−1)(2)5​=−25​k3k_3k3​ at s=−4s=-4s=−4: k3=(−4)+7(−4+1)(−4+2)=3(−3)(−2)=12k_3 = \\frac{(-4)+7}{(-4+1)(-4+2)} = \\frac{3}{(-3)(-2)} = \\frac{1}{2}k3​=(−4+1)(−4+2)(−4)+7​=(−3)(−2)3​=21​Answer: f(t)=[2e−t−52e−2t+12e−4t]u(t)f(t) = \\left[2e^{-t} - \\frac{5}{2}e^{-2t} + \\frac{1}{2}e^{-4t}\\right]u(t)f(t)=[2e−t−25​e−2t+21​e−4t]u(t)Important Notes:\nCover-up method only works for distinct (simple) poles For repeated poles, use the derivative method (see Case 3) For complex poles, you can use cover-up but will get complex residues (see Case 2) Always verify: multiply out your PFE to check it equals the original F(s)F(s)F(s) Case 2: Complex Conjugate Poles PFE Form (poles at s=−α±jβs = -\\alpha \\pm j\\betas=−α±jβ): F(s)=ks−(−α+jβ)+k∗s−(−α−jβ)F(s) = \\frac{k}{s-(-\\alpha+j\\beta)} + \\frac{k^*}{s-(-\\alpha-j\\beta)}F(s)=s−(−α+jβ)k​+s−(−α−jβ)k∗​where kkk and k∗k^*k∗ are complex conjugates.\nTime Domain: f(t)=2∣k∣e−αtcos⁡(βt+∠k)u(t)f(t) = 2|k|e^{-\\alpha t}\\cos(\\beta t + \\angle k)u(t)f(t)=2∣k∣e−αtcos(βt+∠k)u(t)Steps:\nFind residue kkk at one pole using cover-up method Express kkk in polar form: k=∣k∣ej∠kk = |k|e^{j\\angle k}k=∣k∣ej∠k Apply formula above Alternative Form (using real coefficients): f(t)=e−αt[Acos⁡(βt)+Bsin⁡(βt)]u(t)f(t) = e^{-\\alpha t}[A\\cos(\\beta t) + B\\sin(\\beta t)]u(t)f(t)=e−αt[Acos(βt)+Bsin(βt)]u(t)where:\nA=2Re{k}A = 2\\text{Re}\\{k\\}A=2Re{k} B=−2Im{k}B = -2\\text{Im}\\{k\\}B=−2Im{k} Case 3: Multiple-Order Poles PFE Form (pole at s=p1s=p_1s=p1​ with multiplicity mmm): F(s)=k1m(s−p1)m+k1(m−1)(s−p1)m−1+⋯+k11s−p1+(other poles)F(s) = \\frac{k_{1m}}{(s-p_1)^m} + \\frac{k_{1(m-1)}}{(s-p_1)^{m-1}} + \\cdots + \\frac{k_{11}}{s-p_1} + \\text{(other poles)}F(s)=(s−p1​)mk1m​​+(s−p1​)m−1k1(m−1)​​+⋯+s−p1​k11​​+(other poles)Time Domain: f(t)=[k1mtm−1(m−1)!+k1(m−1)tm−2(m−2)!+⋯+k11]ep1tu(t)+(other terms)f(t) = \\left[k_{1m}\\frac{t^{m-1}}{(m-1)!} + k_{1(m-1)}\\frac{t^{m-2}}{(m-2)!} + \\cdots + k_{11}\\right]e^{p_1t}u(t) + \\text{(other terms)}f(t)=[k1m​(m−1)!tm−1​+k1(m−1)​(m−2)!tm−2​+⋯+k11​]ep1​tu(t)+(other terms)Finding Residues - Method 1: Matching Coefficients\nFind highest-order residue k1mk_{1m}k1m​ using cover-up method Multiply both sides by (s−p1)m(s-p_1)^m(s−p1​)m Expand and match coefficients of powers of sss Finding Residues - Method 2: n-to-1-Order-Poles For highest order residue: k1m=(s−p1)mF(s)∣s=p1k_{1m} = \\left.(s-p_1)^m F(s)\\right|_{s=p_1}k1m​=(s−p1​)mF(s)∣s=p1​​For next lower order: k1(m−1)=dds[(s−p1)mF(s)]∣s=p1k_{1(m-1)} = \\left.\\frac{d}{ds}\\left[(s-p_1)^m F(s)\\right]\\right|_{s=p_1}k1(m−1)​=dsd​[(s−p1​)mF(s)]​s=p1​​And so on with higher derivatives.\nCase 4: Improper Rational Functions (IRF) If numerator order \\geq denominator order:\nPerform long division first Write as: F(s)=Q(s)+R(s)D(s)F(s) = Q(s) + \\frac{R(s)}{D(s)}F(s)=Q(s)+D(s)R(s)​ Apply PFE to the proper fraction R(s)D(s)\\frac{R(s)}{D(s)}D(s)R(s)​ Inverse transform polynomial terms: L−1{1}=δ(t)\\mathcal{L}^{-1}\\{1\\} = \\delta(t)L−1{1}=δ(t) (impulse) L−1{s}=δ′(t)\\mathcal{L}^{-1}\\{s\\} = \\delta'(t)L−1{s}=δ′(t) (derivative of impulse) Case 5: Delayed Functions (e−sTe^{-sT}e−sT terms) L−1{F(s)e−sT}=f(t−T)u(t−T)\\mathcal{L}^{-1}\\{F(s)e^{-sT}\\} = f(t-T)u(t-T)L−1{F(s)e−sT}=f(t−T)u(t−T)The function is delayed by TTT seconds and is zero for t\u003cTt \u003c Tt\u003cT.","circuit-analysis-with-laplace#Circuit Analysis with Laplace":"","common-laplace-transform-pairs#Common Laplace Transform Pairs":"","common-mistakes-to-avoid#Common Mistakes to Avoid":"Forgetting initial conditions when using differentiation property Not checking if FVT is applicable (poles in right half-plane) Missing the u(t)u(t)u(t) in time-domain answers Incorrect sign on initial condition voltage/current sources Not factoring denominator completely before PFE Using IVT on improper rational functions Forgetting to perform long division for IRFs before PFE Not checking your answer with IVT/FVT when possible This cheat sheet covers all major topics for Laplace transform analysis in linear circuits. Practice each problem type systematically, and always verify your answers when possible!","comprehensive-laplace-transform-cheat-sheet-for-linear-circuit-analysis#Comprehensive Laplace Transform Cheat Sheet for Linear Circuit Analysis":"","definition#Definition":"","final-value-theorem-fvt#Final Value Theorem (FVT)":"f(∞)=lim⁡s→0sF(s)f(\\infty) = \\lim_{s \\to 0} sF(s)f(∞)=s→0lim​sF(s)Requirements:\nAll poles of sF(s)sF(s)sF(s) must have Re(s)\u003c0\\text{Re}(s) \u003c 0Re(s)\u003c0 (lie in left half-plane) If poles on imaginary axis or right half-plane, FVT is NOT APPLICABLE Use: Quickly find steady-state value without doing full inverse transform.\nCommon Mistake: Applying FVT when poles are at s=0s=0s=0 or in right half-plane. Always check pole locations of sF(s)sF(s)sF(s) first!","general-form-after-pfe#General Form After PFE":"","goal#Goal":"","inductor-s-domain-model-detailed#Inductor S-Domain Model (Detailed)":"Circuit representation with initial condition:\nLi(0-) + sL ----[+|-]----[====]---- (voltage (impedance) source) Equation: VL(s)=sLI(s)−Li(0−)V_L(s) = sLI(s) - Li(0^-)VL​(s)=sLI(s)−Li(0−)","initial-and-final-value-theorems#Initial and Final Value Theorems":"","initial-value-theorem-ivt#Initial Value Theorem (IVT)":"f(0+)=lim⁡s→∞sF(s)f(0^+) = \\lim_{s \\to \\infty} sF(s)f(0+)=s→∞lim​sF(s)Requirements:\nF(s)F(s)F(s) must be a Proper Rational Function (PRF) If IRF, IVT gives ∞\\infty∞ (not useful) Use: Quickly find initial value without doing full inverse transform.","inverse-laplace-transform#Inverse Laplace Transform":"","inverse-transforms-by-pole-type#Inverse Transforms (By Pole Type)":"L−1{1s−p}=eptu(t)L−1{1(s−p)2}=teptu(t)L−1{ks+α−jβ+k∗s+α+jβ}=2∣k∣e−αtcos⁡(βt+∠k)u(t)\\begin{aligned} \\mathcal{L}^{-1}\\left\\{\\frac{1}{s-p}\\right\\} \u0026= e^{pt}u(t) \\\\ \\mathcal{L}^{-1}\\left\\{\\frac{1}{(s-p)^2}\\right\\} \u0026= te^{pt}u(t) \\\\ \\mathcal{L}^{-1}\\left\\{\\frac{k}{s+\\alpha-j\\beta} + \\frac{k^*}{s+\\alpha+j\\beta}\\right\\} \u0026= 2|k|e^{-\\alpha t}\\cos(\\beta t + \\angle k)u(t) \\end{aligned}L−1{s−p1​}L−1{(s−p)21​}L−1{s+α−jβk​+s+α+jβk∗​}​=eptu(t)=teptu(t)=2∣k∣e−αtcos(βt+∠k)u(t)​","kirchhoffs-laws-in-s-domain#Kirchhoff\u0026rsquo;s Laws in S-Domain":"KVL (Kirchhoff’s Voltage Law): ∑Vi(s)=0\\sum V_i(s) = 0∑Vi​(s)=0Sum of voltages around any closed loop equals zero (same as time domain, but with V(s)V(s)V(s)).\nKCL (Kirchhoff’s Current Law): ∑Ii(s)=0\\sum I_i(s) = 0∑Ii​(s)=0Sum of currents entering a node equals sum leaving (same as time domain, but with I(s)I(s)I(s)).","laplace-transform-fundamentals#Laplace Transform Fundamentals":"","poles-and-zeros#Poles and Zeros":"","problem-type-1-find-laplace-transform-of#Problem Type 1: Find Laplace Transform of ":"f(t)f(t)f(t) Steps:\nBreak down f(t)f(t)f(t) into simpler additive terms (use linearity) Identify if any special properties apply: Exponential envelope → frequency shift property Time delay → delay property Derivative → differentiation property Apply standard transforms from table Combine results Example: Find L{e−2tsin⁡(3t)+t2}\\mathcal{L}\\{e^{-2t}\\sin(3t) + t^2\\}L{e−2tsin(3t)+t2}\nSolution:\nTerm 1: L{e−2tsin⁡(3t)}\\mathcal{L}\\{e^{-2t}\\sin(3t)\\}L{e−2tsin(3t)} → Use frequency shift: replace sss with s+2s+2s+2 in L{sin⁡(3t)}\\mathcal{L}\\{\\sin(3t)\\}L{sin(3t)} L{sin⁡(3t)}=3s2+9\\mathcal{L}\\{\\sin(3t)\\} = \\frac{3}{s^2+9}L{sin(3t)}=s2+93​ L{e−2tsin⁡(3t)}=3(s+2)2+9\\mathcal{L}\\{e^{-2t}\\sin(3t)\\} = \\frac{3}{(s+2)^2+9}L{e−2tsin(3t)}=(s+2)2+93​ Term 2: L{t2}=2!s3=2s3\\mathcal{L}\\{t^2\\} = \\frac{2!}{s^3} = \\frac{2}{s^3}L{t2}=s32!​=s32​ Answer: F(s)=3(s+2)2+9+2s3F(s) = \\frac{3}{(s+2)^2+9} + \\frac{2}{s^3}F(s)=(s+2)2+93​+s32​","problem-type-2-find-inverse-laplace-transform-of#Problem Type 2: Find Inverse Laplace Transform of ":"F(s)F(s)F(s) Steps:\nCheck if PRF or IRF If IRF: Do long division first Factor denominator completely to find all poles Set up PFE based on pole types: Distinct real poles → simple fractions Complex conjugate poles → pair of conjugate fractions Multiple-order poles → multiple fractions with increasing powers Find residues using cover-up method (or other methods for multiple poles) Write time-domain expression using inverse transform formulas Include u(t)u(t)u(t) for causality Example: Find L−1{2s+10s2+3s+2}\\mathcal{L}^{-1}\\left\\{\\frac{2s+10}{s^2+3s+2}\\right\\}L−1{s2+3s+22s+10​}\nSolution:\nCheck: PRF (numerator order 1 \u003c denominator order 2) ✓\\checkmark✓ Factor: s2+3s+2=(s+1)(s+2)s^2+3s+2 = (s+1)(s+2)s2+3s+2=(s+1)(s+2) PFE: 2s+10(s+1)(s+2)=k1s+1+k2s+2\\frac{2s+10}{(s+1)(s+2)} = \\frac{k_1}{s+1} + \\frac{k_2}{s+2}(s+1)(s+2)2s+10​=s+1k1​​+s+2k2​​ Find residues: k1=2s+10s+2∣s=−1=2(−1)+10−1+2=81=8k_1 = \\left.\\frac{2s+10}{s+2}\\right|_{s=-1} = \\frac{2(-1)+10}{-1+2} = \\frac{8}{1} = 8k1​=s+22s+10​​s=−1​=−1+22(−1)+10​=18​=8 k2=2s+10s+1∣s=−2=2(−2)+10−2+1=6−1=−6k_2 = \\left.\\frac{2s+10}{s+1}\\right|_{s=-2} = \\frac{2(-2)+10}{-2+1} = \\frac{6}{-1} = -6k2​=s+12s+10​​s=−2​=−2+12(−2)+10​=−16​=−6 Answer: f(t)=8e−tu(t)−6e−2tu(t)f(t) = 8e^{-t}u(t) - 6e^{-2t}u(t)f(t)=8e−tu(t)−6e−2tu(t)","problem-type-3-solve-differential-equation-with-initial-conditions#Problem Type 3: Solve Differential Equation with Initial Conditions":"Steps:\nTake Laplace transform of entire equation (term by term) Apply differentiation property: L{f′}=sF(s)−f(0−)\\mathcal{L}\\{f'\\} = sF(s) - f(0^-)L{f′}=sF(s)−f(0−) Substitute known initial conditions Solve algebraically for F(s)F(s)F(s) Apply inverse transform (PFE + cover-up method) Example: Solve dydt+3y=e−t\\frac{dy}{dt} + 3y = e^{-t}dtdy​+3y=e−t with y(0−)=2y(0^-) = 2y(0−)=2\nSolution:\nTransform: L{y′}+3L{y}=L{e−t}\\mathcal{L}\\{y'\\} + 3\\mathcal{L}\\{y\\} = \\mathcal{L}\\{e^{-t}\\}L{y′}+3L{y}=L{e−t} Apply property: sY(s)−y(0−)+3Y(s)=1s+1sY(s) - y(0^-) + 3Y(s) = \\frac{1}{s+1}sY(s)−y(0−)+3Y(s)=s+11​ Substitute: sY(s)−2+3Y(s)=1s+1sY(s) - 2 + 3Y(s) = \\frac{1}{s+1}sY(s)−2+3Y(s)=s+11​ Solve: (s+3)Y(s)=1s+1+2(s+3)Y(s) = \\frac{1}{s+1} + 2(s+3)Y(s)=s+11​+2 Y(s)=1(s+1)(s+3)+2s+3Y(s) = \\frac{1}{(s+1)(s+3)} + \\frac{2}{s+3}Y(s)=(s+1)(s+3)1​+s+32​ Y(s)=1+2(s+1)(s+1)(s+3)=2s+3(s+1)(s+3)Y(s) = \\frac{1 + 2(s+1)}{(s+1)(s+3)} = \\frac{2s+3}{(s+1)(s+3)}Y(s)=(s+1)(s+3)1+2(s+1)​=(s+1)(s+3)2s+3​ PFE and inverse transform to get y(t)y(t)y(t)","problem-type-4-analyze-circuit-with-laplace#Problem Type 4: Analyze Circuit with Laplace":"Steps:\nDraw circuit for t\u003c0t \u003c 0t\u003c0: Find initial conditions iL(0−),vC(0−)i_L(0^-), v_C(0^-)iL​(0−),vC​(0−) Draw s-domain circuit for t≥0t \\geq 0t≥0: Replace RRR with RRR Replace LLL with sLsLsL and series voltage source Li(0−)Li(0^-)Li(0−) Replace CCC with 1sC\\frac{1}{sC}sC1​ and series voltage source v(0−)s\\frac{v(0^-)}{s}sv(0−)​ Transform sources to s-domain Apply circuit analysis (KVL, KCL, node/mesh analysis) in s-domain Solve for desired V(s)V(s)V(s) or I(s)I(s)I(s) Apply inverse transform to get time-domain response (Optional) Verify using initial/final value theorems Example: RL Circuit\nGiven: R=10ΩR = 10\\OmegaR=10Ω, L=1HL = 1HL=1H, iL(0−)=0.5Ai_L(0^-) = 0.5AiL​(0−)=0.5A, step input vs(t)=5u(t)Vv_s(t) = 5u(t)Vvs​(t)=5u(t)V\nFind: iL(t)i_L(t)iL​(t) for t≥0t \\geq 0t≥0\nSolution:\nInitial condition: iL(0−)=0.5Ai_L(0^-) = 0.5AiL​(0−)=0.5A S-domain circuit: Voltage source: Vs(s)=5sV_s(s) = \\frac{5}{s}Vs​(s)=s5​ Series elements: Li(0−)=1(0.5)=0.5VLi(0^-) = 1(0.5) = 0.5VLi(0−)=1(0.5)=0.5V, sL=ssL = ssL=s, R=10R = 10R=10 KVL: 5s=0.5+sIL(s)+10IL(s)\\frac{5}{s} = 0.5 + sI_L(s) + 10I_L(s)s5​=0.5+sIL​(s)+10IL​(s) Solve: 5s−0.5=(s+10)IL(s)\\frac{5}{s} - 0.5 = (s+10)I_L(s)s5​−0.5=(s+10)IL​(s) IL(s)=5−0.5ss(s+10)=5−0.5ss(s+10)I_L(s) = \\frac{5-0.5s}{s(s+10)} = \\frac{5-0.5s}{s(s+10)}IL​(s)=s(s+10)5−0.5s​=s(s+10)5−0.5s​ Apply PFE and inverse transform","problem-type-5-apply-initialfinal-value-theorems#Problem Type 5: Apply Initial/Final Value Theorems":"Steps:\nForm sF(s)sF(s)sF(s) For IVT: Check if PRF Calculate lim⁡s→∞sF(s)\\lim_{s \\to \\infty} sF(s)lims→∞​sF(s) For FVT: Check poles of sF(s)sF(s)sF(s) (must all be in left half-plane) If valid, calculate lim⁡s→0sF(s)\\lim_{s \\to 0} sF(s)lims→0​sF(s) (Optional) Verify by finding f(t)f(t)f(t) and evaluating at t=0+t=0^+t=0+ or t=∞t=\\inftyt=∞","properties-most-used#Properties (Most Used)":"L{af+bg}=aF+bGL{eatf(t)}=F(s−a)L{f′}=sF(s)−f(0−)L{f(t−T)u(t−T)}=e−sTF(s)\\begin{aligned} \\mathcal{L}\\{af + bg\\} \u0026= aF + bG \\\\ \\mathcal{L}\\{e^{at}f(t)\\} \u0026= F(s-a) \\\\ \\mathcal{L}\\{f'\\} \u0026= sF(s) - f(0^-) \\\\ \\mathcal{L}\\{f(t-T)u(t-T)\\} \u0026= e^{-sT}F(s) \\end{aligned}L{af+bg}L{eatf(t)}L{f′}L{f(t−T)u(t−T)}​=aF+bG=F(s−a)=sF(s)−f(0−)=e−sTF(s)​","quick-reference-formulas#Quick Reference Formulas":"","s-domain-component-models#S-Domain Component Models":"Component Time Domain S-Domain Impedance Initial Condition Handling Resistor v(t)=Ri(t)v(t) = Ri(t)v(t)=Ri(t) ZR=RZ_R = RZR​=R None Inductor v(t)=Ldidtv(t) = L\\frac{di}{dt}v(t)=Ldtdi​ ZL=sLZ_L = sLZL​=sL Voltage source Li(0−)Li(0^-)Li(0−) in series Capacitor i(t)=Cdvdti(t) = C\\frac{dv}{dt}i(t)=Cdtdv​ ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​ Voltage source v(0−)s\\frac{v(0^-)}{s}sv(0−)​ in series OR current source Cv(0−)Cv(0^-)Cv(0−) in parallel","six-essential-properties#Six Essential Properties":"","step-by-step-problem-solving-guide#Step-by-Step Problem Solving Guide":"","table-of-contents#Table of Contents":"","terminology#Terminology":"","transform-pairs-most-common#Transform Pairs (Most Common)":"L{u(t)}=1sL{eat}=1s−aL{sin⁡(ωt)}=ωs2+ω2L{cos⁡(ωt)}=ss2+ω2L{tn}=n!sn+1\\begin{aligned} \\mathcal{L}\\{u(t)\\} \u0026= \\frac{1}{s} \\\\ \\mathcal{L}\\{e^{at}\\} \u0026= \\frac{1}{s-a} \\\\ \\mathcal{L}\\{\\sin(\\omega t)\\} \u0026= \\frac{\\omega}{s^2+\\omega^2} \\\\ \\mathcal{L}\\{\\cos(\\omega t)\\} \u0026= \\frac{s}{s^2+\\omega^2} \\\\ \\mathcal{L}\\{t^n\\} \u0026= \\frac{n!}{s^{n+1}} \\end{aligned}L{u(t)}L{eat}L{sin(ωt)}L{cos(ωt)}L{tn}​=s1​=s−a1​=s2+ω2ω​=s2+ω2s​=sn+1n!​​","value-theorems#Value Theorems":"f(0+)=lim⁡s→∞sF(s)(PRF only)f(∞)=lim⁡s→0sF(s)(stable systems only)\\begin{aligned} f(0^+) \u0026= \\lim_{s \\to \\infty} sF(s) \\quad \\text{(PRF only)} \\\\ f(\\infty) \u0026= \\lim_{s \\to 0} sF(s) \\quad \\text{(stable systems only)} \\end{aligned}f(0+)f(∞)​=s→∞lim​sF(s)(PRF only)=s→0lim​sF(s)(stable systems only)​","why-use-laplace-transforms#Why Use Laplace Transforms?":"","zero-input-response-zir-and-zero-state-response-zsr#Zero-Input Response (ZIR) and Zero-State Response (ZSR)":"Total Response: y(t)=yZIR(t)+yZSR(t)y(t) = y_{ZIR}(t) + y_{ZSR}(t)y(t)=yZIR​(t)+yZSR​(t) ZIR: Response due to initial conditions only (no external input) ZSR: Response due to external input only (zero initial conditions)"},"title":"exam_1_cheatsheet_pandoc"},"/electrical_notes/ee_300/exam_1_roadmap_chat/":{"data":{"":"","common-lt-transforms#Common LT Transforms":"L{1}=1s,s\u003e0L{eat}=1s−a,s\u003eaL{cos⁡(ωt)}=ss2+ω2L{sin⁡(ωt)}=ωs2+ω2L{tn}=n!sn+1,n=0,1,2,... \\begin{aligned} \\mathcal{L}\\{1\\} \u0026= \\frac{1}{s}, \u0026 s\u003e0 \\\\ \\mathcal{L}\\{e^{at}\\} \u0026= \\frac{1}{s-a}, \u0026 s\u003ea \\\\ \\mathcal{L}\\{\\cos(\\omega t)\\} \u0026= \\frac{s}{s^2+\\omega^2} \\\\ \\mathcal{L}\\{\\sin(\\omega t)\\} \u0026= \\frac{\\omega}{s^2+\\omega^2} \\\\ \\mathcal{L}\\{t^n\\} \u0026= \\frac{n!}{s^{n+1}}, \u0026 n = 0,1,2,... \\end{aligned} L{1}L{eat}L{cos(ωt)}L{sin(ωt)}L{tn}​=s1​,=s−a1​,=s2+ω2s​=s2+ω2ω​=sn+1n!​,​s\u003e0s\u003ean=0,1,2,...​","differential-equation--s-domain-example#Differential Equation → S-Domain Example":"Ldidt+Ri=v(t) L \\frac{di}{dt} + Ri = v(t) Ldtdi​+Ri=v(t)(sL+R)I(s)−Li(0−)=V(s) (sL+R) I(s) - L i(0^-) = V(s) (sL+R)I(s)−Li(0−)=V(s) Solve for I(s)I(s)I(s), then apply ILT","formulas#Formulas":"Initial Value Theorem (IVT): f(0+)=lim⁡s→∞sF(s),F(s) PRF only f(0^+) = \\lim_{s\\to\\infty} s F(s), \\quad F(s) \\text{ PRF only} f(0+)=s→∞lim​sF(s),F(s) PRF only Final Value Theorem (FVT): f(∞)=lim⁡s→0sF(s),if all poles of sF(s) lie in ℜ(s)\u003c0 f(\\infty) = \\lim_{s\\to 0} s F(s), \\quad \\text{if all poles of } sF(s) \\text{ lie in } \\Re(s)\u003c0 f(∞)=s→0lim​sF(s),if all poles of sF(s) lie in ℜ(s)\u003c0","i-laplace-transform-lt-fundamentals-and-properties#I. Laplace Transform (LT) Fundamentals and Properties":"","ii-inverse-laplace-transform-ilt#II. Inverse Laplace Transform (ILT)":"","iii-laplace-transform-for-differential-equations--circuit-analysis#III. Laplace Transform for Differential Equations \u0026amp; Circuit Analysis":"","iv-initial-and-final-value-properties-ivpfvp#IV. Initial and Final Value Properties (IVP/FVP)":"","s-domain-models#S-Domain Models":"ZR=RZL=sL,with i(0−)→voltage source Li(0−) in seriesZC=1sC,v(0−)→current source Cv(0−)s or v(0−)/s \\begin{aligned} Z_R \u0026= R \\\\ Z_L \u0026= sL, \u0026 \\text{with } i(0^-) \\to \\text{voltage source } L i(0^-) \\text{ in series} \\\\ Z_C \u0026= \\frac{1}{sC}, \u0026 v(0^-) \\to \\text{current source } Cv(0^-)s \\text{ or } v(0^-)/s \\end{aligned} ZR​ZL​ZC​​=R=sL,=sC1​,​with i(0−)→voltage source Li(0−) in seriesv(0−)→current source Cv(0−)s or v(0−)/s​","six-key-properties#Six Key Properties":"Linearity: L{af(t)+bg(t)}=aF(s)+bG(s)\\mathcal{L}\\{af(t)+bg(t)\\} = aF(s)+bG(s)L{af(t)+bg(t)}=aF(s)+bG(s) Frequency shift: L{eatf(t)}=F(s−a)\\mathcal{L}\\{e^{at}f(t)\\} = F(s-a)L{eatf(t)}=F(s−a) Time shift (delay by T): L{f(t−T)u(t−T)}=e−sTF(s)\\mathcal{L}\\{f(t-T)u(t-T)\\} = e^{-sT}F(s)L{f(t−T)u(t−T)}=e−sTF(s) Differentiation: L{f′(t)}=sF(s)−f(0−)\\mathcal{L}\\{f'(t)\\} = sF(s)-f(0^-)L{f′(t)}=sF(s)−f(0−) L{f(n)(t)}=snF(s)−sn−1f(0−)−...−f(n−1)(0−)\\mathcal{L}\\{f^{(n)}(t)\\} = s^n F(s)-s^{n-1}f(0^-)-...-f^{(n-1)}(0^-)L{f(n)(t)}=snF(s)−sn−1f(0−)−...−f(n−1)(0−) Integration: L{∫0tf(τ)dτ}=1sF(s)\\mathcal{L}\\{\\int_0^t f(\\tau)d\\tau\\} = \\frac{1}{s} F(s)L{∫0t​f(τ)dτ}=s1​F(s) Multiply by t: L{tf(t)}=−dF(s)ds\\mathcal{L}\\{t f(t)\\} = -\\frac{dF(s)}{ds}L{tf(t)}=−dsdF(s)​","step-by-step-methodology#Step-by-Step Methodology":"Break function into additive terms (linearity). Apply known transforms or LT properties. Handle exponentials, derivatives, or delays explicitly. Express final result as F(s)F(s)F(s).","step-by-step-methodology-1#Step-by-Step Methodology":"Handle IRF via long division: F(s)=Q(s)+R(s)/D(s)F(s) = Q(s) + R(s)/D(s)F(s)=Q(s)+R(s)/D(s)\nFactor denominator, identify all poles\nCalculate residues kik_iki​\nApply ILT:\nDistinct real poles: f(t)=∑kiepitu(t)f(t)=\\sum k_i e^{p_i t}u(t)f(t)=∑ki​epi​tu(t) Complex poles: f(t)=2∣k∣eαtcos⁡(βt+∠k)u(t)f(t)=2|k| e^{\\alpha t} \\cos(\\beta t+\\angle k) u(t)f(t)=2∣k∣eαtcos(βt+∠k)u(t) Repeated poles: f(t)=tm−1(m−1)!eptu(t)f(t)=\\frac{t^{m-1}}{(m-1)!} e^{pt} u(t)f(t)=(m−1)!tm−1​eptu(t) Include delay terms: f(t−T)u(t−T)f(t-T) u(t-T)f(t−T)u(t−T)","step-by-step-methodology-2#Step-by-Step Methodology":"Derive differential equation, note t\u003c0 response (initial voltage/current). Transform equation or circuit to s-domain. Apply initial conditions. Solve algebraic equation in s-domain. Apply PFE + ILT to get time-domain response. Combine ZIR + ZSR for full solution.","step-by-step-methodology-3#Step-by-Step Methodology":"Form sF(s)sF(s)sF(s) Apply IVT: lim⁡s→∞sF(s)\\lim_{s\\to\\infty} sF(s)lims→∞​sF(s) Check poles of sF(s)sF(s)sF(s) for FVT applicability Apply FVT: lim⁡s→0sF(s)\\lim_{s\\to 0} sF(s)lims→0​sF(s) if valid flowchart TD A[\"Time-Domain Function f(t)\"] --\u003e B[\"Laplace Transform F(s)\"] B --\u003e C[\"S-Domain Circuit or Differential Equation\"] C --\u003e D[\"Apply Initial Conditions\"] D --\u003e E[\"Solve Algebraic Equation for Output V(s) / I(s)\"] E --\u003e F[\"Partial Fraction Expansion / Simplify F(s)\"] F --\u003e G[\"Inverse Laplace Transform f(t)\"] G --\u003e H{\"Response Type\"} H --\u003e H1[\"Zero-State Response (ZSR)\"] H --\u003e H2[\"Zero-Input Response (ZIR)\"] H1 --\u003e I[\"Combine ZIR + ZSR\"] H2 --\u003e I I --\u003e J[\"Final Time-Domain Solution f(t)\"] J --\u003e K{\"Initial / Final Values?\"} K --\u003e L[\"Initial Value: f(0+) = lim(s-\u003e∞) sF(s)\"] K --\u003e M[\"Final Value: f(∞) = lim(s-\u003e0) sF(s)\"]","subtopics-to-familiarize#Subtopics to Familiarize":"Definition: F(s)=L{f(t)}=∫0∞f(t)e−stdt F(s) = \\mathcal{L}\\{f(t)\\} = \\int_0^\\infty f(t)e^{-st} dt F(s)=L{f(t)}=∫0∞​f(t)e−stdt Poles \u0026 zeros, s-plane concepts Relationship to Fourier transform (transient vs. steady-state) Six key properties (linearity, time/frequency shifts, differentiation, integration, multiply-by-t)","subtopics-to-familiarize-1#Subtopics to Familiarize":"PRF vs IRF (proper vs improper) Partial fraction expansion (PFE) Poles \u0026 residues Cover-up method for distinct real poles Complex conjugate poles → sinusoidal response Multiple-order poles → t^n * e^{pt} terms Delay property: L−1{F(s)e−sT}=f(t−T)u(t−T)\\mathcal{L}^{-1}\\{F(s)e^{-sT}\\} = f(t-T)u(t-T)L−1{F(s)e−sT}=f(t−T)u(t−T)","use-in-the-course#Use in the Course":"Converts differential equations (time-domain) into algebraic equations (s-domain). Simplifies circuit and system analysis.","use-in-the-course-1#Use in the Course":"Converts sss-domain solutions back to time-domain. Uses Partial Fraction Expansion (PFE) for rational functions.","use-in-the-course-2#Use in the Course":"Transform circuit differential equations into algebraic equations Includes initial conditions via s-domain equivalents","use-in-the-course-3#Use in the Course":"Quickly compute starting and steady-state values without full ILT","zero-input-and-zero-state-response#Zero-Input and Zero-State Response":"y(t)=yZIR(t)+yZSR(t) y(t) = y_{ZIR}(t) + y_{ZSR}(t) y(t)=yZIR​(t)+yZSR​(t) ZIR: Response due to initial energy (no external input) ZSR: Response due to external input (zero initial conditions)"},"title":"Comprehensive Circuit Analysis with Laplace Transform Roadmap (With Equations)"},"/electrical_notes/ee_300/exam_1_roadmap_notebooklm/":{"data":{"":"","example-problems-to-look-at#Example Problems to Look At":"Calculating F(s)=L{f(t)} F(s) = \\mathcal{L}\\{f(t)\\} F(s)=L{f(t)} for various basic time-domain functions such as exponential/decaying waveforms, unit ramp, and short-duration pulses. Using the linearity property to find the LT of a sum of exponentials. Applying the differentiation property to find the LT of derivatives, often using the initial condition f(0) f(0) f(0). Using the delay property to find the LT of time-delayed signals, which results in terms involving e−sT e^{-sT} e−sT.","example-problems-to-look-at-1#Example Problems to Look At":"Inverse transforming a Proper Rational Function (PRF) (where the numerator order is less than the denominator order) with distinct real poles to obtain a sum of exponentials using the cover-up method. Inverse transforming F(s) F(s) F(s) with complex-conjugate poles, which results in sinusoidal responses, potentially with an exponential envelope. Inverse transforming F(s) F(s) F(s) with multiple-order poles (higher than 1st order) Handling Improper Rational Functions (IRF) (numerator order ≥ \\ge ≥ denominator order) using long division. Inverse transforming terms involving e−sT e^{-sT} e−sT to find delayed time-domain functions f(t−T)u(t−T) f(t-T)u(t-T) f(t−T)u(t−T)","example-problems-to-look-at-2#Example Problems to Look At":"Solving RL Circuits or RC circuits subjected to sudden changes (switches closing) with step or exponential inputs Analyzing circuits using KCL (Kirchhoff’s Current Law) or node methods in the s s s-domain, accounting for initial conditions Determining Zero-Input Response (ZIR) and Zero-State Response (ZSR)","example-problems-to-look-at-3#Example Problems to Look At":"Calculating f(0) f(0) f(0) and f(∞) f(\\infty) f(∞) for standard PRFs Identifying functions where FVP is not applicable Identifying functions where IVP is not applicable (Improper Rational Functions)","high-level-topics-for-test-preparation#High-Level Topics for Test Preparation":"The topics you need to understand revolve around the core processes of applying the Laplace Transform (LT) to solve differential equations and analyze circuits: Transformation L \\mathcal{L} L, Property Application, Inverse Transformation L−1 \\mathcal{L}^{-1} L−1, and Specialized Analysis (Circuits and Value Properties).","i-laplace-transform-lt-fundamentals-and-properties#I. Laplace Transform (LT) Fundamentals and Properties":"","ii-inverse-laplace-transform-inverse-lt#II. Inverse Laplace Transform (Inverse LT)":"","iii-laplace-transform-for-differential-equations-and-circuit-analysis#III. Laplace Transform for Differential Equations and Circuit Analysis":"","iv-initial-and-final-value-properties-ivpfvp#IV. Initial and Final Value Properties (IVP/FVP)":"","step-by-step-methodology-applying-ivp-and-fvp#Step-by-Step Methodology: Applying IVP and FVP":"Formulate sF(s) sF(s) sF(s) Calculate Initial Value: lim⁡s→∞sF(s) \\lim_{s \\to \\infty} sF(s) lims→∞​sF(s) Check FVP Applicability: Examine poles of sF(s) sF(s) sF(s) Calculate Final Value (If Applicable): lim⁡s→0sF(s) \\lim_{s \\to 0} sF(s) lims→0​sF(s)","step-by-step-methodology-applying-lt-general#Step-by-Step Methodology: Applying LT (General)":"Break Down the Function: If the time-domain function f(t) f(t) f(t) is a sum of terms, use the Linearity Property to transform each term independently. Apply Standard Transforms/Properties: Transform basic functions using known inventory transforms, or apply specific properties: If f(t) f(t) f(t) is multiplied by e−αt e^{-\\alpha t} e−αt, replace s s s with s+α s+\\alpha s+α in F(s) F(s) F(s) (Multiply by e−at e^{-at} e−at property) If f(t) f(t) f(t) is delayed by T T T, multiply F(s) F(s) F(s) by e−sT e^{-sT} e−sT (Delay property) If you are transforming a differential equation, use the Differentiation Property: L{df/dt}=sF(s)−f(0) \\mathcal{L}\\{ df/dt \\} = s F(s) - f(0) L{df/dt}=sF(s)−f(0)","step-by-step-methodology-inverse-lt-using-pfe#Step-by-Step Methodology: Inverse LT using PFE":"Handle Improper Functions (If Applicable): If F(s) F(s) F(s) is an IRF, perform long division to rewrite F(s) F(s) F(s) as a polynomial plus a PRF Factor and Set Up PFE: Factor the denominator of the PRF to find all poles pi p_i pi​. Write the resulting PRF in its PFE form, including terms for complex and multiple-order poles Calculate Residues ki k_i ki​: Distinct Real Poles: Use the cover-up method Complex Conjugate Poles: Use cover-up method for one pole; derive inverse LT using magnitude ∣k∣ |k| ∣k∣ and angle ∠k \\angle k ∠k Multiple-Order Poles: Use matching coefficients to find lower-order residues Inverse Transform: Convert each PFE term back into the time domain f(t) f(t) f(t) Handle Delayed Signals: If F(s) F(s) F(s) contains terms multiplied by e−sT e^{-sT} e−sT, apply the delay property: L−1{F(s)e−sT}=f(t−T)u(t−T) \\mathcal{L}^{-1}\\{ F(s)e^{-sT} \\} = f(t-T)u(t-T) L−1{F(s)e−sT}=f(t−T)u(t−T)","step-by-step-methodology-solving-circuits-using-lt#Step-by-Step Methodology: Solving Circuits using LT":"Derive Differential Equation and Find t\u003c0 t\u003c0 t\u003c0 Response Transform to S-Domain Apply Initial Conditions Solve for Output in S-Domain Inverse Transform Complete Solution (combine t\u003c0 t\u003c0 t\u003c0 and t≥0 t\\ge 0 t≥0 waveforms)","subtopics-to-familiarize-yourself-with#Subtopics to Familiarize Yourself With":"Definitions: F(s)=L{f(t)} F(s) = \\mathcal{L}\\{f(t)\\} F(s)=L{f(t)} S-Plane Concepts: Understanding poles and zeros, and their graphical representation in the pole-zero diagram. Relationship to Fourier Transform: LT is more suitable for analyzing dynamic systems with transient behavior, while Fourier is suited for stationary signals. The Six Key Properties: Linearity (scaling and addition) Multiply by e−at e^{-at} e−at (frequency domain translation) Delay Property (time domain translation) Differentiation Property (introduces sF(s) sF(s) sF(s) and initial conditions) Integration Property Multiply-by-t t t Property","subtopics-to-familiarize-yourself-with-1#Subtopics to Familiarize Yourself With":"PRF vs. IRF: Understanding the difference based on the order of the numerator and denominator polynomials PFE: How to express F(s) F(s) F(s) as a sum of simpler terms Poles and Residues: Recognizing that pole locations pi p_i pi​ determine the rate of the exponential, and residues ki k_i ki​ determine the weight/amplitude Cover-up Method: The standard technique for finding residues ki k_i ki​ for distinct real poles Special Cases: Dealing with complex-conjugate poles (resulting in 2∣k∣cos⁡(βt+∠k) 2|k|\\cos(\\beta t + \\angle k) 2∣k∣cos(βt+∠k)), and methods for multiple-order poles (matching coefficients, n n n-to-1-order poles)","subtopics-to-familiarize-yourself-with-2#Subtopics to Familiarize Yourself With":"S-Domain Device Models: Transforming resistors (R R R), capacitors (1/sC 1/sC 1/sC), and inductors (sL sL sL) into s-domain impedances Initial Condition Sources: Capacitor initial voltage Vc(0) V_c(0) Vc​(0) as Vc(0)/s V_c(0)/s Vc​(0)/s in series with 1/sC 1/sC 1/sC ZIR/ZSR: Total response is the sum of ZIR (initial condition driven) and ZSR (input driven)","subtopics-to-familiarize-yourself-with-3#Subtopics to Familiarize Yourself With":"IVP Formula: f(0)=lim⁡s→∞sF(s) f(0) = \\lim_{s \\to \\infty} sF(s) f(0)=lims→∞​sF(s) FVP Formula: f(∞)=lim⁡s→0sF(s) f(\\infty) = \\lim_{s \\to 0} sF(s) f(∞)=lims→0​sF(s) Conditions: IVP requires PRF; FVP requires no poles on right-half s-plane","use-in-the-course#Use in the Course":"The Laplace Transform is a powerful tool used in Electrical Engineering that converts equations from the “time domain” into the equivalent equation in the Complex S-Domain (or phase-domain). This conversion is critical because it changes differential equations (which are generally hard to solve) into linear equations or partial fraction expressions, simplifying the analysis of complex circuit networks. Understanding LT properties is essential for efficient circuit analysis and design.","use-in-the-course-1#Use in the Course":"The Inverse Laplace Transform L−1 \\mathcal{L}^{-1} L−1 is the necessary final step for obtaining the time-domain waveform, f(t) f(t) f(t), after solving the equation in the s s s-domain. The process uses the concept of Partial Fraction Expansion (PFE), which is typically applied to rational functions.","use-in-the-course-2#Use in the Course":"LT is applied to solve circuits modeled by differential equations, converting these equations into linear equations in the s s s-domain that are easier to solve. This method integrates initial conditions directly into the s s s-domain circuit model using s-domain device characteristics.","use-in-the-course-3#Use in the Course":"IVP and FVP allow you to find the initial value f(0) f(0) f(0) and final value f(∞) f(\\infty) f(∞) directly from F(s) F(s) F(s), without full inverse transformation."},"title":"Laplace Transform Roadmap NotebookLM"},"/electrical_notes/ee_300/poles_zeros_cheatsheet/":{"data":{"1-circuit-response-components#1. Circuit Response Components":"","10-quick-problem-solving-guide#10. Quick Problem-Solving Guide":"","11-critical-reminders#11. Critical Reminders":"","12-analysis-flowchart-summary#12. Analysis Flowchart Summary":"","13-example-rc-low-pass-filter#13. Example: RC Low-Pass Filter":"","14-stability-summary#14. Stability Summary":"Pole Location Stability Time Response Left half-plane (Re(s)\u003c0(s) \u003c 0(s)\u003c0) Stable Decaying Right half-plane (Re(s)\u003e0(s) \u003e 0(s)\u003e0) Unstable Growing Imaginary axis (Re(s)=0(s) = 0(s)=0) Marginally stable Sustained System is stable if and only if ALL poles are in the left half-plane.","2-transform-to-s-domain#2. Transform to s-Domain":"","3-network-functions-transfer-functions#3. Network Functions (Transfer Functions)":"","4-poles-and-zeros#4. Poles and Zeros":"","5-pole-types-and-time-response#5. Pole Types and Time Response":"","6-natural-vs-forced-response#6. Natural vs Forced Response":"","7-time-response-via-inverse-laplace-transform#7. Time Response via Inverse Laplace Transform":"","8-common-laplace-transform-pairs#8. Common Laplace Transform Pairs":"","9-differential-equations#9. Differential Equations":"","always-remember#Always Remember":"","common-mistakes#Common Mistakes":"","complete-process---6-steps#Complete Process - 6 Steps":"","complex-conjugate-poles#Complex Conjugate Poles":"","definition#Definition":"","definitions#Definitions":"","differential-equation#Differential Equation":"","discriminant-for-2nd-order#Discriminant for 2nd Order":"","element-impedances#Element Impedances":"","example#Example":"","find-hs#Find H(s)":"","finding-hs-from-circuit---6-steps#Finding H(s) from Circuit - 6 Steps":"","finding-poles-and-zeros---3-steps#Finding Poles and Zeros - 3 Steps":"","forced-response#Forced Response":"","from-hs-to-ode---4-steps#From H(s) to ODE - 4 Steps":"","from-output-expression#From Output Expression":"","given-circuit--find-hs#Given Circuit → Find H(s)":"","given-circuit--input--find-time-response#Given Circuit + Input → Find Time Response":"","given-hs--find-differential-equation#Given H(s) → Find Differential Equation":"","given-hs--find-poleszeros#Given H(s) → Find Poles/Zeros":"","initial-condition-sources#Initial Condition Sources":"","key-insight#Key Insight":"","natural-response#Natural Response":"","poles--zeros-cheat-sheet#Poles \u0026amp; Zeros Cheat Sheet":"","poles-and-zeros#Poles and Zeros":"","rational-function-form#Rational Function Form":"","solving-polynomials#Solving Polynomials":"","special-case-resonance#Special Case: Resonance":"","specific-pole-locations#Specific Pole Locations":"","time-response-to-step-input-#Time Response to Step Input ()":"Poles \u0026 Zeros Cheat Sheet Poles of circuit are rates of exponentials that are “always” in the output Poles determined by output side of differential equation Zeros of circuit are rates of exponentials that are “never” in the output Zeros determined by input side of differential equation 1. Circuit Response Components Total Response Total Response=ZIR+ZSR\\text{Total Response} = \\text{ZIR} + \\text{ZSR}Total Response=ZIR+ZSRZero-Input Response (ZIR) Response due to initial conditions only (stored energy) No external sources applied Composed entirely of natural response Zero-State Response (ZSR) Response due to external inputs only All initial conditions = 0 Composed of natural response + forced response 2. Transform to s-Domain Element Impedances Element Time Domain s-Domain Impedance Resistor RRR ZR=RZ_R = RZR​=R Capacitor CCC ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​ Inductor LLL ZL=sLZ_L = sLZL​=sL Initial Condition Sources Capacitor: Voltage source Vc(0)s\\frac{V_c(0)}{s}sVc​(0)​ in series with 1sC\\frac{1}{sC}sC1​ Inductor: Current source IL(0)s\\frac{I_L(0)}{s}sIL​(0)​ in parallel with sLsLsL For Network Functions: Set all initial conditions to ZERO\n3. Network Functions (Transfer Functions) Definition H(s)=Output(s)Input(s)[with all ICs = 0]H(s) = \\frac{\\text{Output}(s)}{\\text{Input}(s)} \\quad \\text{[with all ICs = 0]}H(s)=Input(s)Output(s)​[with all ICs = 0]Types Transfer Function: H(s)=Vout(s)Vin(s)H(s) = \\frac{V_{out}(s)}{V_{in}(s)}H(s)=Vin​(s)Vout​(s)​ (different ports) Driving-Point Impedance: Z(s)=V(s)I(s)Z(s) = \\frac{V(s)}{I(s)}Z(s)=I(s)V(s)​ (same port) Driving-Point Admittance: Y(s)=I(s)V(s)=1Z(s)Y(s) = \\frac{I(s)}{V(s)} = \\frac{1}{Z(s)}Y(s)=V(s)I(s)​=Z(s)1​ (same port) Finding H(s) from Circuit - 6 Steps Transform all elements to s-domain (RRR, 1sC\\frac{1}{sC}sC1​, sLsLsL) Zero all initial conditions (voltage sources → short, current sources → open) Define input and output variables Apply circuit analysis (voltage/current divider, nodal, mesh, KCL/KVL) Form H(s)=Output(s)Input(s)H(s) = \\frac{\\text{Output}(s)}{\\text{Input}(s)}H(s)=Input(s)Output(s)​ Simplify to rational function: H(s)=N(s)D(s)H(s) = \\frac{N(s)}{D(s)}H(s)=D(s)N(s)​ 4. Poles and Zeros Rational Function Form H(s)=N(s)D(s)=amsm+am−1sm−1+⋯+a0bnsn+bn−1sn−1+⋯+b0H(s) = \\frac{N(s)}{D(s)} = \\frac{a_m s^m + a_{m-1}s^{m-1} + \\cdots + a_0}{b_n s^n + b_{n-1}s^{n-1} + \\cdots + b_0}H(s)=D(s)N(s)​=bn​sn+bn−1​sn−1+⋯+b0​am​sm+am−1​sm−1+⋯+a0​​Definitions ZEROS: Roots of numerator N(s)=0 ⟹ Zeros: s=z1,z2,…,zmN(s) = 0 \\implies \\text{Zeros: } s = z_1, z_2, \\ldots, z_mN(s)=0⟹Zeros: s=z1​,z2​,…,zm​POLES: Roots of denominator (characteristic equation) D(s)=0 ⟹ Poles: s=p1,p2,…,pnD(s) = 0 \\implies \\text{Poles: } s = p_1, p_2, \\ldots, p_nD(s)=0⟹Poles: s=p1​,p2​,…,pn​What They Mean Property Poles Zeros Mathematical D(s)=0D(s) = 0D(s)=0 N(s)=0N(s) = 0N(s)=0 H(s) value H(s)→∞H(s) \\to \\inftyH(s)→∞ H(s)=0H(s) = 0H(s)=0 Time domain Always in output Never in output Physical Natural frequencies Blocked frequencies ODE location Output side (left) Input side (right) Finding Poles and Zeros - 3 Steps Express H(s)=N(s)D(s)H(s) = \\frac{N(s)}{D(s)}H(s)=D(s)N(s)​ in polynomial form Find Zeros: Set N(s)=0N(s) = 0N(s)=0 and solve for sss Find Poles: Set D(s)=0D(s) = 0D(s)=0 and solve for sss Solving Polynomials 1st order (as+bas + bas+b): s=−bas = -\\frac{b}{a}s=−ab​ 2nd order (as2+bs+cas^2 + bs + cas2+bs+c): s=−b±b2−4ac2as = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}s=2a−b±b2−4ac​​ Higher order: Factor or use numerical methods 5. Pole Types and Time Response Discriminant for 2nd Order Δ=b2−4ac\\Delta = b^2 - 4acΔ=b2−4ac Discriminant Pole Type Time Response Stability Δ\u003e0\\Delta \u003e 0Δ\u003e0 Two real poles k1ep1t+k2ep2tk_1 e^{p_1 t} + k_2 e^{p_2 t}k1​ep1​t+k2​ep2​t Stable if pi\u003c0p_i \u003c 0pi​\u003c0 Δ=0\\Delta = 0Δ=0 Repeated real pole (k1+k2t)ept(k_1 + k_2 t)e^{pt}(k1​+k2​t)ept Stable if p\u003c0p \u003c 0p\u003c0 Δ\u003c0\\Delta \u003c 0Δ\u003c0 Complex conjugate Ae−αtcos⁡(ωdt+ϕ)Ae^{-\\alpha t}\\cos(\\omega_d t + \\phi)Ae−αtcos(ωd​t+ϕ) Stable if α\u003e0\\alpha \u003e 0α\u003e0 Specific Pole Locations Real Pole: s=−αs = -\\alphas=−α Time response: ke−αtu(t)\\text{Time response: } k e^{-\\alpha t} u(t)Time response: ke−αtu(t) α\u003e0\\alpha \u003e 0α\u003e0: Decaying exponential (stable) α\u003c0\\alpha \u003c 0α\u003c0: Growing exponential (unstable) Complex Conjugate Poles: s=−α±jωds = -\\alpha \\pm j\\omega_ds=−α±jωd​ Time response: Ae−αtcos⁡(ωdt+ϕ)u(t)\\text{Time response: } Ae^{-\\alpha t}\\cos(\\omega_d t + \\phi) u(t)Time response: Ae−αtcos(ωd​t+ϕ)u(t) α\u003e0\\alpha \u003e 0α\u003e0: Damped oscillation (stable) α\u003c0\\alpha \u003c 0α\u003c0: Growing oscillation (unstable) α=0\\alpha = 0α=0: Sustained oscillation (marginally stable) Pole at Origin: s=0s = 0s=0 Time response: k⋅u(t) (step function)\\text{Time response: } k \\cdot u(t) \\text{ (step function)}Time response: k⋅u(t) (step function) Indicates integrator in system 6. Natural vs Forced Response From Output Expression Vout(s)=H(s)⋅Vin(s)V_{out}(s) = H(s) \\cdot V_{in}(s)Vout​(s)=H(s)⋅Vin​(s)After factoring denominator, all poles come from:\nPoles of H(s)H(s)H(s) → Natural Response Poles of Vin(s)V_{in}(s)Vin​(s) → Forced Response Natural Response Comes from network function poles (circuit’s own modes) Independent of input type Determined by R, L, C values Same modes appear in ZIR Forced Response Comes from input signal poles Has same “shape” as input Amplitude scaled by H(s)H(s)H(s) evaluated at input frequency If input is Kes0tu(t)Ke^{s_0 t}u(t)Kes0​tu(t), forced term is K⋅H(s0)⋅es0tK \\cdot H(s_0) \\cdot e^{s_0 t}K⋅H(s0​)⋅es0​t Special Case: Resonance When input frequency = pole of H(s)H(s)H(s): Output term becomes: t⋅es0t (grows with time)\\text{Output term becomes: } t \\cdot e^{s_0 t} \\text{ (grows with time)}Output term becomes: t⋅es0​t (grows with time) 7. Time Response via Inverse Laplace Transform Complete Process - 6 Steps Find Output: Vout(s)=H(s)⋅Vin(s)V_{out}(s) = H(s) \\cdot V_{in}(s)Vout​(s)=H(s)⋅Vin​(s)\nFactor Denominator: Find ALL poles (from H(s)H(s)H(s) and Vin(s)V_{in}(s)Vin​(s))\nPartial Fraction Expansion (PFE): Vout(s)=k0s−p0+k1s−p1+k2s−p2+⋯V_{out}(s) = \\frac{k_0}{s - p_0} + \\frac{k_1}{s - p_1} + \\frac{k_2}{s - p_2} + \\cdotsVout​(s)=s−p0​k0​​+s−p1​k1​​+s−p2​k2​​+⋯ Find Residues (Cover-Up Method): ki=[(s−pi)⋅Vout(s)]s=pik_i = \\left[(s - p_i) \\cdot V_{out}(s)\\right]_{s = p_i}ki​=[(s−pi​)⋅Vout​(s)]s=pi​​ Inverse Transform: kis−pi→L−1kiepitu(t)\\frac{k_i}{s - p_i} \\xrightarrow{\\mathcal{L}^{-1}} k_i e^{p_i t} u(t)s−pi​ki​​L−1​ki​epi​tu(t) Combine and Identify:\nTerms from H(s)H(s)H(s) poles = Natural response Terms from Vin(s)V_{in}(s)Vin​(s) poles = Forced response Complex Conjugate Poles If poles are s=−α±jωds = -\\alpha \\pm j\\omega_ds=−α±jωd​ with residues kkk and k∗k^*k∗: ks−(−α+jωd)+k∗s−(−α−jωd)→L−12∣k∣e−αtcos⁡(ωdt+∠k)u(t)\\frac{k}{s - (-\\alpha + j\\omega_d)} + \\frac{k^*}{s - (-\\alpha - j\\omega_d)} \\xrightarrow{\\mathcal{L}^{-1}} 2|k|e^{-\\alpha t}\\cos(\\omega_d t + \\angle k) u(t)s−(−α+jωd​)k​+s−(−α−jωd​)k∗​L−1​2∣k∣e−αtcos(ωd​t+∠k)u(t) 8. Common Laplace Transform Pairs Time Domain f(t)f(t)f(t) s-Domain F(s)F(s)F(s) u(t)u(t)u(t) 1s\\frac{1}{s}s1​ eatu(t)e^{at}u(t)eatu(t) 1s−a\\frac{1}{s-a}s−a1​ teatu(t)te^{at}u(t)teatu(t) 1(s−a)2\\frac{1}{(s-a)^2}(s−a)21​ cos⁡(ωt)u(t)\\cos(\\omega t)u(t)cos(ωt)u(t) ss2+ω2\\frac{s}{s^2 + \\omega^2}s2+ω2s​ sin⁡(ωt)u(t)\\sin(\\omega t)u(t)sin(ωt)u(t) ωs2+ω2\\frac{\\omega}{s^2 + \\omega^2}s2+ω2ω​ e−αtcos⁡(ωt)u(t)e^{-\\alpha t}\\cos(\\omega t)u(t)e−αtcos(ωt)u(t) s+α(s+α)2+ω2\\frac{s+\\alpha}{(s+\\alpha)^2 + \\omega^2}(s+α)2+ω2s+α​ e−αtsin⁡(ωt)u(t)e^{-\\alpha t}\\sin(\\omega t)u(t)e−αtsin(ωt)u(t) ω(s+α)2+ω2\\frac{\\omega}{(s+\\alpha)^2 + \\omega^2}(s+α)2+ω2ω​ Transform Properties ddtf(t)→LsF(s)−f(0−)\\frac{d}{dt}f(t) \\xrightarrow{\\mathcal{L}} s F(s) - f(0^-)dtd​f(t)L​sF(s)−f(0−) ∫0tf(τ)dτ→LF(s)s\\int_0^t f(\\tau)d\\tau \\xrightarrow{\\mathcal{L}} \\frac{F(s)}{s}∫0t​f(τ)dτL​sF(s)​ 9. Differential Equations From H(s) to ODE - 4 Steps Start with: H(s)=Vout(s)Vin(s)=N(s)D(s)H(s) = \\frac{V_{out}(s)}{V_{in}(s)} = \\frac{N(s)}{D(s)}H(s)=Vin​(s)Vout​(s)​=D(s)N(s)​\nCross-multiply: Vout(s)⋅D(s)=Vin(s)⋅N(s)V_{out}(s) \\cdot D(s) = V_{in}(s) \\cdot N(s)Vout​(s)⋅D(s)=Vin​(s)⋅N(s)\nReplace sss with ddt\\frac{d}{dt}dtd​:\ns→ddts \\to \\frac{d}{dt}s→dtd​ s2→d2dt2s^2 \\to \\frac{d^2}{dt^2}s2→dt2d2​ sn→dndtns^n \\to \\frac{d^n}{dt^n}sn→dtndn​ Write ODE: (bndndtn+bn−1dn−1dtn−1+⋯+b0)vout(t)=(amdmdtm+⋯+a0)vin(t)\\left(b_n \\frac{d^n}{dt^n} + b_{n-1}\\frac{d^{n-1}}{dt^{n-1}} + \\cdots + b_0\\right) v_{out}(t) = \\left(a_m \\frac{d^m}{dt^m} + \\cdots + a_0\\right) v_{in}(t)(bn​dtndn​+bn−1​dtn−1dn−1​+⋯+b0​)vout​(t)=(am​dtmdm​+⋯+a0​)vin​(t) Key Insight Denominator coefficients (poles) → Output side (left) Numerator coefficients (zeros) → Input side (right) Example H(s)=2s+3s2+5s+6H(s) = \\frac{2s + 3}{s^2 + 5s + 6}H(s)=s2+5s+62s+3​Cross-multiply: Vout(s)(s2+5s+6)=Vin(s)(2s+3)V_{out}(s)(s^2 + 5s + 6) = V_{in}(s)(2s + 3)Vout​(s)(s2+5s+6)=Vin​(s)(2s+3)\nODE: d2voutdt2+5dvoutdt+6vout=2dvindt+3vin\\frac{d^2v_{out}}{dt^2} + 5\\frac{dv_{out}}{dt} + 6v_{out} = 2\\frac{dv_{in}}{dt} + 3v_{in}dt2d2vout​​+5dtdvout​​+6vout​=2dtdvin​​+3vin​ 10. Quick Problem-Solving Guide Given Circuit → Find H(s) Transform to s-domain: RRR, 1sC\\frac{1}{sC}sC1​, sLsLsL Zero all ICs (critical!) Use voltage/current divider, nodal, or mesh analysis Form H(s)=OutputInputH(s) = \\frac{\\text{Output}}{\\text{Input}}H(s)=InputOutput​ Given H(s) → Find Poles/Zeros Express as H(s)=N(s)D(s)H(s) = \\frac{N(s)}{D(s)}H(s)=D(s)N(s)​ Zeros: N(s)=0N(s) = 0N(s)=0 Poles: D(s)=0D(s) = 0D(s)=0 Given H(s) → Find Differential Equation Cross-multiply: Output(s)⋅D(s)=Input(s)⋅N(s)\\text{Output}(s) \\cdot D(s) = \\text{Input}(s) \\cdot N(s)Output(s)⋅D(s)=Input(s)⋅N(s) Replace s→ddts \\to \\frac{d}{dt}s→dtd​ Write ODE Given Circuit + Input → Find Time Response Find H(s)H(s)H(s) from circuit Calculate Vout(s)=H(s)⋅Vin(s)V_{out}(s) = H(s) \\cdot V_{in}(s)Vout​(s)=H(s)⋅Vin​(s) Do partial fraction expansion Use cover-up method for residues Inverse Laplace transform each term Add u(t)u(t)u(t) to each term 11. Critical Reminders Always Remember ✓ Zero all initial conditions when finding H(s)H(s)H(s) ✓ H(s)H(s)H(s) only describes ZSR (not ZIR) ✓ Capacitor: 1sC\\frac{1}{sC}sC1​ NOT sCsCsC ✓ Inductor: sLsLsL NOT 1sL\\frac{1}{sL}sL1​ ✓ Include u(t)u(t)u(t) in time-domain responses ✓ Complex poles come in conjugate pairs\nCommon Mistakes ✗ Forgetting to zero ICs for H(s)H(s)H(s) ✗ Confusing poles (denominator) with zeros (numerator) ✗ Wrong impedance transformations ✗ Not factoring denominator completely ✗ Forgetting u(t)u(t)u(t) in inverse Laplace ✗ Mixing up natural response (from H(s)H(s)H(s) poles) vs forced response (from input poles)\n12. Analysis Flowchart Summary START ↓ What are you given? ├─ Circuit → Transform to s-domain → Find H(s) → Poles/Zeros ├─ H(s) → Direct to Poles/Zeros OR Create ODE └─ ODE → Laplace Transform → Find H(s) → Poles/Zeros ↓ Need Time Response? ├─ Yes → V_out(s) = H(s)·V_in(s) → PFE → ILT → v_out(t) └─ No → DONE 13. Example: RC Low-Pass Filter Given: Vin→R→C→VoutV_{in} \\to R \\to C \\to V_{out}Vin​→R→C→Vout​ (across capacitor)\nFind H(s) H(s)=ZCZR+ZC=1/(sC)R+1/(sC)=11+sRC=1/RCs+1/RCH(s) = \\frac{Z_C}{Z_R + Z_C} = \\frac{1/(sC)}{R + 1/(sC)} = \\frac{1}{1 + sRC} = \\frac{1/RC}{s + 1/RC}H(s)=ZR​+ZC​ZC​​=R+1/(sC)1/(sC)​=1+sRC1​=s+1/RC1/RC​Poles and Zeros Pole: s+1RC=0 ⟹ s=−1RCs + \\frac{1}{RC} = 0 \\implies s = -\\frac{1}{RC}s+RC1​=0⟹s=−RC1​ Zeros: None (numerator is constant) Differential Equation Cross-multiply: Vout(s)(s+1RC)=Vin(s)⋅1RCV_{out}(s)(s + \\frac{1}{RC}) = V_{in}(s) \\cdot \\frac{1}{RC}Vout​(s)(s+RC1​)=Vin​(s)⋅RC1​\ndvoutdt+voutRC=vinRC\\frac{dv_{out}}{dt} + \\frac{v_{out}}{RC} = \\frac{v_{in}}{RC}dtdvout​​+RCvout​​=RCvin​​Time Response to Step Input (vin=u(t)v_{in} = u(t)vin​=u(t)) Vin(s)=1s,Vout(s)=1/RC(s+1/RC)⋅sV_{in}(s) = \\frac{1}{s}, \\quad V_{out}(s) = \\frac{1/RC}{(s + 1/RC) \\cdot s}Vin​(s)=s1​,Vout​(s)=(s+1/RC)⋅s1/RC​PFE: Vout(s)=1s−1s+1/RCV_{out}(s) = \\frac{1}{s} - \\frac{1}{s + 1/RC}Vout​(s)=s1​−s+1/RC1​\nvout(t)=[1−e−t/RC]u(t)v_{out}(t) = \\left[1 - e^{-t/RC}\\right]u(t)vout​(t)=[1−e−t/RC]u(t) Forced response: 111 (from input pole at s=0s = 0s=0) Natural response: −e−t/RC-e^{-t/RC}−e−t/RC (from H(s)H(s)H(s) pole at s=−1/RCs = -1/RCs=−1/RC)","total-response#Total Response":"","transform-properties#Transform Properties":"","types#Types":"","what-they-mean#What They Mean":"","zero-input-response-zir#Zero-Input Response (ZIR)":"","zero-state-response-zsr#Zero-State Response (ZSR)":""},"title":"poles_zeros_cheatsheet"},"/electrical_notes/ee_300/quiz_zeros_poles_chat/":{"data":{"common-laplace-pairs#Common Laplace Pairs":"u(t) ↔ 1/s e^(at)·u(t) ↔ 1/(s-a) t·e^(at)·u(t) ↔ 1/(s-a)² cos(ωt)·u(t) ↔ s/(s² + ω²) sin(ωt)·u(t) ↔ ω/(s² + ω²) e^(-αt)·cos(ωt)·u(t) ↔ (s+α)/((s+α)² + ω²)","common-quiz-question-types#Common Quiz Question Types:":"Type 1: Given circuit → Find H(s) Type 2: Given H(s) → Find poles/zeros Type 3: Given circuit + input → Find v_out(t) Type 4: Given H(s) → Write differential equation Type 5: Given poles/zeros → Sketch time response","comprehensive-poles-and-zeros-study-guide#Comprehensive Poles and Zeros Study Guide":"Comprehensive Poles and Zeros Study Guide","cover-up-method-simple-poles#Cover-Up Method (Simple Poles)":"k_i = [(s - p_i)·V_out(s)]|_(s=p_i)","detailed-steps#Detailed Steps":"Step 1: Transform Circuit to s-Domain\nConvert each element to its s-domain impedance:\nResistor R → Z = R Capacitor C → Z = 1/(sC) Inductor L → Z = sL Step 2: Zero All Initial Conditions\nThis is CRITICAL for finding H(s):\nVoltage sources (including initial condition sources) → short circuits Current sources → open circuits This ensures H(s) represents only the ZSR Step 3: Define Input and Output\nIdentify:\nInput variable: V_in(s) or I_in(s) Output variable: V_out(s) or I_out(s) Step 4: Analyze the s-Domain Circuit\nUse standard resistive circuit techniques:\nVoltage divider Current divider Nodal analysis (KCL) Mesh analysis (KVL) Source transformations Series/parallel combinations Step 5: Form H(s)\nCalculate:\nH(s) = Output(s) / Input(s) Step 6: Simplify to Rational Form\nExpress as:\nH(s) = (a_m·s^m + a_(m-1)·s^(m-1) + ... + a_0) / (b_n·s^n + b_(n-1)·s^(n-1) + ... + b_0) Factor if possible to show poles and zeros explicitly:\nH(s) = K · (s - z_1)(s - z_2)...(s - z_m) / (s - p_1)(s - p_2)...(s - p_n)","differential-equation-from-hs#Differential Equation from H(s)":"If H(s) = N(s)/D(s) Then: D(d/dt)·y(t) = N(d/dt)·x(t)","during-the-quiz#During the Quiz:":"Read carefully - What’s given? What do they want?\nWrite down knowns - Circuit values, initial conditions, input type\nChoose your path - Use the decision tree from Part 3\nShow all work - Partial credit is your friend!\nCheck units - Does s = -5 rad/s make sense?\nVerify stability - Are poles in left half-plane?\nDouble-check signs - Especially negative signs in exponentials","essential-skills-checklist#Essential Skills Checklist":"Before the quiz, make sure you can:\n✓ Transform circuits to s-domain\nR → R C → 1/(sC) L → sL ✓ Find H(s) from circuits\nZero all initial conditions first! Use voltage/current dividers or nodal/mesh analysis Express as rational function N(s)/D(s) ✓ Find poles and zeros\nPoles: solve D(s) = 0 Zeros: solve N(s) = 0 Use quadratic formula for 2nd order ✓ Write differential equations from H(s)\nCross-multiply: Output(s)·D(s) = Input(s)·N(s) Replace s with d/dt Poles → output side, Zeros → input side ✓ Perform partial fraction expansion\nFactor denominator completely Set up PFE with one term per pole Use cover-up method for residues ✓ Inverse Laplace transform\nk/(s-p) → k·e^(pt)·u(t) Handle complex conjugate pairs properly Combine to get natural + forced response ✓ Conceptual understanding\nH(s) only describes ZSR (zero initial conditions) Poles = always in output (natural response) Zeros = never in output (blocked frequencies) Natural response from H(s) poles Forced response from input poles","finding-poles#Finding Poles":"Step 1: Identify the denominator polynomial D(s)\nStep 2: Set D(s) = 0 (this is the characteristic equation)\nStep 3: Solve for s\nSame techniques as for zeros Example:\nIf D(s) = s² + 4s + 13 Then: s² + 4s + 13 = 0 Using quadratic formula: s = (-4 \\pm √(16 - 52)) / 2 s = (-4 \\pm √(-36)) / 2 s = (-4 \\pm j6) / 2 s = -2 \\pm j3 Poles: s = -2 + j3, s = -2 - j3 (complex conjugate pair)","finding-poles-and-zeros#Finding Poles and Zeros":"Zeros: N(s) = 0 Poles: D(s) = 0 [characteristic equation]","finding-zeros#Finding Zeros":"Step 1: Identify the numerator polynomial N(s)\nStep 2: Set N(s) = 0\nStep 3: Solve for s\nFactor if possible Use quadratic formula for 2nd order Use numerical methods for higher orders Example:\nIf N(s) = s² + 3s + 2 Then: s² + 3s + 2 = 0 (s + 1)(s + 2) = 0 Zeros: s = -1, s = -2","method-a-direct-time-domain-analysis#Method A: Direct Time-Domain Analysis":"Step 1: Write KCL/KVL equations in time domain\nStep 2: Use element relationships:\nResistor: v = R·i Capacitor: i = C·(dv/dt) or v = (1/C)·∫i dt Inductor: v = L·(di/dt) or i = (1/L)·∫v dt Step 3: Combine to get ODE relating input to output\nStep 4: Solve via Laplace transform:\nTransform ODE to s-domain Solve algebraically Inverse transform back","method-b-from-network-function-easier#Method B: From Network Function (EASIER!)":"If you already have H(s), you can directly write the ODE:\nStep 1: Start with H(s) in polynomial form\nH(s) = V_out(s)/V_in(s) = N(s)/D(s) Step 2: Cross-multiply\nV_out(s)·D(s) = V_in(s)·N(s) Step 3: Interpret s as the derivative operator d/dt\ns → d/dt s² → d²/dt² s³ → d³/dt³, etc. Step 4: Write the ODE\nExample:\nGiven: H(s) = (2s + 3) / (s² + 5s + 6) Cross-multiply: V_out(s)·(s² + 5s + 6) = V_in(s)·(2s + 3) Replace s with d/dt: (d²/dt² + 5·d/dt + 6)·v_out(t) = (2·d/dt + 3)·v_in(t) Final ODE: d²v_out/dt² + 5·dv_out/dt + 6·v_out = 2·dv_in/dt + 3·v_in Key Insight:\nDenominator coefficients (poles) → output side (left) Numerator coefficients (zeros) → input side (right)","network-function#Network Function":"H(s) = N(s)/D(s) = Output(s)/Input(s) [with ICs = 0]","network-function-as-rational-function#Network Function as Rational Function":"Every network function can be written as:\nH(s) = N(s) / D(s) Where:\nN(s) = Numerator polynomial D(s) = Denominator polynomial","network-functions-hs#Network Functions H(s)":"The network function is the mathematical DNA of your circuit in the s-domain.\nDefinition:\nH(s) = Output(s) / Input(s) [with all initial conditions = 0] Critical Points:\nH(s) ONLY describes the ZSR (zero-state response) Must set all initial conditions to zero when finding H(s) Relates output to input in frequency domain Types of Network Functions:\nTransfer Function H(s) or T(s)\nInput and output at DIFFERENT ports Example: V_out(s) / V_in(s) Driving-Point Impedance Z(s)\nMeasured at SAME port: V(s) / I(s) Driving-Point Admittance Y(s)\nMeasured at SAME port: I(s) / V(s) Y(s) = 1/Z(s)","part-1-foundation---zsr-zir-and-network-functions#Part 1: Foundation - ZSR, ZIR, and Network Functions":"","part-10-practice-problem-workflow#Part 10: Practice Problem Workflow":"flowchart TD Start([Example: RC Low-Pass Filter - V in to R to C to V out]) Goal[Goal: Find H-s poles zeros and diff eq] S1[Step 1: s-Domain Transform - Z R equals R - Z C equals 1 over sC] S2[Step 2: Voltage Divider - H-s equals Z C over Z R plus Z C] S3[Step 3: Substitute - H-s equals 1 over sC divided by R plus 1 over sC] S4[Step 4: Simplify - Multiply top and bottom by sC] Result1[H-s equals 1 over 1 plus sRC equals 1 over RC divided by s plus 1 over RC] FindPZ[Find Poles and Zeros] Num[Numerator: N-s equals 1 over RC constant] Z[No finite zeros cannot equal 0] Den[Denominator: D-s equals s plus 1 over RC] P[Set s plus 1 over RC equals 0 - Pole: s equals negative 1 over RC] PZDone[Pole at s equals negative 1 over RC - No finite zeros] DiffEq[Create Differential Equation] Cross[Cross-multiply: V out-s times s plus 1 over RC equals V in-s times 1 over RC] Replace[Replace s with d over dt] ODE[dv out over dt plus v out over RC equals v in over RC] TimeResp[Find Time Response to step input: v in equals u-t] VinS[V in-s equals 1 over s] VoutS[V out-s equals H-s times V in-s equals 1 over RC divided by s plus 1 over RC times 1 over s] PFE[Partial Fractions: V out-s equals A over s plus B over s plus 1 over RC] CoverUp[Cover-up method: A equals 1 - B equals negative 1] ILT[Inverse Laplace: v out-t equals 1 minus e to negative t over RC] Final[Final: v out-t equals 1 minus e to negative t over RC times u-t - Natural response: negative e to negative t over RC from H-s pole - Forced response: 1 from input pole at s equals 0] Complete([Complete Solution]) Start --\u003e Goal Goal --\u003e S1 S1 --\u003e S2 S2 --\u003e S3 S3 --\u003e S4 S4 --\u003e Result1 Result1 --\u003e FindPZ FindPZ --\u003e Num FindPZ --\u003e Den Num --\u003e Z Den --\u003e P Z --\u003e PZDone P --\u003e PZDone PZDone --\u003e DiffEq DiffEq --\u003e Cross Cross --\u003e Replace Replace --\u003e ODE ODE --\u003e TimeResp TimeResp --\u003e VinS VinS --\u003e VoutS VoutS --\u003e PFE PFE --\u003e CoverUp CoverUp --\u003e ILT ILT --\u003e Final Final --\u003e Complete Example Circuit: RC Low-Pass Filter\nGiven: Input v_in, output v_out across capacitor, R and C in series.\nFind H(s), poles, zeros, and differential equation:\nSolution:\ns-domain circuit:\nZ_R = R Z_C = 1/(sC) Voltage divider:\nH(s) = V_out(s)/V_in(s) = Z_C/(Z_R + Z_C) H(s) = [1/(sC)] / [R + 1/(sC)] H(s) = 1 / (1 + sRC) H(s) = 1/(RC) / (s + 1/(RC)) Poles and zeros:\nN(s) = 1/(RC) → No finite zeros D(s) = s + 1/(RC) = 0 Pole: s = -1/(RC) Differential equation:\nCross-multiply: V_out(s)·(s + 1/(RC)) = V_in(s)·(1/(RC)) Replace s → d/dt: (d/dt + 1/(RC))·v_out = (1/(RC))·v_in dv_out/dt + v_out/(RC) = v_in/(RC) Time response to step input (v_in = u(t)):\nV_in(s) = 1/s V_out(s) = H(s)·V_in(s) = [1/(RC)]/[(s + 1/(RC))·s] PFE: V_out(s) = 1/s - 1/(s + 1/(RC)) v_out(t) = [1 - e^(-t/(RC))]·u(t)","part-11-quiz-preparation-checklist#Part 11: Quiz Preparation Checklist":"flowchart TD Start([Quiz Day Preparation]) C1{Can you do this?} T1[Transform R L C to s-domain] Study1[Review Part 4] C2{Can you do this?} T2[Find H-s from circuit using circuit analysis] Study2[Review Part 4] C3{Can you do this?} T3[Find poles: set D-s equals 0 - Find zeros: set N-s equals 0] Study3[Review Part 5] C4{Can you do this?} T4[Write diff eq from H-s by cross-multiplying] Study4[Review Part 6] C5{Can you do this?} T5[Do partial fraction expansion] Study5[Review Part 7] C6{Can you do this?} T6[Use cover-up method for residues] Study6[Review Part 7] C7{Can you do this?} T7[Inverse Laplace transform each term] Study7[Review Part 7] C8{Do you understand?} T8[Distinguish natural vs forced response] Study8[Review Part 2 and 7] C9{Do you remember?} T9[Zero ICs when finding H-s] Study9[Review Part 1 and 4] C10{Can you recognize?} T10[Different pole types and their time responses] Study10[Review Part 5] Ready[READY FOR QUIZ] Start --\u003e C1 C1 --\u003e|Yes| T1 C1 --\u003e|No| Study1 T1 --\u003e C2 C2 --\u003e|Yes| T2 C2 --\u003e|No| Study2 T2 --\u003e C3 C3 --\u003e|Yes| T3 C3 --\u003e|No| Study3 T3 --\u003e C4 C4 --\u003e|Yes| T4 C4 --\u003e|No| Study4 T4 --\u003e C5 C5 --\u003e|Yes| T5 C5 --\u003e|No| Study5 T5 --\u003e C6 C6 --\u003e|Yes| T6 C6 --\u003e|No| Study6 T6 --\u003e C7 C7 --\u003e|Yes| T7 C7 --\u003e|No| Study7 T7 --\u003e C8 C8 --\u003e|Yes| T8 C8 --\u003e|No| Study8 T8 --\u003e C9 C9 --\u003e|Yes| T9 C9 --\u003e|No| Study9 T9 --\u003e C10 C10 --\u003e|Yes| T10 C10 --\u003e|No| Study10 T10 --\u003e Ready Study1 --\u003e C1 Study2 --\u003e C2 Study3 --\u003e C3 Study4 --\u003e C4 Study5 --\u003e C5 Study6 --\u003e C6 Study7 --\u003e C7 Study8 --\u003e C8 Study9 --\u003e C9 Study10 --\u003e C10","part-12-key-conceptual-questions-for-understanding#Part 12: Key Conceptual Questions for Understanding":"flowchart TD Q1[Q: Why do we zero initial conditions for H-s?] A1[A: H-s only describes ZSR zero-state response - ICs would add ZIR component] Q2[Q: What is the difference between poles and zeros?] A2[A: Poles from D-s equals 0 always in output - Zeros from N-s equals 0 blocked from output] Q3[Q: Why do complex poles come in conjugate pairs?] A3[A: Real circuits have real coefficients - Complex roots of real polynomials must be conjugate pairs] Q4[Q: What does a pole at origin s equals 0 mean?] A4[A: Integrator in system - Step response in time domain - DC gain is infinite] Q5[Q: What happens when input frequency equals pole of H-s?] A5[A: RESONANCE - Output grows as t times e to s zero t - System is driven at natural frequency] Q6[Q: How do you identify natural vs forced response?] A6[A: Natural from H-s poles - Forced from input poles - Check which pole each term came from] Q7[Q: What makes a system unstable?] A7[A: Poles in right half-plane positive real part - Leads to growing exponentials] Q8[Q: Why is the characteristic equation important?] A8[A: D-s equals 0 gives the poles - Poles determine natural response - Same for ZIR and ZSR natural modes] Q1 --\u003e A1 Q2 --\u003e A2 Q3 --\u003e A3 Q4 --\u003e A4 Q5 --\u003e A5 Q6 --\u003e A6 Q7 --\u003e A7 Q8 --\u003e A8","part-13-final-tips-for-quiz-success#Part 13: Final Tips for Quiz Success":"","part-14-summary---the-big-picture#Part 14: Summary - The Big Picture":"flowchart TD Circuit[Circuit with R L C] Transform[Transform to s-Domain] Hs[Network Function H-s equals N-s over D-s] Split{What do you need?} PZ[Find roots: Poles D-s equals 0 - Zeros N-s equals 0] DE[Cross-multiply and replace s with d over dt] TR[V out-s equals H-s times V in-s Then PFE and ILT] Understand[Understanding: Poles gives Natural response - Zeros gives Blocked frequencies] Master[MASTERY: You can now analyze any linear circuit] Circuit --\u003e Transform Transform --\u003e Hs Hs --\u003e Split Split --\u003e|Poles and Zeros| PZ Split --\u003e|Diff Eq| DE Split --\u003e|Time Response| TR PZ --\u003e Understand DE --\u003e Understand TR --\u003e Understand Understand --\u003e Master","part-2-what-are-poles-and-zeros#Part 2: What Are Poles and Zeros?":"","part-3-master-decision-tree---problem-solving-strategy#Part 3: Master Decision Tree - Problem Solving Strategy":"flowchart TD Start([Start: Given Problem]) Q1{What are you given?} Start --\u003e Q1 Q1 --\u003e|Circuit Diagram| Path1[Path A: Circuit Analysis] Q1 --\u003e|Network Function| Path2[Path B: From H-s] Q1 --\u003e|Differential Equation| Path3[Path C: From ODE] Path1 --\u003e Q2{What do you need to find?} Q2 --\u003e|H-s| A1[Follow Part 4: Circuit to H-s] Q2 --\u003e|Poles and Zeros| A2[First get H-s then Part 5] Q2 --\u003e|Time Response| A3[Get H-s then Part 7: ILT Method] Q2 --\u003e|Differential Equation| A4[First get H-s then Part 6B] Path2 --\u003e Q3{What do you need?} Q3 --\u003e|Poles and Zeros| B1[Follow Part 5: Find Poles and Zeros] Q3 --\u003e|Differential Equation| B2[Follow Part 6B: H-s to ODE] Q3 --\u003e|Time Response| B3[Follow Part 7: ILT Method] Path3 --\u003e Q4{What do you need?} Q4 --\u003e|H-s| C1[Laplace transform both sides solve for Output over Input] Q4 --\u003e|Poles and Zeros| C2[Get H-s first then Part 5] Q4 --\u003e|Time Response| C3[Solve ODE via Laplace method] A1 --\u003e Done1[Solution Complete] A2 --\u003e Done1 A3 --\u003e Done1 A4 --\u003e Done1 B1 --\u003e Done1 B2 --\u003e Done1 B3 --\u003e Done1 C1 --\u003e Done1 C2 --\u003e Done1 C3 --\u003e Done1","part-4-step-by-step-process-to-find-hs-from-circuit#Part 4: Step-by-Step Process to Find H(s) from Circuit":"flowchart TD Start([Given: Circuit Diagram]) Step1[Step 1: Transform to s-Domain] Detail1[R remains R, C becomes 1 over sC, L becomes sL] Step2[Step 2: Zero Initial Conditions] Detail2[CRITICAL: Set all ICs to zero, Voltage sources become Short, Current sources become Open] Step3[Step 3: Define Input and Output] Detail3[Identify Input and Output variables] Step4[Step 4: Circuit Analysis] Q1{Which technique is easiest?} T1[Combine impedances] T2[Voltage or Current divider] T3[Nodal or Mesh analysis] Step5[Step 5: Form H-s] Detail5[H-s equals Output over Input] Step6[Step 6: Simplify to Rational Form] Detail6[H-s equals N-s over D-s] End([H-s Found Ready for Part 5]) Start --\u003e Step1 Step1 --\u003e Detail1 Detail1 --\u003e Step2 Step2 --\u003e Detail2 Detail2 --\u003e Step3 Step3 --\u003e Detail3 Detail3 --\u003e Step4 Step4 --\u003e Q1 Q1 --\u003e|Series or Parallel| T1 Q1 --\u003e|Two elements| T2 Q1 --\u003e|Complex circuit| T3 T1 --\u003e Step5 T2 --\u003e Step5 T3 --\u003e Step5 Step5 --\u003e Detail5 Detail5 --\u003e Step6 Step6 --\u003e Detail6 Detail6 --\u003e End","part-5-step-by-step-process-to-find-poles-and-zeros#Part 5: Step-by-Step Process to Find Poles and Zeros":"flowchart TD Start([Given: H-s equals N-s over D-s]) Split{Find which?} Z1[Step 1: Identify N-s] P1[Step 1: Identify D-s] Both[Do both paths] Z2[Step 2: Set N-s equals 0] Z3[Step 3: Solve for s] ZQ{Polynomial order?} ZS1[s equals negative b over a] ZS2[Use quadratic formula] ZS3[Factor or use numerical methods] ZEnd[Zeros Found] P2[Step 2: Set D-s equals 0 - Characteristic Equation] P3[Step 3: Solve for s] PQ{Polynomial order?} PS1[s equals negative b over a] PS2[Use quadratic formula Check discriminant] PS3[Factor or use numerical methods] PEnd[Poles Found] PCheck{Discriminant b squared minus 4ac} Real[Two real poles] Repeated[Repeated real pole] Complex[Complex conjugate pair s equals negative alpha plus or minus j omega] Final([Solution Complete]) Start --\u003e Split Split --\u003e|Zeros| Z1 Split --\u003e|Poles| P1 Split --\u003e|Both| Both Both --\u003e Z1 Both --\u003e P1 Z1 --\u003e Z2 Z2 --\u003e Z3 Z3 --\u003e ZQ ZQ --\u003e|1st order| ZS1 ZQ --\u003e|2nd order| ZS2 ZQ --\u003e|Higher order| ZS3 ZS1 --\u003e ZEnd ZS2 --\u003e ZEnd ZS3 --\u003e ZEnd P1 --\u003e P2 P2 --\u003e P3 P3 --\u003e PQ PQ --\u003e|1st order| PS1 PQ --\u003e|2nd order| PS2 PQ --\u003e|Higher order| PS3 PS1 --\u003e PEnd PS2 --\u003e PCheck PS3 --\u003e PEnd PCheck --\u003e|Greater than 0| Real PCheck --\u003e|Equals 0| Repeated PCheck --\u003e|Less than 0| Complex Real --\u003e PEnd Repeated --\u003e PEnd Complex --\u003e PEnd ZEnd --\u003e Final PEnd --\u003e Final Once you have H(s) = N(s)/D(s):","part-6-creating-differential-equations-from-circuits#Part 6: Creating Differential Equations from Circuits":"flowchart TD Start([Need: Differential Equation]) Q{What do you have?} MethodA[Method A: Direct Time-Domain Analysis] MethodB[Method B: From H-s - EASIER] A1[Step 1: Write KCL or KVL in time domain] A2[Step 2: Use element relations] A3[Step 3: Combine to get ODE relating input to output] A4[Step 4: Solve via Laplace transform if needed] B1[Step 1: Start with H-s equals N-s over D-s] B2[Step 2: Cross-multiply Output times D-s equals Input times N-s] B3[Step 3: Replace s with d over dt] B4[Step 4: Write the ODE] Key[KEY INSIGHT: Denominator D-s poles goes to Output side LEFT - Numerator N-s zeros goes to Input side RIGHT] End([ODE Found]) Start --\u003e Q Q --\u003e|Circuit diagram| MethodA Q --\u003e|Network function H-s| MethodB MethodA --\u003e A1 A1 --\u003e A2 A2 --\u003e A3 A3 --\u003e A4 MethodB --\u003e B1 B1 --\u003e B2 B2 --\u003e B3 B3 --\u003e B4 B4 --\u003e Key A4 --\u003e End Key --\u003e End","part-7-time-domain-response-via-inverse-laplace-transform#Part 7: Time-Domain Response via Inverse Laplace Transform":"flowchart TD Start([Given: H-s and Input V in-s]) Step1[Step 1: Find V out-s equals H-s times V in-s] Step2[Step 2: Factor Denominator Find ALL poles] Identify[Identify pole sources: Poles from H-s gives Natural response - Poles from V in-s gives Forced response] Step3[Step 3: Partial Fraction Expansion PFE] PFE[V out-s equals k zero over s minus p zero plus k one over s minus p one plus dot dot dot] Step4[Step 4: Find Residues] Q{Pole type?} Simple[Cover-Up Method: k i equals s minus p i times V out-s evaluated at s equals p i] Complex[Both residues will be complex conjugates Use cover-up on each] Repeated[Use special methods derivatives of cover-up] Step5[Step 5: Inverse Transform Each Term] Transform[k i over s minus p i transforms to k i times e to p i t times u-t] Special{Special cases?} SC[Combine conjugate pairs: 2 magnitude k times e to negative alpha t times cosine omega d t plus angle k times u-t] SR[Direct transform: k times e to pt times u-t] Step6[Step 6: Combine All Terms v out-t equals Sum of all transformed terms] Classify[Classify response: Terms from H-s poles equals Natural - Terms from V in-s poles equals Forced] End([Time Response Found]) Start --\u003e Step1 Step1 --\u003e Step2 Step2 --\u003e Identify Identify --\u003e Step3 Step3 --\u003e PFE PFE --\u003e Step4 Step4 --\u003e Q Q --\u003e|Simple pole| Simple Q --\u003e|Complex conjugate| Complex Q --\u003e|Repeated pole| Repeated Simple --\u003e Step5 Complex --\u003e Step5 Repeated --\u003e Step5 Step5 --\u003e Transform Transform --\u003e Special Special --\u003e|Complex poles s equals negative alpha plus or minus j omega d| SC Special --\u003e|Real poles| SR SC --\u003e Step6 SR --\u003e Step6 Step6 --\u003e Classify Classify --\u003e End","part-8-common-mistakes-to-avoid#Part 8: Common Mistakes to Avoid":"flowchart TD Start([Common Pitfalls]) M1[Mistake 1: Forgetting to zero ICs when finding H-s] Fix1[Fix: Always set V c zero equals 0 and I L zero equals 0 for H-s - H-s only describes ZSR] M2[Mistake 2: Confusing poles and zeros] Fix2[Fix: Poles equals D-s equals 0 denominator - Zeros equals N-s equals 0 numerator] M3[Mistake 3: Wrong impedance conversions] Fix3[Fix: C is 1 over sC NOT sC - L is sL NOT 1 over sL] M4[Mistake 4: Not factoring completely] Fix4[Fix: Find ALL poles and zeros - Complex poles come in conjugate pairs] M5[Mistake 5: Forgetting u-t in time domain] Fix5[Fix: 1 over s minus a transforms to e to at times u-t NOT just e to at] M6[Mistake 6: Mixing up natural vs forced] Fix6[Fix: Natural equals H-s poles - Forced equals Input poles] M7[Mistake 7: Missing resonance case] Fix7[Fix: When input frequency equals pole of H-s special case - Term becomes t times e to s zero t] End([Stay Alert]) Start --\u003e M1 M1 --\u003e Fix1 Fix1 --\u003e M2 M2 --\u003e Fix2 Fix2 --\u003e M3 M3 --\u003e Fix3 Fix3 --\u003e M4 M4 --\u003e Fix4 Fix4 --\u003e M5 M5 --\u003e Fix5 Fix5 --\u003e M6 M6 --\u003e Fix6 Fix6 --\u003e M7 M7 --\u003e Fix7 Fix7 --\u003e End Forgetting to zero initial conditions when finding H(s)\nH(s) ONLY represents ZSR Must set V_c(0) = 0 and I_L(0) = 0 Confusing poles and zeros\nPoles = denominator roots (D(s) = 0) Zeros = numerator roots (N(s) = 0) Not factoring completely\nMust find ALL poles and zeros Complex poles come in conjugate pairs Wrong impedance conversions\nCapacitor: 1/(sC) not sC Inductor: sL not 1/(sL) Forgetting unit step u(t) in time domain\nILT of 1/(s-a) is e^(at)·u(t), not just e^(at) Mixing up which response is which\nNatural response = from H(s) poles Forced response = from input poles Not recognizing resonance\nWhen input frequency = pole of H(s), special case occurs","part-9-quick-reference-formulas#Part 9: Quick Reference Formulas":"","poles-the-circuits-natural-frequencies#POLES: The Circuit\u0026rsquo;s Natural Frequencies":"Definition: Poles are the roots of the denominator: D(s) = 0\nWhy “poles”? At these values of s, H(s) → ∞ (the function “blows up”)\nWhat poles tell you:\nIn s-domain:\nLocations where H(s) becomes infinite Also called “natural frequencies” or “characteristic roots” In time domain:\nDetermine the natural response modes Each pole creates an exponential term in the output Real pole at s = -α → term like: k·e^(-αt) Complex poles at s = -α \\pm jω_d → damped sinusoid: k·e^(-αt)·cos(ω_d·t + φ) In differential equations:\nPoles come from the OUTPUT side (left side) of the ODE The characteristic equation D(s) = 0 gives you the poles Physical meaning:\nPoles represent modes that are always present in the output Even if your input doesn’t contain these frequencies, they’ll appear in the response Special case: If input frequency = pole frequency, you get resonance (term becomes t·e^(s_0·t))","process-overview#Process Overview":"Time-domain circuit → s-domain circuit → H(s) → Poles \u0026 Zeros","quick-mental-checks#Quick Mental Checks:":"✓ Did I zero initial conditions for H(s)? ✓ Are my impedances correct? (1/sC not sC!) ✓ Did I factor completely? ✓ Does my answer make physical sense? ✓ Did I include u(t) in time-domain?","quick-reference-table#Quick Reference Table":"Property Poles Zeros Math Roots of D(s) = 0 Roots of N(s) = 0 H(s) value H(s) → ∞ H(s) = 0 ODE side Output (left) Input (right) Time domain Always in output Never in output Circuit property Natural modes Blocked frequencies","remember-the-core-concepts#Remember the Core Concepts:":"H(s) = N(s)/D(s) is the heart of everything Poles (D(s) = 0) → Natural modes, always present Zeros (N(s) = 0) → Blocked frequencies, never in output Natural response comes from H(s) poles Forced response comes from input poles Always zero ICs when finding H(s)","s-domain-impedances#s-Domain Impedances":"Z_R = R Z_C = 1/(sC) Z_L = sL","special-cases#Special Cases":"Complex Conjugate Poles (s = -α \\pm jω_d):\nIf k and k* are conjugate residues:\nk/(s - (-α + jω_d)) + k*/(s - (-α - jω_d)) Combines to give:\n2|k|·e^(-αt)·cos(ω_d·t + ∠k)·u(t) Repeated Poles:\nFor pole p_i with multiplicity n, use special techniques (not covered in detail here, but involves derivatives of the cover-up method).","step-by-step-ilt-process#Step-by-Step ILT Process":"Step 1: Find V_out(s)\nV_out(s) = H(s)·V_in(s) Step 2: Factor the Denominator\nFactor completely to find ALL poles:\nPoles from H(s) → natural response Poles from V_in(s) → forced response Step 3: Partial Fraction Expansion (PFE)\nDecompose into simple terms:\nV_out(s) = k_0/(s - p_0) + k_1/(s - p_1) + k_2/(s - p_2) + ... Step 4: Find Residues Using Cover-Up Method\nFor simple pole at s = p_i:\nk_i = [(s - p_i)·V_out(s)]|_(s=p_i) Cover up the (s - p_i) term in V_out(s), then substitute s = p_i everywhere else.\nStep 5: Inverse Transform\nEach term transforms as:\nk_i/(s - p_i) → k_i·e^(p_i·t)·u(t) Step 6: Combine Terms\nv_out(t) = k_0·e^(p_0·t) + k_1·e^(p_1·t) + k_2·e^(p_2·t) + ... [forced] [natural response terms]","the-big-picture#The Big Picture":"When you have:\nV_out(s) = H(s)·V_in(s) The time response v_out(t) contains TWO types of terms:\nNatural Response → from poles of H(s) Forced Response → from poles of V_in(s)","the-complete-problem-solving-framework#The Complete Problem-Solving Framework:":"Path 1: Circuit → H(s) → Poles/Zeros\nTransform to s-domain (R, 1/sC, sL) Zero initial conditions Use circuit analysis to find H(s) Find poles: D(s) = 0 Find zeros: N(s) = 0 Path 2: H(s) → Differential Equation\nStart with H(s) = N(s)/D(s) Cross-multiply Replace s → d/dt Write ODE (poles on output side, zeros on input side) Path 3: Circuit + Input → Time Response\nFind H(s) from circuit Calculate V_out(s) = H(s)·V_in(s) Partial fraction expansion Cover-up method for residues Inverse Laplace transform Identify natural vs forced response","think-about-these#Think About These:":"Why zero initial conditions for H(s)?\nH(s) represents only the ZSR (zero-state response) Initial conditions would add the ZIR component We want the pure input-to-output relationship What’s the physical meaning of a pole?\nA natural frequency of the circuit Will appear in output even if not in input Determined by circuit elements (R, L, C values) What’s the physical meaning of a zero?\nA frequency that gets blocked/cancelled If input contains this frequency, it won’t reach output Like a notch filter Why do complex poles always come in conjugate pairs?\nReal circuits have real-valued components Polynomials with real coefficients have conjugate complex roots Ensures time-domain response is real What happens at resonance?\nInput frequency matches a pole of H(s) Normal exponential becomes t·e^(st) Output grows without bound (in theory)","time-management-strategy#Time Management Strategy":"flowchart LR Read[1. Read problem carefully 1 min] Identify[2. Identify what is given and what is asked 1 min] Plan[3. Choose method Circuit to H-s to poles or zeros 30 sec] Execute[4. Execute solution Show all steps 5-8 min] Check[5. Check answer Units? Reasonable? 1 min] Read --\u003e Identify Identify --\u003e Plan Plan --\u003e Execute Execute --\u003e Check","total-response--zir--zsr#Total Response = ZIR + ZSR":"By superposition, the complete circuit response is:\nTotal Response = ZIR + ZSR","types-of-poles-and-their-time-domain-responses#Types of Poles and Their Time-Domain Responses":"flowchart TD Start([Pole Type]) Q{Pole location?} R1[Time response: k times e to the negative alpha t - Decaying exponential] R2[Time response: k times e to the positive alpha t - Growing exponential - UNSTABLE] R3[Time response: k times u-t - Step function - Integrator] C1{Sign of alpha?} I1[Time response: k times cosine omega zero t plus phi - Sustained oscillation - Marginally stable] C2[k times e to negative alpha t times cosine omega d t plus phi - Damped oscillation - Stable] C3[k times e to positive alpha t times cosine omega d t plus phi - Growing oscillation - UNSTABLE] End1[Stable] End2[Unstable] End3[Marginally Stable] Start --\u003e Q Q --\u003e|Real negative s equals negative alpha where alpha greater than 0| R1 Q --\u003e|Real positive s equals positive alpha| R2 Q --\u003e|At origin s equals 0| R3 Q --\u003e|Complex conjugate s equals negative alpha plus or minus j omega d| C1 Q --\u003e|Imaginary s equals plus or minus j omega zero| I1 C1 --\u003e|alpha greater than 0| C2 C1 --\u003e|alpha less than 0| C3 C1 --\u003e|alpha equals 0| I1 R1 --\u003e End1 R2 --\u003e End2 R3 --\u003e End3 C2 --\u003e End1 C3 --\u003e End2 I1 --\u003e End3 Key Points:\nReal, negative pole (s = -α, α \u003e 0)\nTime response: k·e^(-αt) → decaying exponential Stable Real, positive pole (s = +α)\nTime response: k·e^(+αt) → growing exponential UNSTABLE Complex conjugate pair (s = -α \\pm jω_d)\nTime response: k·e^(-αt)·cos(ω_d·t + φ) Damped oscillation if α \u003e 0 Growing oscillation if α \u003c 0 (unstable) Imaginary poles (s = \\pmjω_0)\nTime response: k·cos(ω_0·t + φ) Sustained oscillation (marginally stable) Pole at origin (s = 0)\nTime response: k·u(t) → step function Indicates integrator in system","understanding-natural-vs-forced-response#Understanding Natural vs Forced Response":"flowchart LR Input[Input V in-s has poles] Forced[Forced Response Same shape as input Amplitude scaled by H-s] Network[Network H-s has poles] Natural[Natural Response Circuits own modes Independent of input] Output[Total Output v out-t] Special[Special Case: Input frequency equals H-s pole] Resonance[Resonance Output term: t times e to s zero t] Input --\u003e Forced Network --\u003e Natural Forced --\u003e Output Natural --\u003e Output Special --\u003e Resonance Forced Response:\nComes from input poles Has same “shape” as input Amplitude scaled by H(s) evaluated at input frequency If v_in(t) = K·e^(s_0·t)·u(t), then forced term = K·H(s_0)·e^(s_0·t) Natural Response:\nComes from H(s) poles Independent of input type Determined by circuit elements (R, L, C) Same modes appear in ZIR (zero-input response) Key Insight: If input frequency matches a pole of H(s), you get resonance - the output term becomes t·e^(s_0·t) (grows with time).","youve-got-this-#You\u0026rsquo;ve Got This! 🎯":"This guide covers everything you need. The Mermaid diagrams show you the decision-making process at each step. When you’re stuck:\nLook at the master decision tree (Part 3) Follow the step-by-step flowcharts Check the common mistakes section Verify with the quiz preparation checklist Practice a few problems using these flowcharts, and you’ll be ready!\nGood luck on your quiz!","zero-input-response-zir#Zero-Input Response (ZIR)":"The ZIR represents what your circuit does based purely on stored energy.\nWhat it is: Response with NO external input sources Caused by: Initial conditions (capacitor voltage V_c(0), inductor current I_L(0)) In time domain: This is the natural response - the circuit “ringing” due to stored energy Key insight: ZIR exists even after you turn off all sources","zero-state-response-zsr#Zero-State Response (ZSR)":"The ZSR represents what your circuit does based purely on external inputs.\nWhat it is: Response with NO initial stored energy (all initial conditions = 0) Caused by: External voltage/current sources Key insight: ZSR assumes the circuit starts from a “blank slate”","zeros-the-circuits-blocking-frequencies#ZEROS: The Circuit\u0026rsquo;s Blocking Frequencies":"Definition: Zeros are the roots of the numerator: N(s) = 0\nWhy “zeros”? At these values of s, H(s) = 0 (the function becomes zero)\nWhat zeros tell you:\nIn s-domain:\nLocations where H(s) = 0 In time domain:\nDetermine which frequencies are blocked from appearing in output If input contains e^(z_i·t) where z_i is a zero, that term is completely eliminated from output In differential equations:\nZeros come from the INPUT side (right side) of the ODE Physical meaning:\nZeros act as “blockers” - they prevent certain input frequencies from reaching the output Like a notch filter that kills specific frequencies"},"title":"quiz_zeros_poles_chat"},"/electrical_notes/ee_300/quiz_zeros_poles_nblm/":{"data":{"":"","1-zero-state-response-zsr-tracking#1. Zero-State Response (ZSR) Tracking":"","2-zero-input-response-zir-tracking#2. Zero-Input Response (ZIR) Tracking":"","3-the-role-of-the-network-function#3. The Role of the Network Function ":"","4-relationship-between--and-differential-equations-diffeq#4. Relationship Between  and Differential Equations (Diffeq)":"","a-creating-the-differential-equation-from-a-circuit#A. Creating the Differential Equation from a Circuit":"","a-forced-response-input-poles#A. Forced Response (Input Poles)":"","a-what-are-poles#A. What are Poles?":"","a-zero-input-response-zir#A. Zero-Input Response (ZIR)":"","b-creating-the-differential-equation-from#B. Creating the Differential Equation from ":"","b-natural-response-network-function-poles#B. Natural Response (Network Function Poles)":"","b-what-are-zeros#B. What are Zeros?":"","b-zero-state-response-zsr#B. Zero-State Response (ZSR)":"","c-network-functions-#C. Network Functions ()":"","i-comprehensive-theory-overview-zsr-zir-and-network-functions#I. Comprehensive Theory Overview: ZSR, ZIR, and Network Functions":"","ii-poles-and-zeros-explained#II. Poles and Zeros Explained":"","iii-step-by-step-guide-for-poles-and-zeros-using-network-functions#III. Step-by-Step Guide for Poles and Zeros using Network Functions":"","iv-differential-equations-from-circuits-and-network-functions#IV. Differential Equations from Circuits and Network Functions":"","network-function-calculation#Network Function Calculation":"","poles-denominator---output-zirnatural-response#Poles (Denominator )  Output (ZIR/Natural Response)":"","step-by-step-guide-to-derive-the-ode-from#Step-by-Step Guide to Derive the ODE from ":"H(s)H(s)H(s) Define H(s)H(s)H(s): Start with the network function expressed as a rational function, e.g., H(s)=Vout(s)Vin(s)=N(s)D(s)H(s) = \\frac{V_{out}(s)}{V_{in}(s)} = \\frac{N(s)}{D(s)}H(s)=Vin​(s)Vout​(s)​=D(s)N(s)​. Cross-Multiply: Rearrange the equation: Vout(s)⋅D(s)=Vin(s)⋅N(s)V_{out}(s) \\cdot D(s) = V_{in}(s) \\cdot N(s)Vout​(s)⋅D(s)=Vin​(s)⋅N(s). Substitute sss for ddt\\frac{d}{dt}dtd​: Use the differentiation property of the Laplace Transform, recognizing that multiplication by sss in the sss-domain corresponds to differentiation in the time domain, provided all initial conditions are zero (which is true for the ZSR/network function context). Write the ODE: Apply the inverse LT to obtain the final time-domain differential equation relating the output vout(t)v_{out}(t)vout​(t) and input vin(t)v_{in}(t)vin​(t). For example, if H(s)=s+2s2+3s+1H(s) = \\frac{s+2}{s^2 + 3s + 1}H(s)=s2+3s+1s+2​, the resulting ODE is: (s2+3s+1)Vout(s)=(s+2)Vin(s)\\left(s^2 + 3s + 1\\right) V_{out}(s) = \\left(s+2\\right) V_{in}(s)(s2+3s+1)Vout​(s)=(s+2)Vin​(s) d2vout(t)dt2+3dvout(t)dt+vout(t)=dvin(t)dt+2vin(t)\\frac{d^2 v_{out}(t)}{dt^2} + 3 \\frac{d v_{out}(t)}{dt} + v_{out}(t) = \\frac{d v_{in}(t)}{dt} + 2 v_{in}(t)dt2d2vout​(t)​+3dtdvout​(t)​+vout​(t)=dtdvin​(t)​+2vin​(t)","step-by-step-process-for-ilt-and-time-response#Step-by-Step Process for ILT and Time Response":"","step-by-step-process-to-calculate#Step-by-Step Process to Calculate ":"","step-by-step-process-to-find-poles-and-zeros#Step-by-Step Process to Find Poles and Zeros":"","using--for-total-response#Using  for Total Response":"","v-poles-and-zeros-in-time-domain-response-inverse-laplace-transform#V. Poles and Zeros in Time-Domain Response (Inverse Laplace Transform)":"","zeros-numerator---input-zsrforced-response-interaction#Zeros (Numerator )  Input (ZSR/Forced Response Interaction)":"I will have a quiz on poles and zeros. I need to understand everything regarding poles and zeros from the context of understanding creating a differential equation from a circuit, or converting to s-domain and using inverse laplace transform, or using s-domain and calculating network functions like H(s) and creating a diffeq. Please explain all of these topics and provide step by step guides to find poles and zeros. explain what poles and zeros are in all of these contexts. You don’t have to cover laplace transforms as i have documentation for this, but i do need to cover the theory behind ZSR, ZIR, and network functions. please create comprehensive theory overview and step my step processes for me to solve any problem associated with poles and zeros and using network funcitons.\nThis is a comprehensive overview of poles and zeros within the context of linear circuit analysis using the sss-domain, network functions, and differential equations, drawing entirely from the provided sources.\nI. Comprehensive Theory Overview: ZSR, ZIR, and Network Functions The total response of a linear circuit can be separated using the principle of superposition into two components: the Zero-Input Response (ZIR) and the Zero-State Response (ZSR).\nA. Zero-Input Response (ZIR) The Zero-Input Response (ZIR) is the circuit behavior due entirely to stored energy (initial conditions) in energy storage elements (capacitors and inductors).\nDefinition: ZIR is the response assuming there is zero external input or source. Origin: It is derived from the initial voltage across a capacitor, Vc(0)V_c(0)Vc​(0), or the initial current through an inductor, IL(0)I_L(0)IL​(0). Time Domain Connection: The ZIR is solely composed of the natural response of the circuit. B. Zero-State Response (ZSR) The Zero-State Response (ZSR) is the circuit behavior due entirely to the external input sources.\nDefinition: ZSR is the response when the initial state of the circuit (stored energy) is set to zero. Input Requirement: The ZSR occurs for any input, provided that before time t\u003c0t\u003c0t\u003c0, no energy is stored in the network. C. Network Functions (H(s)H(s)H(s)) The Network Function, H(s)H(s)H(s) (or T(s)T(s)T(s)), is the mathematical representation of the circuit’s dynamic behavior in the sss-domain and is fundamentally related to the ZSR.\nDefinition: The network function is the ratio of the ZSR output in the sss-domain to the ZSR input in the sss-domain. H(s)=Output Variable(s)Input Variable(s)H(s) = \\frac{\\text{Output Variable}(s)}{\\text{Input Variable}(s)}H(s)=Input Variable(s)Output Variable(s)​ Requirement: Network functions are found by explicitly setting all initial condition sources to zero. Time Domain Connection: If the input is Vin(s)V_{in}(s)Vin​(s), the output ZSR is calculated as Vout(s)=H(s)⋅Vin(s)V_{out}(s) = H(s) \\cdot V_{in}(s)Vout​(s)=H(s)⋅Vin​(s). Types: Transfer Function (H(s)H(s)H(s) or T(s)T(s)T(s)): Input and output are at two different terminal pairs. Driving-Point Impedance (Z(s)Z(s)Z(s)): Ratio of voltage to current (V/IV/IV/I) measured at the same terminal pair. Driving-Point Admittance (Y(s)Y(s)Y(s)): Ratio of current to voltage (I/VI/VI/V) measured at the same terminal pair; Y(s)=1/Z(s)Y(s) = 1/Z(s)Y(s)=1/Z(s). II. Poles and Zeros Explained The network function H(s)H(s)H(s) is expressed as a rational function, which means the numerator and the denominator are polynomials of sss.\nH(s)=N(s)D(s)H(s) = \\frac{N(s)}{D(s)}H(s)=D(s)N(s)​A. What are Poles? Definition: The poles of the circuit (also known as natural frequencies) are the roots of the characteristic polynomial, which is the denominator of the network function, D(s)=0D(s)=0D(s)=0. S-Domain Context: Poles are locations on the sss-plane where the network function H(s)H(s)H(s) approaches infinity. Time Domain/Diffeq Context: Natural Response: Poles determine the modes of the circuit, which make up the natural response. Each distinct pole corresponds to an exponential term in the time domain solution. Differential Equation: Poles are determined by the output side (left side) of the differential equation after cross-multiplication. Input Interaction: Poles determine which exponentials are always in the output, even if they are not in the input. If the input frequency is the same as a pole frequency, the order of the pole in the output increases, leading to terms like t⋅es0tt \\cdot e^{s_0 t}t⋅es0​t. Waveform: Real poles (s=−αs = -\\alphas=−α): Lead to decaying exponentials (ke−αtk e^{-\\alpha t}ke−αt). Complex-conjugate poles (s=−α±jωds = -\\alpha \\pm j\\omega_ds=−α±jωd​): Lead to exponentially decaying sinusoids. B. What are Zeros? Definition: The zeros of the circuit are the roots of the numerator of the network function, N(s)=0N(s)=0N(s)=0. S-Domain Context: Zeros are locations on the sss-plane where the network function H(s)H(s)H(s) approaches zero. Time Domain/Diffeq Context: Signal Blocking: Zeros determine the rates of exponentials that are never in the output. An exponential input at the frequency of a zero will be blocked and will never appear in the circuit output. Differential Equation: Zeros are determined by the input side (right side) of the differential equation. III. Step-by-Step Guide for Poles and Zeros using Network Functions The general process involves transforming the circuit into the sss-domain, deriving the network function H(s)H(s)H(s), and finding the roots of its constituent polynomials.\nStep-by-Step Process to Calculate H(s)H(s)H(s) Transform the Circuit to sss-Domain (Impedances): Convert all reactive elements to their sss-domain impedances, Z(s)Z(s)Z(s): Resistors (RRR) become RRR. Capacitors (CCC) become ZC=1/(sC)Z_C = 1/(sC)ZC​=1/(sC). Inductors (LLL) become ZL=sLZ_L = sLZL​=sL. Zero Initial Conditions: To find H(s)H(s)H(s) (the network function), treat all initial condition sources (like Vc(0)/sV_c(0)/sVc​(0)/s or LiL(0)L i_L(0)LiL​(0)) as zero (voltage sources become short circuits; current sources become open circuits). Define H(s)H(s)H(s): Define the desired output Vout(s)V_{out}(s)Vout​(s) or Iout(s)I_{out}(s)Iout​(s) and the input Vin(s)V_{in}(s)Vin​(s) or Iin(s)I_{in}(s)Iin​(s). Solve using sss-Domain Circuit Techniques: Use standard resistive circuit analysis techniques (KCL, KVL, nodal analysis, mesh analysis, voltage/current dividers) to find the ratio H(s)=OutputInputH(s) = \\frac{\\text{Output}}{\\text{Input}}H(s)=InputOutput​. Express H(s)H(s)H(s) as a Rational Function: Simplify the expression into the proper rational function form: H(s)=N(s)D(s)=amsm+am−1sm−1+⋯+a0bnsn+bn−1sn−1+⋯+b0H(s) = \\frac{N(s)}{D(s)} = \\frac{a_m s^m + a_{m-1} s^{m-1} + \\dots + a_0}{b_n s^n + b_{n-1} s^{n-1} + \\dots + b_0}H(s)=D(s)N(s)​=bn​sn+bn−1​sn−1+⋯+b0​am​sm+am−1​sm−1+⋯+a0​​ Step-by-Step Process to Find Poles and Zeros Identify the Numerator N(s)N(s)N(s) and Denominator D(s)D(s)D(s) of the network function H(s)H(s)H(s). Find Zeros: Set the numerator equal to zero and solve for sss: N(s)=0→Roots are the ZerosN(s) = 0 \\quad \\rightarrow \\quad \\text{Roots are the Zeros}N(s)=0→Roots are the Zeros Find Poles: Set the denominator equal to zero and solve for sss. These are the roots of the characteristic equation: D(s)=0→Roots are the PolesD(s) = 0 \\quad \\rightarrow \\quad \\text{Roots are the Poles}D(s)=0→Roots are the Poles Plot (Optional): Plot the poles and zeros on the complex sss-plane (pole-zero diagram). IV. Differential Equations from Circuits and Network Functions The Laplace Transform (LT) is used to convert differential equations (ODEs) from the time domain into easier-to-solve partial fraction expressions (linear equations) in the sss-domain. Conversely, you can derive the differential equation directly from H(s)H(s)H(s).\nA. Creating the Differential Equation from a Circuit This follows the standard circuit analysis process in the time domain:\nDevelop Differential Equation(s): Use circuit analysis techniques (KCL/KVL) on the time-domain circuit to relate the input variable to the output variable, which will typically involve derivatives of voltage or current due to capacitors (ic=Cdvcdti_c = C \\frac{dv_c}{dt}ic​=Cdtdvc​​) and inductors. Solve (via LT): Transform the equation into the sss-domain, solve for the variable of interest, and then perform the inverse transform to get the time-domain waveform. B. Creating the Differential Equation from H(s)H(s)H(s) A much simpler method to obtain the input-output differential equation (ODE) is to use the network function H(s)H(s)H(s).\nStep-by-Step Process:\nStart with H(s)H(s)H(s): Assume the network function is in the rational polynomial form relating output Vout(s)V_{out}(s)Vout​(s) and input Vin(s)V_{in}(s)Vin​(s): H(s)=Vout(s)Vin(s)=N(s)D(s)H(s) = \\frac{V_{out}(s)}{V_{in}(s)} = \\frac{N(s)}{D(s)}H(s)=Vin​(s)Vout​(s)​=D(s)N(s)​ Cross-Multiply: Cross-multiply the terms: Vout(s)⋅D(s)=Vin(s)⋅N(s)V_{out}(s) \\cdot D(s) = V_{in}(s) \\cdot N(s)Vout​(s)⋅D(s)=Vin​(s)⋅N(s) Substitute Derivatives: Interpret sss as the differential operator ddt\\frac{d}{dt}dtd​: sVout(s)→ddtvout(t)s V_{out}(s) \\rightarrow \\frac{d}{dt} v_{out}(t)sVout​(s)→dtd​vout​(t) s2Vout(s)→d2dt2vout(t)s^2 V_{out}(s) \\rightarrow \\frac{d^2}{dt^2} v_{out}(t)s2Vout​(s)→dt2d2​vout​(t) Write ODE: Apply the inverse LT to the resulting expression. Since H(s)H(s)H(s) only describes the ZSR, this transformation relies on setting initial conditions to zero. (bndndtn+⋯+b0)vout(t)=(amdmdtm+⋯+a0)vin(t)\\left(b_n \\frac{d^n}{dt^n} + \\dots + b_0 \\right) v_{out}(t) = \\left(a_m \\frac{d^m}{dt^m} + \\dots + a_0 \\right) v_{in}(t)(bn​dtndn​+⋯+b0​)vout​(t)=(am​dtmdm​+⋯+a0​)vin​(t)Poles and Zeros Link to Diffeq: The coefficients of D(s)D(s)D(s) (the poles) become the coefficients of the terms involving the output variable and its derivatives on the left side of the ODE, while the coefficients of N(s)N(s)N(s) (the zeros) become the coefficients of the terms involving the input variable and its derivatives on the right side of the ODE.\nV. Poles and Zeros in Time-Domain Response (Inverse Laplace Transform) When converting the sss-domain output Vout(s)V_{out}(s)Vout​(s) back to the time domain vout(t)v_{out}(t)vout​(t) using the Inverse Laplace Transform (ILT), the final waveform is dictated by the poles of the overall function, Vout(s)=H(s)⋅Vin(s)V_{out}(s) = H(s) \\cdot V_{in}(s)Vout​(s)=H(s)⋅Vin​(s). The output waveform is the sum of the forced response and the natural response.\nA. Forced Response (Input Poles) The forced response relates to the poles contributed by the input signal, Vin(s)V_{in}(s)Vin​(s).\nIf the input is an exponential vin(t)=Kies0tu(t)v_{in}(t) = K_i e^{s_0 t} u(t)vin​(t)=Ki​es0​tu(t), the resulting forced response term in the output is also Kfes0tK_f e^{s_0 t}Kf​es0​t. The magnitude KfK_fKf​ is calculated using the cover-up method (PFE residue) but is equivalent to evaluating H(s)H(s)H(s) at the input pole frequency, s0s_0s0​: the amplitude is scaled by H(s0)H(s_0)H(s0​). B. Natural Response (Network Function Poles) The natural response relates to the poles contributed by the network function, H(s)H(s)H(s).\nThe natural response components, such as kiepitk_i e^{p_i t}ki​epi​t, are determined by the locations of the poles pip_ipi​ of H(s)H(s)H(s). This response is characteristic of the device elements (R, L, C) and is independent of the specific external source (it exists even in the ZIR case). Step-by-Step Process for ILT and Time Response Find Output in sss-Domain: Calculate Vout(s)=H(s)⋅Vin(s)V_{out}(s) = H(s) \\cdot V_{in}(s)Vout​(s)=H(s)⋅Vin​(s). Factor: Factor the denominator of Vout(s)V_{out}(s)Vout​(s) completely to find all pole locations (pip_ipi​). These include poles from H(s)H(s)H(s) and poles from Vin(s)V_{in}(s)Vin​(s). Partial Fraction Expansion (PFE): Decompose Vout(s)V_{out}(s)Vout​(s) into a sum of simple terms corresponding to each distinct pole. Vout(s)=k0s−s0+k1s−p1+…V_{out}(s) = \\frac{k_0}{s - s_0} + \\frac{k_1}{s - p_1} + \\dotsVout​(s)=s−s0​k0​​+s−p1​k1​​+… Find Residues (kik_iki​): Use the Cover-Up Method to find the residue kik_iki​ associated with each pole pip_ipi​. For a simple pole pip_ipi​: ki=(s−pi)Vout(s)∣s=pik_i = \\left. (s - p_i) V_{out}(s) \\right|_{s=p_i}ki​=(s−pi​)Vout​(s)∣s=pi​​ (If the poles are complex-conjugates, the residues kik_iki​ will also be conjugate pairs). (If there are multiple-order poles, special techniques like matching coefficients or the nnn-to-1-order pole method are required for residues). Inverse Transform: Use the inverse LT properties to transform the PFE back to the time domain, vout(t)v_{out}(t)vout​(t). Each simple term kis−pi\\frac{k_i}{s - p_i}s−pi​ki​​ transforms to kiepitu(t)k_i e^{p_i t} u(t)ki​epi​tu(t). Result: The terms corresponding to the poles of H(s)H(s)H(s) form the natural response, and the terms corresponding to the poles of Vin(s)V_{in}(s)Vin​(s) form the forced response. so how do i keep track of ZSR input vs output, ZIR input vs output, and using this for network funcitons and other things?\nThe process of analyzing circuits using the Laplace Transform (LT) hinges on separating the total response into the Zero-Input Response (ZIR) and the Zero-State Response (ZSR) using superposition. This separation is crucial for defining and utilizing the Network Function, H(s)H(s)H(s).\nHere is how you keep track of ZSR input versus output, ZIR input versus output, and how these relate to network functions.\n1. Zero-State Response (ZSR) Tracking The Zero-State Response (ZSR) is the component of the total response caused by external input sources when the circuit starts from a “zero state,” meaning zero initial stored energy.\nZSR Input vs. Output Tracking Parameter Definition/Input Output/Response Input (Cause) External Sources: Vin(s)V_{in}(s)Vin​(s) or Iin(s)I_{in}(s)Iin​(s). This is the actual source driving the circuit (e.g., a voltage source Vs(t)V_s(t)Vs​(t) or current source Is(t)I_s(t)Is​(t)) transformed into the sss-domain. ZSR Output: Vout,ZSR(s)V_{out, ZSR}(s)Vout,ZSR​(s) or Iout,ZSR(s)I_{out, ZSR}(s)Iout,ZSR​(s). This is the part of the total response resulting only from the input. Circuit State All initial conditions (stored energy) are set to zero (capacitors act as short circuits for voltage sources Vc(0)/sV_c(0)/sVc​(0)/s, inductors act as open circuits for current sources LiL(0)L i_L(0)LiL​(0)). The ZSR is calculated using the input source and the component impedances (RRR, sLsLsL, 1/sC1/sC1/sC). Relationship The output is the result of applying Vin(s)V_{in}(s)Vin​(s) through the system defined by H(s)H(s)H(s): OutputZSR(s)=H(s)⋅InputZSR(s) \\mathbf{\\text{Output}_{ZSR}(s) = H(s) \\cdot \\text{Input}_{ZSR}(s)} OutputZSR​(s)=H(s)⋅InputZSR​(s) The ZSR input is any waveform (step, exponential, sinusoid) that is applied at time t≥0t \\ge 0t≥0, assuming that before t\u003c0t\u003c0t\u003c0, no energy was stored in the network.\n2. Zero-Input Response (ZIR) Tracking The Zero-Input Response (ZIR) is the component of the total response caused by stored energy (initial conditions) when the external input sources are zeroed.\nZIR Input vs. Output Tracking Parameter Definition/Input Output/Response Input (Cause) Initial Condition Sources: These are sss-domain sources inserted into the circuit model to represent stored energy. For a capacitor, this might be a voltage source of Vc(0)/sV_c(0)/sVc​(0)/s in series with 1/(sC)1/(sC)1/(sC). For an inductor, this might be a voltage source of LiL(0)L i_L(0)LiL​(0) in series with sLsLsL. ZIR Output: Vout,ZIR(s)V_{out, ZIR}(s)Vout,ZIR​(s) or Iout,ZIR(s)I_{out, ZIR}(s)Iout,ZIR​(s). Circuit State All external voltage sources are replaced by short circuits, and all external current sources are replaced by open circuits. The ZIR is calculated using the initial condition sources and the component impedances (RRR, sLsLsL, 1/sC1/sC1/sC). Relationship The ZIR is composed entirely of the natural response of the circuit, determined by the circuit’s poles. 3. The Role of the Network Function H(s)H(s)H(s) The network function H(s)H(s)H(s) acts as the bridge that connects the ZSR input and output, but it does not account for the ZIR.\nNetwork Function Calculation Requirement: H(s)H(s)H(s) is strictly the ratio of the ZSR output to the ZSR input in the sss-domain. Procedure: To find H(s)H(s)H(s), you must explicitly set all initial condition sources to zero. Inputs and Outputs: If H(s)H(s)H(s) is a Transfer Function (T(s)), the input and output are at two different terminal pairs (ports). If H(s)H(s)H(s) is a Driving-Point Impedance (Z(s)=V(s)/I(s)Z(s) = V(s)/I(s)Z(s)=V(s)/I(s)) or Admittance (Y(s)=I(s)/V(s)Y(s) = I(s)/V(s)Y(s)=I(s)/V(s)), the input and output are measured at the same terminal pair. Using H(s)H(s)H(s) for Total Response The total response Vout(s)V_{out}(s)Vout​(s) is the sum of the calculated ZSR and ZIR components: Vout(s)=Vout,ZSR(s)+Vout,ZIR(s)V_{out}(s) = V_{out, ZSR}(s) + V_{out, ZIR}(s)Vout​(s)=Vout,ZSR​(s)+Vout,ZIR​(s) where: Vout,ZSR(s)=H(s)⋅Vin(s)V_{out, ZSR}(s) = H(s) \\cdot V_{in}(s)Vout,ZSR​(s)=H(s)⋅Vin​(s)This Vout(s)V_{out}(s)Vout​(s) is then transformed back into the time domain vout(t)v_{out}(t)vout​(t) using the Inverse Laplace Transform. The poles of Vout(s)V_{out}(s)Vout​(s) determine the partial fraction expansion terms and thus the final time-domain waveform.\n4. Relationship Between H(s)H(s)H(s) and Differential Equations (Diffeq) The structure of the network function directly dictates the form of the input-output differential equation (ODE) of the circuit.\nPoles (Denominator D(s)D(s)D(s)) →\\rightarrow→ Output (ZIR/Natural Response) Diffeq Side: The coefficients of the characteristic polynomial D(s)D(s)D(s) correspond to the coefficients of the output variable and its derivatives on the left side of the ODE. Response Link: Poles determine the exponents (rates) of the terms that form the natural response (and thus the ZIR). Poles are the rates of exponentials that are “always” in the output. Zeros (Numerator N(s)N(s)N(s)) →\\rightarrow→ Input (ZSR/Forced Response Interaction) Diffeq Side: The coefficients of the numerator polynomial N(s)N(s)N(s) correspond to the coefficients of the input variable and its derivatives on the right side of the ODE. Response Link: Zeros determine the frequencies (rates) of exponentials that are never in the output. If an exponential input occurs at the frequency of a circuit zero, that signal is blocked or vanishes in the output (provided the input pole is not of a higher order than the circuit zero).","zir-input-vs-output-tracking#ZIR Input vs. Output Tracking":"","zsr-input-vs-output-tracking#ZSR Input vs. Output Tracking":""},"title":"quiz_zeros_poles_nblm"},"/electrical_notes/ee_300/time_to_s_to_diffeq_to_laplace/":{"data":{"":"Comprehensive Guide: Time Domain to s-Domain Circuit ConversionTable of Contents Overview and Order of Operations The Standard Problem Progression Component Transformation Equations Step 1: Time Domain Circuit to s-Domain Circuit Step 2: Apply KVL/KCL to s-Domain Circuit Step 3: Derive Differential Equations from s-Domain Step 4: Setup for Laplace Transform Alternative Path: Differential Equation First Working Backwards: Inverse Operations Complete Worked Examples Tips and Tricks Common Pitfalls Overview and Order of Operations This guide covers TWO distinct paths for circuit analysis using Laplace transforms. Understanding the order is critical:\nPATH A: Direct s-Domain Transformation (Most Common in Exams) graph TD A[Step 1: Time Domain Circuit] --\u003e B[Step 2: Convert to s-Domain Circuit] B --\u003e C[Step 3: Apply KVL/KCL in s-Domain] C --\u003e D[Step 4: s-Domain Algebraic Equation] D --\u003e E[Step 5: Solve for V_s or I_s] E --\u003e F[Step 6: Apply Inverse Laplace Transform] F --\u003e G[Step 7: Time Domain Solution v_t or i_t] style A fill:#ffebee style B fill:#fff3e0 style C fill:#e1f5ff style D fill:#e8f5e9 style E fill:#f3e5f5 style F fill:#fff9c4 style G fill:#c8e6c9 Key Point: This path goes directly to s-domain, then applies circuit laws. You get an algebraic equation in sss, NOT a differential equation.\nPATH B: Differential Equation First (Alternative Method) graph TD A[Step 1: Time Domain Circuit] --\u003e B[Step 2: Apply KVL/KCL in Time Domain] B --\u003e C[Step 3: Substitute Component Equations] C --\u003e D[Step 4: Derive Differential Equation] D --\u003e E[Step 5: Apply Laplace Transform] E --\u003e F[Step 6: s-Domain Algebraic Equation] F --\u003e G[Step 7: Solve for V_s or I_s] G --\u003e H[Step 8: Apply Inverse Laplace Transform] H --\u003e I[Step 9: Time Domain Solution] style A fill:#ffebee style D fill:#ffe0b2 style E fill:#fff9c4 style I fill:#c8e6c9 Key Point: This path derives a differential equation in time domain FIRST, then transforms it.\nThe Standard Problem Progression Based on your description, here is the typical exam question format:\nProblem Format Given:\nTime domain circuit diagram Component values (R, L, C) Source functions vs(t)v_s(t)vs​(t) or is(t)i_s(t)is​(t) Part 1: Convert to s-Domain\nTransform all components to s-domain equivalents Draw the s-domain circuit diagram Part 2: Find Equation Using s-Domain Circuit\nApply KVL or KCL to the s-domain circuit Obtain algebraic equation in terms of sss Part 3: Initial Conditions Given\nYou are NOW given: vC(0)v_C(0)vC​(0), iL(0)i_L(0)iL​(0), etc. Incorporate these into your s-domain equation Solve for V(s)V(s)V(s) or I(s)I(s)I(s) Part 4: Inverse Transform\nApply inverse Laplace transform Find v(t)v(t)v(t) or i(t)i(t)i(t) Critical Clarification on “Differential Equations” IMPORTANT: When you go Time Domain → s-Domain Circuit → KVL/KCL, you get an ALGEBRAIC equation in sss, NOT a differential equation.\nYou only get a differential equation if you:\nStart in time domain and apply KVL/KCL there (PATH B), OR Take your s-domain algebraic equation and inverse transform it back (which is backwards) The confusion: In PATH A, you can think of the s-domain algebraic equation as the “Laplace transform of the differential equation,” but you never explicitly write the differential equation.\nComponent Transformation Equations Complete Time Domain to s-Domain Table Component Time Domain s-Domain Impedance Z(s) Initial Condition (when given later) Resistor vR(t)=R⋅i(t)v_R(t) = R \\cdot i(t)vR​(t)=R⋅i(t) ZR=RZ_R = RZR​=R None Capacitor iC(t)=CdvC(t)dti_C(t) = C \\frac{dv_C(t)}{dt}iC​(t)=CdtdvC​(t)​ ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​ Add voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ in series Inductor vL(t)=LdiL(t)dtv_L(t) = L \\frac{di_L(t)}{dt}vL​(t)=LdtdiL​(t)​ ZL=sLZ_L = sLZL​=sL Add voltage source LiL(0)Li_L(0)LiL​(0) in series OR current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​ in parallel Voltage Source vs(t)v_s(t)vs​(t) N/A Vs(s)=L{vs(t)}V_s(s) = \\mathcal{L}\\{v_s(t)\\}Vs​(s)=L{vs​(t)} Current Source is(t)i_s(t)is​(t) N/A Is(s)=L{is(t)}I_s(s) = \\mathcal{L}\\{i_s(t)\\}Is​(s)=L{is​(t)} Key Time-Domain Component Equations Resistor vR(t)=R⋅iR(t)v_R(t) = R \\cdot i_R(t)vR​(t)=R⋅iR​(t) iR(t)=vR(t)Ri_R(t) = \\frac{v_R(t)}{R}iR​(t)=RvR​(t)​Capacitor iC(t)=CdvC(t)dti_C(t) = C \\frac{dv_C(t)}{dt}iC​(t)=CdtdvC​(t)​ vC(t)=1C∫0tiC(τ)dτ+vC(0)v_C(t) = \\frac{1}{C}\\int_{0}^{t} i_C(\\tau)d\\tau + v_C(0)vC​(t)=C1​∫0t​iC​(τ)dτ+vC​(0)Inductor vL(t)=LdiL(t)dtv_L(t) = L \\frac{di_L(t)}{dt}vL​(t)=LdtdiL​(t)​ iL(t)=1L∫0tvL(τ)dτ+iL(0)i_L(t) = \\frac{1}{L}\\int_{0}^{t} v_L(\\tau)d\\tau + i_L(0)iL​(t)=L1​∫0t​vL​(τ)dτ+iL​(0) Step 1: Time Domain Circuit to s-Domain Circuit Transformation Process graph TD A[Time Domain Circuit for t \\geq 0] --\u003e B[Identify all components] B --\u003e C[Transform Resistors: R → R] B --\u003e D[Transform Capacitors: C → 1/sC] B --\u003e E[Transform Inductors: L → sL] B --\u003e F[Transform Sources: v_s_t → V_s_s] C --\u003e G[Draw s-Domain Circuit] D --\u003e G E --\u003e G F --\u003e G G --\u003e H[Note: Initial conditionsNOT included yet] style A fill:#ffebee style G fill:#e8f5e9 style H fill:#fff3e0 Detailed Transformation Rules Rule 1: Resistor Transformation Time Domain: Resistor with value RRR ohms\ns-Domain: Same resistor with value RRR ohms\nZR(s)=RZ_R(s) = RZR​(s)=RRule 2: Capacitor Transformation Time Domain: Capacitor with value CCC farads\ns-Domain: Impedance 1sC\\frac{1}{sC}sC1​\nZC(s)=1sCZ_C(s) = \\frac{1}{sC}ZC​(s)=sC1​Circuit Representation (without initial conditions): Just the impedance 1sC\\frac{1}{sC}sC1​\nCircuit Representation (with initial conditions, added later):\nImpedance 1sC\\frac{1}{sC}sC1​ in series with voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ Rule 3: Inductor Transformation Time Domain: Inductor with value LLL henries\ns-Domain: Impedance sLsLsL\nZL(s)=sLZ_L(s) = sLZL​(s)=sLCircuit Representation (without initial conditions): Just the impedance sLsLsL\nCircuit Representation (with initial conditions, added later):\nOption A (for KVL/Mesh): Impedance sLsLsL in series with voltage source LiL(0)Li_L(0)LiL​(0) Option B (for KCL/Node): Impedance sLsLsL in parallel with current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​ Rule 4: Voltage Source Transformation Time Domain: vs(t)v_s(t)vs​(t)\ns-Domain: Vs(s)=L{vs(t)}V_s(s) = \\mathcal{L}\\{v_s(t)\\}Vs​(s)=L{vs​(t)}\nCommon transforms:\nStep function: V0u(t)→V0sV_0 u(t) \\rightarrow \\frac{V_0}{s}V0​u(t)→sV0​​ Exponential: V0e−atu(t)→V0s+aV_0 e^{-at}u(t) \\rightarrow \\frac{V_0}{s+a}V0​e−atu(t)→s+aV0​​ Sine: V0sin⁡(ωt)u(t)→V0ωs2+ω2V_0 \\sin(\\omega t)u(t) \\rightarrow \\frac{V_0\\omega}{s^2+\\omega^2}V0​sin(ωt)u(t)→s2+ω2V0​ω​ Cosine: V0cos⁡(ωt)u(t)→V0ss2+ω2V_0 \\cos(\\omega t)u(t) \\rightarrow \\frac{V_0 s}{s^2+\\omega^2}V0​cos(ωt)u(t)→s2+ω2V0​s​ Rule 5: Current Source Transformation Time Domain: is(t)i_s(t)is​(t)\ns-Domain: Is(s)=L{is(t)}I_s(s) = \\mathcal{L}\\{i_s(t)\\}Is​(s)=L{is​(t)}\n(Same transform pairs as voltage sources)\nExample: Series RLC Circuit Transformation Time Domain Circuit:\nv_s(t) ---[ R ]---[ L ]---[ C ]--- ground s-Domain Circuit (without initial conditions):\nV_s(s) ---[ R ]---[ sL ]---[ 1/sC ]--- ground s-Domain Circuit (with initial conditions added later):\nV_s(s) ---[ R ]---[ sL ]---[+]---[ 1/sC ]---[+]--- ground [Li_L(0)] [v_C(0)/s] Where [+] indicates voltage source polarity.\nStep 2: Apply KVL/KCL to s-Domain Circuit Using Kirchhoff’s Laws in s-Domain graph TD A[s-Domain Circuit] --\u003e B{What are you solving for?} B --\u003e|Voltage orSeries Circuit| C[Use KVL] B --\u003e|Current orParallel Circuit| D[Use KCL] C --\u003e E[Sum voltages around loop = 0] D --\u003e F[Sum currents at node = 0] E --\u003e G[s-Domain Algebraic Equation] F --\u003e G style G fill:#e8f5e9 KVL in s-Domain (Mesh/Loop Analysis) Kirchhoff’s Voltage Law: Sum of voltages around any closed loop equals zero.\n∑Vsources(s)−∑Vdrops(s)=0\\sum V_{sources}(s) - \\sum V_{drops}(s) = 0∑Vsources​(s)−∑Vdrops​(s)=0Voltage drops across impedances: Vdrop(s)=I(s)⋅Z(s)V_{drop}(s) = I(s) \\cdot Z(s)Vdrop​(s)=I(s)⋅Z(s)General KVL Equation: Vs(s)=I(s)⋅Z1(s)+I(s)⋅Z2(s)+⋯+I(s)⋅Zn(s)+Vinitial(s)V_s(s) = I(s) \\cdot Z_1(s) + I(s) \\cdot Z_2(s) + \\cdots + I(s) \\cdot Z_n(s) + V_{initial}(s)Vs​(s)=I(s)⋅Z1​(s)+I(s)⋅Z2​(s)+⋯+I(s)⋅Zn​(s)+Vinitial​(s)Where Vinitial(s)V_{initial}(s)Vinitial​(s) represents initial condition voltage sources (when added).\nKCL in s-Domain (Node Analysis) Kirchhoff’s Current Law: Sum of currents entering a node equals sum of currents leaving.\n∑Ientering(s)=∑Ileaving(s)\\sum I_{entering}(s) = \\sum I_{leaving}(s)∑Ientering​(s)=∑Ileaving​(s)Current through impedance: I(s)=V(s)Z(s)I(s) = \\frac{V(s)}{Z(s)}I(s)=Z(s)V(s)​General KCL Equation at a node: Is(s)+Iinitial(s)=Vnode(s)Z1(s)+Vnode(s)Z2(s)+⋯I_s(s) + I_{initial}(s) = \\frac{V_{node}(s)}{Z_1(s)} + \\frac{V_{node}(s)}{Z_2(s)} + \\cdotsIs​(s)+Iinitial​(s)=Z1​(s)Vnode​(s)​+Z2​(s)Vnode​(s)​+⋯Where Iinitial(s)I_{initial}(s)Iinitial​(s) represents initial condition current sources (when added).\nExample: Series RLC Circuit - KVL Application s-Domain Circuit:\nV_s(s) ---[ R ]---[ sL ]---[ 1/sC ]--- ground Current I(s) flows clockwise Apply KVL (going clockwise): Vs(s)−VR(s)−VL(s)−VC(s)=0V_s(s) - V_R(s) - V_L(s) - V_C(s) = 0Vs​(s)−VR​(s)−VL​(s)−VC​(s)=0Substitute Ohm’s Law in s-Domain: Vs(s)−I(s)⋅R−I(s)⋅sL−I(s)⋅1sC=0V_s(s) - I(s) \\cdot R - I(s) \\cdot sL - I(s) \\cdot \\frac{1}{sC} = 0Vs​(s)−I(s)⋅R−I(s)⋅sL−I(s)⋅sC1​=0Algebraic equation in s: Vs(s)=I(s)[R+sL+1sC]V_s(s) = I(s) \\left[ R + sL + \\frac{1}{sC} \\right]Vs​(s)=I(s)[R+sL+sC1​]This is an algebraic equation, NOT a differential equation.\nExample: Parallel RLC Circuit - KCL Application s-Domain Circuit:\nI_s(s) | +----+----+----+ | | | | R sL 1/sC ground Apply KCL at top node (voltage V(s) across all elements): Is(s)=IR(s)+IL(s)+IC(s)I_s(s) = I_R(s) + I_L(s) + I_C(s)Is​(s)=IR​(s)+IL​(s)+IC​(s)Substitute: Is(s)=V(s)R+V(s)sL+V(s)⋅sCI_s(s) = \\frac{V(s)}{R} + \\frac{V(s)}{sL} + V(s) \\cdot sCIs​(s)=RV(s)​+sLV(s)​+V(s)⋅sCAlgebraic equation in s: Is(s)=V(s)[1R+1sL+sC]I_s(s) = V(s) \\left[ \\frac{1}{R} + \\frac{1}{sL} + sC \\right]Is​(s)=V(s)[R1​+sL1​+sC] Step 3: Derive Differential Equations from s-Domain IMPORTANT CLARIFICATION When you follow PATH A (Time → s-Domain → KVL/KCL), you get an algebraic equation in sss, not a differential equation.\nHowever, you may be asked to “find the differential equation” which means: What time-domain differential equation corresponds to this s-domain equation?\nConverting s-Domain Equation to Differential Equation This is the INVERSE process, used to understand what differential equation you would have gotten if you had used PATH B.\ngraph LR A[s-Domain Algebraic Equation] --\u003e B[Apply Inverse Correspondence] B --\u003e C[Time-Domain Differential Equation] style A fill:#e8f5e9 style C fill:#ffe0b2 Inverse Laplace Correspondence Rules These rules work backwards from the Laplace transform properties:\ns-Domain Term Time-Domain Equivalent V(s)V(s)V(s) or I(s)I(s)I(s) v(t)v(t)v(t) or i(t)i(t)i(t) s⋅V(s)s \\cdot V(s)s⋅V(s) dv(t)dt\\frac{dv(t)}{dt}dtdv(t)​ (plus initial condition) s2⋅V(s)s^2 \\cdot V(s)s2⋅V(s) d2v(t)dt2\\frac{d^2v(t)}{dt^2}dt2d2v(t)​ (plus initial conditions) V(s)s\\frac{V(s)}{s}sV(s)​ ∫0tv(τ)dτ\\int_0^t v(\\tau)d\\tau∫0t​v(τ)dτ Vs(s)V_s(s)Vs​(s) vs(t)v_s(t)vs​(t) Constant CCC Constant CCC Detailed Correspondence Rules Rule 1: Basic Substitution V(s)→v(t)V(s) \\rightarrow v(t)V(s)→v(t) I(s)→i(t)I(s) \\rightarrow i(t)I(s)→i(t)Rule 2: Multiplication by sss (First Derivative) s⋅V(s)→dv(t)dt+v(0+)s \\cdot V(s) \\rightarrow \\frac{dv(t)}{dt} + v(0^+)s⋅V(s)→dtdv(t)​+v(0+)However: If initial conditions are already incorporated as sources in the s-domain circuit, then: s⋅V(s)→dv(t)dts \\cdot V(s) \\rightarrow \\frac{dv(t)}{dt}s⋅V(s)→dtdv(t)​And the initial condition term appears separately.\nRule 3: Multiplication by s2s^2s2 (Second Derivative) s2⋅V(s)→d2v(t)dt2+s⋅v(0+)+dv(0+)dts^2 \\cdot V(s) \\rightarrow \\frac{d^2v(t)}{dt^2} + s \\cdot v(0^+) + \\frac{dv(0^+)}{dt}s2⋅V(s)→dt2d2v(t)​+s⋅v(0+)+dtdv(0+)​With initial conditions incorporated: s2⋅V(s)→d2v(t)dt2s^2 \\cdot V(s) \\rightarrow \\frac{d^2v(t)}{dt^2}s2⋅V(s)→dt2d2v(t)​Rule 4: Division by sss (Integration) V(s)s→∫0tv(τ)dτ\\frac{V(s)}{s} \\rightarrow \\int_0^t v(\\tau)d\\tausV(s)​→∫0t​v(τ)dτExample: Converting s-Domain to Differential Equation Given s-Domain Equation (from Series RLC): Vs(s)=I(s)[R+sL+1sC]V_s(s) = I(s) \\left[ R + sL + \\frac{1}{sC} \\right]Vs​(s)=I(s)[R+sL+sC1​]Step 1: Expand Vs(s)=R⋅I(s)+sL⋅I(s)+I(s)sCV_s(s) = R \\cdot I(s) + sL \\cdot I(s) + \\frac{I(s)}{sC}Vs​(s)=R⋅I(s)+sL⋅I(s)+sCI(s)​Step 2: Multiply through by sCsCsC sC⋅Vs(s)=sRC⋅I(s)+s2LC⋅I(s)+I(s)sC \\cdot V_s(s) = sRC \\cdot I(s) + s^2LC \\cdot I(s) + I(s)sC⋅Vs​(s)=sRC⋅I(s)+s2LC⋅I(s)+I(s)Step 3: Apply inverse correspondence\nsC⋅Vs(s)→Cdvs(t)dtsC \\cdot V_s(s) \\rightarrow C\\frac{dv_s(t)}{dt}sC⋅Vs​(s)→Cdtdvs​(t)​ sRC⋅I(s)→RCdi(t)dtsRC \\cdot I(s) \\rightarrow RC\\frac{di(t)}{dt}sRC⋅I(s)→RCdtdi(t)​ s2LC⋅I(s)→LCd2i(t)dt2s^2LC \\cdot I(s) \\rightarrow LC\\frac{d^2i(t)}{dt^2}s2LC⋅I(s)→LCdt2d2i(t)​ I(s)→i(t)I(s) \\rightarrow i(t)I(s)→i(t) Resulting Differential Equation: Cdvs(t)dt=RCdi(t)dt+LCd2i(t)dt2+i(t)C\\frac{dv_s(t)}{dt} = RC\\frac{di(t)}{dt} + LC\\frac{d^2i(t)}{dt^2} + i(t)Cdtdvs​(t)​=RCdtdi(t)​+LCdt2d2i(t)​+i(t)Or rearranged: LCd2i(t)dt2+RCdi(t)dt+i(t)=Cdvs(t)dtLC\\frac{d^2i(t)}{dt^2} + RC\\frac{di(t)}{dt} + i(t) = C\\frac{dv_s(t)}{dt}LCdt2d2i(t)​+RCdtdi(t)​+i(t)=Cdtdvs​(t)​This is a second-order differential equation.\nStep 4: Setup for Laplace Transform At this point, you have either:\nOption A: s-Domain Algebraic Equation (from PATH A) You already have: An equation like Vs(s)=I(s)⋅Ztotal(s)V_s(s) = I(s) \\cdot Z_{total}(s)Vs​(s)=I(s)⋅Ztotal​(s)\nTo solve:\nAdd initial condition sources (if not already included) Algebraically solve for I(s)I(s)I(s) or V(s)V(s)V(s) You now have I(s)=Vs(s)Ztotal(s)I(s) = \\frac{V_s(s)}{Z_{total}(s)}I(s)=Ztotal​(s)Vs​(s)​ plus initial condition terms Next step: Apply Inverse Laplace Transform to get i(t)i(t)i(t) or v(t)v(t)v(t)\nYou would perform Inverse Laplace Transform from here.\nOption B: Time-Domain Differential Equation (from PATH B) You have: A differential equation like: LCd2i(t)dt2+RCdi(t)dt+i(t)=Cdvs(t)dtLC\\frac{d^2i(t)}{dt^2} + RC\\frac{di(t)}{dt} + i(t) = C\\frac{dv_s(t)}{dt}LCdt2d2i(t)​+RCdtdi(t)​+i(t)=Cdtdvs​(t)​To solve:\nApply Laplace Transform to both sides Use differentiation property: L{dfdt}=sF(s)−f(0)\\mathcal{L}\\{\\frac{df}{dt}\\} = sF(s) - f(0)L{dtdf​}=sF(s)−f(0) Substitute initial conditions Solve algebraically for I(s)I(s)I(s) You would apply Laplace Transform from here.\nLaplace Transform Properties (for PATH B) Differentiation Property (First Derivative) L{df(t)dt}=sF(s)−f(0)\\mathcal{L}\\left\\{\\frac{df(t)}{dt}\\right\\} = sF(s) - f(0)L{dtdf(t)​}=sF(s)−f(0)Second Derivative Property L{d2f(t)dt2}=s2F(s)−sf(0)−f′(0)\\mathcal{L}\\left\\{\\frac{d^2f(t)}{dt^2}\\right\\} = s^2F(s) - sf(0) - f'(0)L{dt2d2f(t)​}=s2F(s)−sf(0)−f′(0)Integration Property L{∫0tf(τ)dτ}=F(s)s\\mathcal{L}\\left\\{\\int_0^t f(\\tau) d\\tau\\right\\} = \\frac{F(s)}{s}L{∫0t​f(τ)dτ}=sF(s)​Linearity Property L{af(t)+bg(t)}=aF(s)+bG(s)\\mathcal{L}\\{af(t) + bg(t)\\} = aF(s) + bG(s)L{af(t)+bg(t)}=aF(s)+bG(s)Example: Applying Laplace Transform to Differential Equation Given Differential Equation: LCd2i(t)dt2+RCdi(t)dt+i(t)=vs(t)LC\\frac{d^2i(t)}{dt^2} + RC\\frac{di(t)}{dt} + i(t) = v_s(t)LCdt2d2i(t)​+RCdtdi(t)​+i(t)=vs​(t)With initial conditions: i(0)=I0i(0) = I_0i(0)=I0​, di(0)dt=I0′\\frac{di(0)}{dt} = I_0'dtdi(0)​=I0′​\nStep 1: Apply Laplace Transform to each term\nLeft side:\nL{LCd2i(t)dt2}=LC[s2I(s)−si(0)−i′(0)]=LC[s2I(s)−sI0−I0′]\\mathcal{L}\\{LC\\frac{d^2i(t)}{dt^2}\\} = LC[s^2I(s) - si(0) - i'(0)] = LC[s^2I(s) - sI_0 - I_0']L{LCdt2d2i(t)​}=LC[s2I(s)−si(0)−i′(0)]=LC[s2I(s)−sI0​−I0′​] L{RCdi(t)dt}=RC[sI(s)−i(0)]=RC[sI(s)−I0]\\mathcal{L}\\{RC\\frac{di(t)}{dt}\\} = RC[sI(s) - i(0)] = RC[sI(s) - I_0]L{RCdtdi(t)​}=RC[sI(s)−i(0)]=RC[sI(s)−I0​] L{i(t)}=I(s)\\mathcal{L}\\{i(t)\\} = I(s)L{i(t)}=I(s) Right side:\nL{vs(t)}=Vs(s)\\mathcal{L}\\{v_s(t)\\} = V_s(s)L{vs​(t)}=Vs​(s) Step 2: Substitute into equation LC[s2I(s)−sI0−I0′]+RC[sI(s)−I0]+I(s)=Vs(s)LC[s^2I(s) - sI_0 - I_0'] + RC[sI(s) - I_0] + I(s) = V_s(s)LC[s2I(s)−sI0​−I0′​]+RC[sI(s)−I0​]+I(s)=Vs​(s)Step 3: Expand and collect terms LCs2I(s)−LCsI0−LCI0′+RCsI(s)−RCI0+I(s)=Vs(s)LCs^2I(s) - LCsI_0 - LCI_0' + RCsI(s) - RCI_0 + I(s) = V_s(s)LCs2I(s)−LCsI0​−LCI0′​+RCsI(s)−RCI0​+I(s)=Vs​(s)I(s)[LCs2+RCs+1]=Vs(s)+LCsI0+LCI0′+RCI0I(s)[LCs^2 + RCs + 1] = V_s(s) + LCsI_0 + LCI_0' + RCI_0I(s)[LCs2+RCs+1]=Vs​(s)+LCsI0​+LCI0′​+RCI0​Step 4: Solve for I(s) I(s)=Vs(s)+LCsI0+LCI0′+RCI0LCs2+RCs+1I(s) = \\frac{V_s(s) + LCsI_0 + LCI_0' + RCI_0}{LCs^2 + RCs + 1}I(s)=LCs2+RCs+1Vs​(s)+LCsI0​+LCI0′​+RCI0​​You would now apply Inverse Laplace Transform to get i(t).\nAlternative Path: Differential Equation First When to Use This Path Use PATH B when:\nThe problem explicitly asks for the differential equation first You’re more comfortable with time-domain analysis The circuit is simple enough to analyze in time domain Complete PATH B Process graph TD A[Time Domain Circuit] --\u003e B[Apply KVL or KCL in Time Domain] B --\u003e C[Use component equations:v=Ri, v=L di/dt, i=C dv/dt] C --\u003e D[Substitute to get one variable] D --\u003e E[Differential Equation in t] E --\u003e F[Apply Laplace Transform] F --\u003e G[Use differentiation property] G --\u003e H[Substitute initial conditions] H --\u003e I[Algebraic equation in s] I --\u003e J[Solve for V_s or I_s] J --\u003e K[Apply Inverse Laplace Transform] K --\u003e L[Time Domain Solution] style E fill:#ffe0b2 style F fill:#fff9c4 style L fill:#c8e6c9 Detailed Steps for PATH B Step 1: Apply KVL or KCL in Time Domain For Series Circuit (KVL): vs(t)=vR(t)+vL(t)+vC(t)v_s(t) = v_R(t) + v_L(t) + v_C(t)vs​(t)=vR​(t)+vL​(t)+vC​(t)For Parallel Circuit (KCL): is(t)=iR(t)+iL(t)+iC(t)i_s(t) = i_R(t) + i_L(t) + i_C(t)is​(t)=iR​(t)+iL​(t)+iC​(t)Step 2: Substitute Component Equations For Series RLC finding current i(t):\nFrom KVL: vs(t)=vR(t)+vL(t)+vC(t)v_s(t) = v_R(t) + v_L(t) + v_C(t)vs​(t)=vR​(t)+vL​(t)+vC​(t)Substitute:\nvR(t)=Ri(t)v_R(t) = Ri(t)vR​(t)=Ri(t) vL(t)=Ldi(t)dtv_L(t) = L\\frac{di(t)}{dt}vL​(t)=Ldtdi(t)​ vC(t)=1C∫0ti(τ)dτ+vC(0)v_C(t) = \\frac{1}{C}\\int_0^t i(\\tau)d\\tau + v_C(0)vC​(t)=C1​∫0t​i(τ)dτ+vC​(0) Result: vs(t)=Ri(t)+Ldi(t)dt+1C∫0ti(τ)dτ+vC(0)v_s(t) = Ri(t) + L\\frac{di(t)}{dt} + \\frac{1}{C}\\int_0^t i(\\tau)d\\tau + v_C(0)vs​(t)=Ri(t)+Ldtdi(t)​+C1​∫0t​i(τ)dτ+vC​(0)Step 3: Eliminate Integrals/Derivatives Differentiate to eliminate integral: dvs(t)dt=Rdi(t)dt+Ld2i(t)dt2+i(t)C\\frac{dv_s(t)}{dt} = R\\frac{di(t)}{dt} + L\\frac{d^2i(t)}{dt^2} + \\frac{i(t)}{C}dtdvs​(t)​=Rdtdi(t)​+Ldt2d2i(t)​+Ci(t)​Rearrange: Ld2i(t)dt2+Rdi(t)dt+i(t)C=dvs(t)dtL\\frac{d^2i(t)}{dt^2} + R\\frac{di(t)}{dt} + \\frac{i(t)}{C} = \\frac{dv_s(t)}{dt}Ldt2d2i(t)​+Rdtdi(t)​+Ci(t)​=dtdvs​(t)​This is your differential equation.\nStep 4: Apply Laplace Transform (Same process as shown in Step 4 above)\nWorking Backwards: Inverse Operations Understanding the Reverse Process Sometimes you need to work backwards through the steps:\ngraph LR A[Time Domain v_t] \u003c--\u003e B[Laplace Transform] B \u003c--\u003e C[s-Domain V_s] C \u003c--\u003e D[s-Domain Circuit] D \u003c--\u003e E[Time Domain Circuit] style A fill:#ffebee style C fill:#e8f5e9 style E fill:#ffebee Reverse Operation 1: s-Domain to Time Domain Circuit Going Forward: Time circuit → s-Domain circuit (replace R, L, C with impedances)\nGoing Backward: s-Domain circuit → Time circuit\nReverse Transformation Table s-Domain Element Time Domain Element Resistor RRR Resistor RRR Impedance 1sC\\frac{1}{sC}sC1​ Capacitor CCC Impedance sLsLsL Inductor LLL Voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ Initial condition vC(0)v_C(0)vC​(0) on capacitor Voltage source LiL(0)Li_L(0)LiL​(0) Initial condition iL(0)i_L(0)iL​(0) on inductor Vs(s)V_s(s)Vs​(s) vs(t)=L−1{Vs(s)}v_s(t) = \\mathcal{L}^{-1}\\{V_s(s)\\}vs​(t)=L−1{Vs​(s)} Process:\nIdentify each impedance element Convert impedances back to time-domain components Extract initial conditions from voltage/current sources Inverse transform any source functions Reverse Operation 2: s-Domain Equation to Differential Equation Going Forward: Differential equation → Apply Laplace → s-Domain equation\nGoing Backward: s-Domain equation → Identify correspondences → Differential equation\nProcess (detailed in Step 3 above):\nIdentify all terms involving sss Apply inverse correspondence: snV(s)→dnv(t)dtns^n V(s) \\rightarrow \\frac{d^n v(t)}{dt^n}snV(s)→dtndnv(t)​ V(s)s→∫v(t)dt\\frac{V(s)}{s} \\rightarrow \\int v(t)dtsV(s)​→∫v(t)dt Substitute back to get differential equation Reverse Operation 3: KVL/KCL Back to Circuit Going Forward: Circuit → Apply KVL/KCL → Equation\nGoing Backward: Equation → Identify topology → Circuit\nKey identifiers:\nIf equation has sum of voltages = source: Series circuit (KVL) If equation has sum of currents = source: Parallel circuit (KCL) Terms added together → Elements in series (for KVL) or parallel (for KCL) Example: Given: Vs(s)=I(s)[R+sL+1sC]V_s(s) = I(s)[R + sL + \\frac{1}{sC}]Vs​(s)=I(s)[R+sL+sC1​]\nThis indicates:\nSeries circuit (sum of impedances) Contains R, L, and C in series Voltage source Vs(s)V_s(s)Vs​(s) Current I(s)I(s)I(s) flows through all elements Reverse Operation 4: Differential Equation to KVL/KCL Going Forward: KVL/KCL → Substitute components → Differential equation\nGoing Backward: Differential equation → Identify terms → Reconstruct KVL/KCL\nIdentification rules:\nTerms with d2dt2\\frac{d^2}{dt^2}dt2d2​ → Inductor (if solving for current) or Capacitor (if solving for voltage) Terms with ddt\\frac{d}{dt}dtd​ → Inductor (voltage) or Capacitor (current) or Resistor derivative Terms without derivatives → Resistor or result of integration RHS (right-hand side) → Source function Complete Worked Examples Example 1: Series RC Circuit (PATH A - Standard Exam Format) Part 1: Given Time Domain Circuit Circuit:\nv_s(t) = 10u(t) V ---[R = 100Ω]---[C = 10μF]--- ground Find: Voltage across capacitor, vC(t)v_C(t)vC​(t)\nPart 2: Convert to s-Domain Transform components:\nVoltage source: vs(t)=10u(t)→Vs(s)=10sv_s(t) = 10u(t) \\rightarrow V_s(s) = \\frac{10}{s}vs​(t)=10u(t)→Vs​(s)=s10​ Resistor: R=100Ω→R=100ΩR = 100Ω \\rightarrow R = 100ΩR=100Ω→R=100Ω Capacitor: C=10μF→ZC=1sC=1s⋅10×10−6=10610s=105sC = 10μF \\rightarrow Z_C = \\frac{1}{sC} = \\frac{1}{s \\cdot 10 \\times 10^{-6}} = \\frac{10^6}{10s} = \\frac{10^5}{s}C=10μF→ZC​=sC1​=s⋅10×10−61​=10s106​=s105​ s-Domain circuit (without initial conditions):\nV_s(s) = 10/s ---[100]---[10^5/s]--- ground Part 3: Apply KVL in s-Domain Current flows clockwise: I(s)I(s)I(s)\nKVL around loop: Vs(s)=I(s)⋅R+VC(s)V_s(s) = I(s) \\cdot R + V_C(s)Vs​(s)=I(s)⋅R+VC​(s)\nVoltage across capacitor: VC(s)=I(s)⋅ZC=I(s)⋅105sV_C(s) = I(s) \\cdot Z_C = I(s) \\cdot \\frac{10^5}{s}VC​(s)=I(s)⋅ZC​=I(s)⋅s105​\nSubstitute: 10s=I(s)⋅100+I(s)⋅105s\\frac{10}{s} = I(s) \\cdot 100 + I(s) \\cdot \\frac{10^5}{s}s10​=I(s)⋅100+I(s)⋅s105​\n10s=I(s)[100+105s]\\frac{10}{s} = I(s) \\left[100 + \\frac{10^5}{s}\\right]s10​=I(s)[100+s105​]\n10s=I(s)[100s+105s]\\frac{10}{s} = I(s) \\left[\\frac{100s + 10^5}{s}\\right]s10​=I(s)[s100s+105​]\nSolve for I(s): I(s)=10s⋅s100s+105=10100s+105I(s) = \\frac{10}{s} \\cdot \\frac{s}{100s + 10^5} = \\frac{10}{100s + 10^5}I(s)=s10​⋅100s+105s​=100s+10510​\nSimplify: I(s)=10100(s+1000)=0.1s+1000I(s) = \\frac{10}{100(s + 1000)} = \\frac{0.1}{s + 1000}I(s)=100(s+1000)10​=s+10000.1​\nNow find V_C(s): VC(s)=I(s)⋅105s=0.1s+1000⋅105sV_C(s) = I(s) \\cdot \\frac{10^5}{s} = \\frac{0.1}{s + 1000} \\cdot \\frac{10^5}{s}VC​(s)=I(s)⋅s105​=s+10000.1​⋅s105​\nVC(s)=104s(s+1000)V_C(s) = \\frac{10^4}{s(s + 1000)}VC​(s)=s(s+1000)104​\nPart 4: Initial Conditions Given Later Problem states: Initially, capacitor is uncharged: vC(0)=0v_C(0) = 0vC​(0)=0\nSince vC(0)=0v_C(0) = 0vC​(0)=0, no initial condition source is added. Our equation is complete.\nPart 5: Ready for Inverse Laplace Transform We have: VC(s)=104s(s+1000)V_C(s) = \\frac{10^4}{s(s + 1000)}VC​(s)=s(s+1000)104​\nAt this point, you would apply Inverse Laplace Transform using partial fraction expansion.\nExample 2: Series RL Circuit with Initial Condition (PATH A) Part 1: Given Time Domain Circuit Circuit:\nv_s(t) = 5e^{-2t}u(t) V ---[R = 10Ω]---[L = 0.5H]--- ground Find: Current i(t)i(t)i(t)\nPart 2: Convert to s-Domain Transform components:\nVoltage source: vs(t)=5e−2tu(t)→Vs(s)=5s+2v_s(t) = 5e^{-2t}u(t) \\rightarrow V_s(s) = \\frac{5}{s+2}vs​(t)=5e−2tu(t)→Vs​(s)=s+25​ Resistor: R=10ΩR = 10ΩR=10Ω Inductor: L=0.5H→ZL=sL=0.5sL = 0.5H \\rightarrow Z_L = sL = 0.5sL=0.5H→ZL​=sL=0.5s s-Domain circuit (without initial conditions):\nV_s(s) = 5/(s+2) ---[10]---[0.5s]--- ground Part 3: Apply KVL in s-Domain KVL around loop: Vs(s)=I(s)⋅R+I(s)⋅ZLV_s(s) = I(s) \\cdot R + I(s) \\cdot Z_LVs​(s)=I(s)⋅R+I(s)⋅ZL​\n5s+2=I(s)⋅10+I(s)⋅0.5s\\frac{5}{s+2} = I(s) \\cdot 10 + I(s) \\cdot 0.5ss+25​=I(s)⋅10+I(s)⋅0.5s\n5s+2=I(s)[10+0.5s]\\frac{5}{s+2} = I(s)[10 + 0.5s]s+25​=I(s)[10+0.5s]\nSolve for I(s): I(s)=5(s+2)(10+0.5s)=5(s+2)⋅0.5(20+s)I(s) = \\frac{5}{(s+2)(10 + 0.5s)} = \\frac{5}{(s+2) \\cdot 0.5(20 + s)}I(s)=(s+2)(10+0.5s)5​=(s+2)⋅0.5(20+s)5​\nI(s)=10(s+2)(s+20)I(s) = \\frac{10}{(s+2)(s+20)}I(s)=(s+2)(s+20)10​\nPart 4: Initial Conditions Given Problem now states: iL(0)=2Ai_L(0) = 2AiL​(0)=2A\nAdd initial condition voltage source LiL(0)=0.5×2=1VLi_L(0) = 0.5 \\times 2 = 1VLiL​(0)=0.5×2=1V in series with inductor.\nUpdated s-Domain circuit:\nV_s(s) = 5/(s+2) ---[10]---[0.5s]---[+]--- ground [1V source] The voltage source opposes the applied voltage (it represents back-EMF from initial current).\nUpdated KVL: Vs(s)=I(s)⋅R+I(s)⋅ZL+LiL(0)V_s(s) = I(s) \\cdot R + I(s) \\cdot Z_L + Li_L(0)Vs​(s)=I(s)⋅R+I(s)⋅ZL​+LiL​(0)\n5s+2=I(s)[10+0.5s]+1\\frac{5}{s+2} = I(s)[10 + 0.5s] + 1s+25​=I(s)[10+0.5s]+1\n5s+2−1=I(s)[10+0.5s]\\frac{5}{s+2} - 1 = I(s)[10 + 0.5s]s+25​−1=I(s)[10+0.5s]\n5−(s+2)s+2=I(s)[10+0.5s]\\frac{5 - (s+2)}{s+2} = I(s)[10 + 0.5s]s+25−(s+2)​=I(s)[10+0.5s]\n3−ss+2=I(s)[10+0.5s]\\frac{3 - s}{s+2} = I(s)[10 + 0.5s]s+23−s​=I(s)[10+0.5s]\nSolve for I(s): I(s)=3−s(s+2)(10+0.5s)=3−s0.5(s+2)(s+20)I(s) = \\frac{3-s}{(s+2)(10+0.5s)} = \\frac{3-s}{0.5(s+2)(s+20)}I(s)=(s+2)(10+0.5s)3−s​=0.5(s+2)(s+20)3−s​\nI(s)=2(3−s)(s+2)(s+20)I(s) = \\frac{2(3-s)}{(s+2)(s+20)}I(s)=(s+2)(s+20)2(3−s)​\nPart 5: Ready for Inverse Laplace Transform We have: I(s)=2(3−s)(s+2)(s+20)=6−2s(s+2)(s+20)I(s) = \\frac{2(3-s)}{(s+2)(s+20)} = \\frac{6-2s}{(s+2)(s+20)}I(s)=(s+2)(s+20)2(3−s)​=(s+2)(s+20)6−2s​\nAt this point, you would apply Inverse Laplace Transform.\nExample 3: Deriving Differential Equation from s-Domain (PATH A with Step 3) Given: s-Domain Equation From Example 1, we had: Vs(s)=I(s)[R+ZC]V_s(s) = I(s)[R + Z_C]Vs​(s)=I(s)[R+ZC​]\nFor RC circuit: Vs(s)=I(s)[R+1sC]V_s(s) = I(s)\\left[R + \\frac{1}{sC}\\right]Vs​(s)=I(s)[R+sC1​]\nFind: Corresponding Differential Equation Step 1: Express in standard form Vs(s)=RI(s)+I(s)sCV_s(s) = RI(s) + \\frac{I(s)}{sC}Vs​(s)=RI(s)+sCI(s)​\nStep 2: Relate current to voltage\nFor a capacitor: I(s)=sC⋅VC(s)I(s) = sC \\cdot V_C(s)I(s)=sC⋅VC​(s)\nSubstitute: Vs(s)=R⋅sC⋅VC(s)+sC⋅VC(s)sCV_s(s) = R \\cdot sC \\cdot V_C(s) + \\frac{sC \\cdot V_C(s)}{sC}Vs​(s)=R⋅sC⋅VC​(s)+sCsC⋅VC​(s)​\nVs(s)=RsC⋅VC(s)+VC(s)V_s(s) = RsC \\cdot V_C(s) + V_C(s)Vs​(s)=RsC⋅VC​(s)+VC​(s)\nVs(s)=VC(s)[1+RsC]V_s(s) = V_C(s)[1 + RsC]Vs​(s)=VC​(s)[1+RsC]\nStep 3: Apply inverse correspondence\nVs(s)→vs(t)V_s(s) \\rightarrow v_s(t)Vs​(s)→vs​(t) VC(s)→vC(t)V_C(s) \\rightarrow v_C(t)VC​(s)→vC​(t) sC⋅VC(s)→CdvC(t)dtsC \\cdot V_C(s) \\rightarrow C\\frac{dv_C(t)}{dt}sC⋅VC​(s)→CdtdvC​(t)​ From the equation: Vs(s)=VC(s)+RC⋅s⋅VC(s)V_s(s) = V_C(s) + RC \\cdot s \\cdot V_C(s)Vs​(s)=VC​(s)+RC⋅s⋅VC​(s)\nTime domain: vs(t)=vC(t)+RCdvC(t)dtv_s(t) = v_C(t) + RC\\frac{dv_C(t)}{dt}vs​(t)=vC​(t)+RCdtdvC​(t)​\nThis is the first-order differential equation.\nRearranged: RCdvC(t)dt+vC(t)=vs(t)RC\\frac{dv_C(t)}{dt} + v_C(t) = v_s(t)RCdtdvC​(t)​+vC​(t)=vs​(t)\nOr: dvC(t)dt+1RCvC(t)=vs(t)RC\\frac{dv_C(t)}{dt} + \\frac{1}{RC}v_C(t) = \\frac{v_s(t)}{RC}dtdvC​(t)​+RC1​vC​(t)=RCvs​(t)​\nExample 4: Complete PATH B Process (Differential Equation First) Part 1: Given Time Domain Circuit Circuit:\nv_s(t) = 10u(t) V ---[R = 2Ω]---[L = 1H]--- ground Find: Current i(t)i(t)i(t), given iL(0)=0i_L(0) = 0iL​(0)=0\nPart 2: Apply KVL in Time Domain KVL around loop: vs(t)=vR(t)+vL(t)v_s(t) = v_R(t) + v_L(t)vs​(t)=vR​(t)+vL​(t)\nPart 3: Substitute Component Equations vR(t)=R⋅i(t)=2i(t)v_R(t) = R \\cdot i(t) = 2i(t)vR​(t)=R⋅i(t)=2i(t) vL(t)=Ldi(t)dt=1⋅di(t)dt=di(t)dtv_L(t) = L\\frac{di(t)}{dt} = 1 \\cdot \\frac{di(t)}{dt} = \\frac{di(t)}{dt}vL​(t)=Ldtdi(t)​=1⋅dtdi(t)​=dtdi(t)​ Substitute: vs(t)=2i(t)+di(t)dtv_s(t) = 2i(t) + \\frac{di(t)}{dt}vs​(t)=2i(t)+dtdi(t)​\nGiven: vs(t)=10u(t)v_s(t) = 10u(t)vs​(t)=10u(t)\nDifferential equation: di(t)dt+2i(t)=10u(t)\\frac{di(t)}{dt} + 2i(t) = 10u(t)dtdi(t)​+2i(t)=10u(t)\nFor t\u003e0t \u003e 0t\u003e0 (where u(t)=1u(t) = 1u(t)=1): di(t)dt+2i(t)=10\\frac{di(t)}{dt} + 2i(t) = 10dtdi(t)​+2i(t)=10\nPart 4: Apply Laplace Transform Transform both sides: L{di(t)dt}+2L{i(t)}=L{10}\\mathcal{L}\\left\\{\\frac{di(t)}{dt}\\right\\} + 2\\mathcal{L}\\{i(t)\\} = \\mathcal{L}\\{10\\}L{dtdi(t)​}+2L{i(t)}=L{10}\nUse differentiation property: sI(s)−i(0)+2I(s)=10ssI(s) - i(0) + 2I(s) = \\frac{10}{s}sI(s)−i(0)+2I(s)=s10​\nGiven: i(0)=0i(0) = 0i(0)=0\nsI(s)+2I(s)=10ssI(s) + 2I(s) = \\frac{10}{s}sI(s)+2I(s)=s10​\nI(s)[s+2]=10sI(s)[s + 2] = \\frac{10}{s}I(s)[s+2]=s10​\nSolve for I(s): I(s)=10s(s+2)I(s) = \\frac{10}{s(s+2)}I(s)=s(s+2)10​\nPart 5: Ready for Inverse Laplace Transform We have: I(s)=10s(s+2)I(s) = \\frac{10}{s(s+2)}I(s)=s(s+2)10​\nAt this point, you would apply Inverse Laplace Transform.\nExample 5: Parallel RLC with Node Analysis (PATH A) Part 1: Given Time Domain Circuit Circuit:\ni_s(t) = 2u(t) A | +----+----+----+ | | | | R=5 L=2H C=0.1F | | | | ground ground ground Find: Voltage v(t)v(t)v(t) across all elements\nPart 2: Convert to s-Domain Transform components:\nCurrent source: is(t)=2u(t)→Is(s)=2si_s(t) = 2u(t) \\rightarrow I_s(s) = \\frac{2}{s}is​(t)=2u(t)→Is​(s)=s2​ Resistor: R=5ΩR = 5ΩR=5Ω Inductor: ZL=sL=2sZ_L = sL = 2sZL​=sL=2s (use parallel form with current source for KCL) Capacitor: ZC=1sC=10.1s=10sZ_C = \\frac{1}{sC} = \\frac{1}{0.1s} = \\frac{10}{s}ZC​=sC1​=0.1s1​=s10​ s-Domain circuit (without initial conditions):\nI_s(s) = 2/s | +----+----+----+ | | | | R=5 2s 10/s | | | | ground Voltage V(s)V(s)V(s) appears across all elements.\nPart 3: Apply KCL at Top Node KCL (currents leaving node): Is(s)=IR(s)+IL(s)+IC(s)I_s(s) = I_R(s) + I_L(s) + I_C(s)Is​(s)=IR​(s)+IL​(s)+IC​(s)\nExpress currents in terms of V(s):\nIR(s)=V(s)R=V(s)5I_R(s) = \\frac{V(s)}{R} = \\frac{V(s)}{5}IR​(s)=RV(s)​=5V(s)​ IL(s)=V(s)ZL=V(s)2sI_L(s) = \\frac{V(s)}{Z_L} = \\frac{V(s)}{2s}IL​(s)=ZL​V(s)​=2sV(s)​ IC(s)=V(s)ZC=V(s)⋅s10=sV(s)10I_C(s) = \\frac{V(s)}{Z_C} = V(s) \\cdot \\frac{s}{10} = \\frac{sV(s)}{10}IC​(s)=ZC​V(s)​=V(s)⋅10s​=10sV(s)​ Substitute: 2s=V(s)5+V(s)2s+sV(s)10\\frac{2}{s} = \\frac{V(s)}{5} + \\frac{V(s)}{2s} + \\frac{sV(s)}{10}s2​=5V(s)​+2sV(s)​+10sV(s)​\nFactor out V(s): 2s=V(s)[15+12s+s10]\\frac{2}{s} = V(s)\\left[\\frac{1}{5} + \\frac{1}{2s} + \\frac{s}{10}\\right]s2​=V(s)[51​+2s1​+10s​]\nFind common denominator (10s): 2s=V(s)[2s10s+510s+s210s]\\frac{2}{s} = V(s)\\left[\\frac{2s}{10s} + \\frac{5}{10s} + \\frac{s^2}{10s}\\right]s2​=V(s)[10s2s​+10s5​+10ss2​]\n2s=V(s)[2s+5+s210s]\\frac{2}{s} = V(s)\\left[\\frac{2s + 5 + s^2}{10s}\\right]s2​=V(s)[10s2s+5+s2​]\n2s=V(s)[s2+2s+510s]\\frac{2}{s} = V(s)\\left[\\frac{s^2 + 2s + 5}{10s}\\right]s2​=V(s)[10ss2+2s+5​]\nSolve for V(s): V(s)=2s⋅10ss2+2s+5V(s) = \\frac{2}{s} \\cdot \\frac{10s}{s^2 + 2s + 5}V(s)=s2​⋅s2+2s+510s​\nV(s)=20s2+2s+5V(s) = \\frac{20}{s^2 + 2s + 5}V(s)=s2+2s+520​\nPart 4: Initial Conditions Given Problem states: vC(0)=0Vv_C(0) = 0VvC​(0)=0V, iL(0)=1Ai_L(0) = 1AiL​(0)=1A\nFor inductor in parallel form: Add current source iL(0)s=1s\\frac{i_L(0)}{s} = \\frac{1}{s}siL​(0)​=s1​ in parallel with ZLZ_LZL​\nUpdated KCL: Is(s)=IR(s)+IL(s)+IC(s)+IL,initial(s)I_s(s) = I_R(s) + I_L(s) + I_C(s) + I_{L,initial}(s)Is​(s)=IR​(s)+IL​(s)+IC​(s)+IL,initial​(s)\nWhere IL,initial(s)=−iL(0)s=−1sI_{L,initial}(s) = -\\frac{i_L(0)}{s} = -\\frac{1}{s}IL,initial​(s)=−siL​(0)​=−s1​ (negative because it flows out of the node initially)\nActually, the correct polarity: the initial current source flows in the same direction as the inductor would naturally discharge.\nUpdated equation: 2s=V(s)5+V(s)2s+sV(s)10−1s\\frac{2}{s} = \\frac{V(s)}{5} + \\frac{V(s)}{2s} + \\frac{sV(s)}{10} - \\frac{1}{s}s2​=5V(s)​+2sV(s)​+10sV(s)​−s1​\n2s+1s=V(s)[15+12s+s10]\\frac{2}{s} + \\frac{1}{s} = V(s)\\left[\\frac{1}{5} + \\frac{1}{2s} + \\frac{s}{10}\\right]s2​+s1​=V(s)[51​+2s1​+10s​]\n3s=V(s)[s2+2s+510s]\\frac{3}{s} = V(s)\\left[\\frac{s^2 + 2s + 5}{10s}\\right]s3​=V(s)[10ss2+2s+5​]\nSolve for V(s): V(s)=3s⋅10ss2+2s+5=30s2+2s+5V(s) = \\frac{3}{s} \\cdot \\frac{10s}{s^2 + 2s + 5} = \\frac{30}{s^2 + 2s + 5}V(s)=s3​⋅s2+2s+510s​=s2+2s+530​\nPart 5: Ready for Inverse Laplace Transform We have: V(s)=30s2+2s+5V(s) = \\frac{30}{s^2 + 2s + 5}V(s)=s2+2s+530​\nAt this point, you would apply Inverse Laplace Transform.\nTips and Tricks General Strategy Tip 1: Choose Your Analysis Method Based on Circuit Topology\nSeries-dominant circuit: Use KVL/Mesh analysis Parallel-dominant circuit: Use KCL/Node analysis Mixed circuit: Count nodes vs. loops, choose method with fewer equations Tip 2: Initial Condition Handling\nWhen initial conditions are given AFTER you’ve already set up the s-domain circuit:\nDon’t panic - this is common in exams Add the initial condition sources to your existing s-domain circuit Update your KVL/KCL equation with the new source terms Re-solve for the variable of interest Tip 3: Impedance Combination\nCombine impedances BEFORE applying KVL/KCL to simplify algebra:\nSeries impedances: Ztotal=Z1+Z2+Z3+⋯Z_{total} = Z_1 + Z_2 + Z_3 + \\cdotsZtotal​=Z1​+Z2​+Z3​+⋯\nParallel impedances: 1Ztotal=1Z1+1Z2+1Z3+⋯\\frac{1}{Z_{total}} = \\frac{1}{Z_1} + \\frac{1}{Z_2} + \\frac{1}{Z_3} + \\cdotsZtotal​1​=Z1​1​+Z2​1​+Z3​1​+⋯\nOr for two impedances: Ztotal=Z1Z2Z1+Z2Z_{total} = \\frac{Z_1 Z_2}{Z_1 + Z_2}Ztotal​=Z1​+Z2​Z1​Z2​​\nComponent Transformation Tips Tip 4: Capacitor Impedance Direction\nThe impedance 1sC\\frac{1}{sC}sC1​ becomes:\nLarge (open circuit) at low frequencies (s→0s \\to 0s→0, DC) Small (short circuit) at high frequencies (s→∞s \\to \\inftys→∞) Tip 5: Inductor Impedance Direction\nThe impedance sLsLsL becomes:\nSmall (short circuit) at low frequencies (s→0s \\to 0s→0, DC) Large (open circuit) at high frequencies (s→∞s \\to \\inftys→∞) Tip 6: Initial Condition Polarity for Capacitors\nWhen adding the initial condition voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​:\nIf vC(0)\u003e0v_C(0) \u003e 0vC​(0)\u003e0: The + terminal of the source is on the same side as the + terminal of the capacitor’s initial voltage The source “helps” discharge the capacitor Tip 7: Initial Condition Choice for Inductors\nYou have two equivalent options:\nSeries voltage source: LiL(0)Li_L(0)LiL​(0) - easier for KVL Parallel current source: iL(0)s\\frac{i_L(0)}{s}siL​(0)​ - easier for KCL Use source transformation to convert between them if needed: LiL(0) (series with sL)≡iL(0)s (parallel with sL)Li_L(0) \\text{ (series with } sL) \\equiv \\frac{i_L(0)}{s} \\text{ (parallel with } sL)LiL​(0) (series with sL)≡siL​(0)​ (parallel with sL)\nEquation Setup Tips Tip 8: Factor Out the Unknown\nAlways factor out I(s)I(s)I(s) or V(s)V(s)V(s) as soon as possible:\nInstead of: 10s=100I(s)+105I(s)s\\frac{10}{s} = 100I(s) + \\frac{10^5 I(s)}{s}s10​=100I(s)+s105I(s)​\nWrite: 10s=I(s)[100+105s]\\frac{10}{s} = I(s)\\left[100 + \\frac{10^5}{s}\\right]s10​=I(s)[100+s105​]\nTip 9: Common Denominator Strategy\nWhen combining impedances with different sss terms:\nR+1sC=RsC+1sCR + \\frac{1}{sC} = \\frac{RsC + 1}{sC}R+sC1​=sCRsC+1​\nR+sL=R+sL (already simplified)R + sL = R + sL \\text{ (already simplified)}R+sL=R+sL (already simplified)\n1sL+sC=1+s2LCsL\\frac{1}{sL} + sC = \\frac{1 + s^2LC}{sL}sL1​+sC=sL1+s2LC​\nTip 10: Simplify Before Solving\nLook for opportunities to simplify:\nFactor out constants Cancel common terms in numerator and denominator Combine like terms Example: I(s)=100100(s+10)=1s+10I(s) = \\frac{100}{100(s+10)} = \\frac{1}{s+10}I(s)=100(s+10)100​=s+101​\nDifferential Equation Derivation Tips Tip 11: Matching Powers of s\nWhen deriving differential equations from s-domain:\ns0s^0s0 (constant) → original function s1s^1s1 → first derivative s2s^2s2 → second derivative Tip 12: Clear Fractions First\nBefore applying inverse correspondence, multiply through to eliminate fractions:\nGiven: Vs(s)=I(s)[R+sL+1sC]V_s(s) = I(s)\\left[R + sL + \\frac{1}{sC}\\right]Vs​(s)=I(s)[R+sL+sC1​]\nMultiply by sCsCsC: sCVs(s)=I(s)[RsC+s2LC+1]sCVs(s) = I(s)[RsC + s^2LC + 1]sCVs(s)=I(s)[RsC+s2LC+1]\nNow apply inverse correspondence more easily.\nTip 13: Identify the Dependent Variable\nMake sure you know what variable your differential equation should be in terms of:\nIf solving for current, derive equation in terms of i(t)i(t)i(t) If solving for voltage, derive equation in terms of v(t)v(t)v(t) Use component relationships to substitute and eliminate other variables Verification Tips Tip 14: Dimensional Analysis\nCheck units throughout:\n[R]=Ω[R] = \\Omega[R]=Ω [sL]=s⋅H=Ω[sL] = s \\cdot H = \\Omega[sL]=s⋅H=Ω (since H=Ω⋅sH = \\Omega \\cdot sH=Ω⋅s) [1sC]=1s⋅F=Ω[\\frac{1}{sC}] = \\frac{1}{s \\cdot F} = \\Omega[sC1​]=s⋅F1​=Ω (since F=sΩF = \\frac{s}{\\Omega}F=Ωs​) All impedances must have units of Ohms Tip 15: Initial Value Check\nUse Initial Value Theorem to verify: lim⁡t→0+f(t)=lim⁡s→∞sF(s)\\lim_{t \\to 0^+} f(t) = \\lim_{s \\to \\infty} sF(s)limt→0+​f(t)=lims→∞​sF(s)\nCheck if your V(s)V(s)V(s) or I(s)I(s)I(s) gives the correct initial value.\nTip 16: Final Value Check\nUse Final Value Theorem (for stable systems): lim⁡t→∞f(t)=lim⁡s→0sF(s)\\lim_{t \\to \\infty} f(t) = \\lim_{s \\to 0} sF(s)limt→∞​f(t)=lims→0​sF(s)\nFor DC steady state, this should match your circuit analysis at s=0s = 0s=0.\nProblem-Solving Workflow Tip 17: Standard Exam Approach\nRead entire problem - note what’s given and what’s asked Draw s-domain circuit (without initial conditions first) Choose KVL or KCL based on topology Write equation in s-domain When initial conditions are given, add them to circuit and equation Solve algebraically for V(s)V(s)V(s) or I(s)I(s)I(s) State “ready for inverse Laplace transform” Tip 18: Sign Convention Consistency\nChoose current direction at the start Mark it clearly on your circuit diagram Stick with it throughout the problem Voltage drops are positive in the direction of current (passive sign convention) Tip 19: Organize Your Work\nLabel each step clearly:\n“s-Domain Circuit Transformation” “Apply KVL” or “Apply KCL” “Add Initial Conditions” “Solve for V(s)” or “Solve for I(s)” “Ready for Inverse Laplace Transform” This makes it easier for graders and helps you catch errors.\nAdvanced Tips Tip 20: Source Transformation in s-Domain\nYou can perform source transformations in s-domain just like in time domain:\nVoltage source Vs(s)V_s(s)Vs​(s) in series with ZZZ ↔ Current source Is(s)=Vs(s)ZI_s(s) = \\frac{V_s(s)}{Z}Is​(s)=ZVs​(s)​ in parallel with ZZZ\nUse this to simplify circuits before analysis.\nTip 21: Thevenin/Norton in s-Domain\nFor complex circuits, find Thevenin or Norton equivalent:\nVth(s)V_{th}(s)Vth​(s) = open circuit voltage Zth(s)Z_{th}(s)Zth​(s) = impedance with sources zeroed IN(s)=Vth(s)Zth(s)I_N(s) = \\frac{V_{th}(s)}{Z_{th}(s)}IN​(s)=Zth​(s)Vth​(s)​ Tip 22: Voltage and Current Dividers\nUse these shortcuts in s-domain:\nVoltage divider: V1(s)=Vin(s)⋅Z1Z1+Z2V_1(s) = V_{in}(s) \\cdot \\frac{Z_1}{Z_1 + Z_2}V1​(s)=Vin​(s)⋅Z1​+Z2​Z1​​\nCurrent divider: I1(s)=Iin(s)⋅Z2Z1+Z2I_1(s) = I_{in}(s) \\cdot \\frac{Z_2}{Z_1 + Z_2}I1​(s)=Iin​(s)⋅Z1​+Z2​Z2​​\nTip 23: Natural Response vs Forced Response\nYour s-domain solution contains both:\nPoles from circuit (denominator of 1Ztotal\\frac{1}{Z_{total}}Ztotal​1​) → natural response Poles from source (denominator of Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s)) → forced response This becomes clear after inverse transformation.\nTip 24: Quick Mental Checks\nBefore inverse transforming:\nDegree of denominator \\geq degree of numerator (for proper rational function) All poles should be in left half-plane for stable circuit Number of poles tells you order of differential equation Common Pitfalls Transformation Errors Pitfall 1: Wrong Impedance Formula\nWRONG: ZC=sCZ_C = sCZC​=sC or ZC=CZ_C = CZC​=C\nCORRECT: ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​\nWRONG: ZL=LsZ_L = \\frac{L}{s}ZL​=sL​ or ZL=LZ_L = LZL​=L\nCORRECT: ZL=sLZ_L = sLZL​=sL\nPitfall 2: Forgetting the sss Variable\nWhen working in s-domain, ALWAYS include sss:\nWRONG: V(s)=I(s)[R+L+1C]V(s) = I(s)[R + L + \\frac{1}{C}]V(s)=I(s)[R+L+C1​]\nCORRECT: V(s)=I(s)[R+sL+1sC]V(s) = I(s)[R + sL + \\frac{1}{sC}]V(s)=I(s)[R+sL+sC1​]\nPitfall 3: Initial Condition Source Form\nWRONG: Capacitor initial condition = vC(0)v_C(0)vC​(0)\nCORRECT: Capacitor initial condition = vC(0)s\\frac{v_C(0)}{s}svC​(0)​\nWRONG: Inductor series voltage source = iL(0)i_L(0)iL​(0)\nCORRECT: Inductor series voltage source = LiL(0)Li_L(0)LiL​(0)\nWRONG: Inductor parallel current source = iL(0)i_L(0)iL​(0)\nCORRECT: Inductor parallel current source = iL(0)s\\frac{i_L(0)}{s}siL​(0)​\nSign and Polarity Errors Pitfall 4: Initial Condition Polarity\nThe initial condition sources must have correct polarity:\nCapacitor voltage source: reflects actual stored voltage polarity Inductor current source: flows in direction of initial current Wrong polarity gives negative of correct answer Pitfall 5: KVL Sign Errors\nGoing around loop, be consistent:\nVoltage rises (- to +) are positive if going that direction Voltage drops (+ to -) are negative if going that direction OR: Set all drops in current direction as positive (passive convention) Pitfall 6: KCL Direction Errors\nAt a node:\nCurrents entering: one sign (usually positive) Currents leaving: opposite sign (usually negative) Be consistent throughout Algebraic Errors Pitfall 7: Fraction Combination\nWRONG: 1sC+R=1+RsC\\frac{1}{sC} + R = \\frac{1 + R}{sC}sC1​+R=sC1+R​\nCORRECT: 1sC+R=1+RsCsC\\frac{1}{sC} + R = \\frac{1 + RsC}{sC}sC1​+R=sC1+RsC​\nPitfall 8: Factoring Errors\nWhen factoring out I(s)I(s)I(s) or V(s)V(s)V(s), check EVERY term:\nWRONG: RI(s)+sLI(s)+I(s)sC=I(s)[R+sL]RI(s) + sLI(s) + \\frac{I(s)}{sC} = I(s)[R + sL]RI(s)+sLI(s)+sCI(s)​=I(s)[R+sL]\nCORRECT: RI(s)+sLI(s)+I(s)sC=I(s)[R+sL+1sC]RI(s) + sLI(s) + \\frac{I(s)}{sC} = I(s)[R + sL + \\frac{1}{sC}]RI(s)+sLI(s)+sCI(s)​=I(s)[R+sL+sC1​]\nPitfall 9: Solving for Wrong Variable\nMake sure you’re solving for what’s asked:\nProblem asks for VC(s)V_C(s)VC​(s) but you solved for I(s)I(s)I(s) - must convert Use VC(s)=I(s)⋅ZCV_C(s) = I(s) \\cdot Z_CVC​(s)=I(s)⋅ZC​ or similar relationships Conceptual Errors Pitfall 10: Mixing Time and s-Domain\nNEVER write v(t)v(t)v(t) in an s-domain equation or V(s)V(s)V(s) in a time-domain equation.\nWRONG: V(s)=R⋅i(t)V(s) = R \\cdot i(t)V(s)=R⋅i(t)\nCORRECT: V(s)=R⋅I(s)V(s) = R \\cdot I(s)V(s)=R⋅I(s) (s-domain) or v(t)=R⋅i(t)v(t) = R \\cdot i(t)v(t)=R⋅i(t) (time-domain)\nPitfall 11: Assuming Zero Initial Conditions\nUnless explicitly stated or obvious (circuit just turned on from de-energized state), NEVER assume vC(0)=0v_C(0) = 0vC​(0)=0 or iL(0)=0i_L(0) = 0iL​(0)=0.\nWait for problem to give initial conditions or solve for them from t\u003c0t \u003c 0t\u003c0 analysis.\nPitfall 12: Wrong Differential Equation Order\nThe order of the differential equation equals:\nNumber of energy storage elements (L and C) in general For series/parallel RLC: second order For RC or RL: first order If you get wrong order, check your derivation.\nPitfall 13: Forgetting u(t) in Sources\nWhen transforming sources, don’t forget the unit step:\nvs(t)=10v_s(t) = 10vs​(t)=10 for t\u003e0t \u003e 0t\u003e0 means vs(t)=10u(t)v_s(t) = 10u(t)vs​(t)=10u(t)\nWRONG: L{10}=10\\mathcal{L}\\{10\\} = 10L{10}=10\nCORRECT: L{10u(t)}=10s\\mathcal{L}\\{10u(t)\\} = \\frac{10}{s}L{10u(t)}=s10​\nPitfall 14: Incorrect Source Transformation\nWhen converting between series and parallel forms:\nFor inductor initial condition:\nSeries: sLsLsL with voltage source LiL(0)Li_L(0)LiL​(0)\n↔ Parallel: sLsLsL with current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​\nThe relationship: LiL(0)=(sL)⋅iL(0)sLi_L(0) = (sL) \\cdot \\frac{i_L(0)}{s}LiL​(0)=(sL)⋅siL​(0)​ [CHECK]\nNOT: LiL(0)=(sL)iL(0)Li_L(0) = \\frac{(sL)}{i_L(0)}LiL​(0)=iL​(0)(sL)​ [X]\nUnits and Scaling Errors Pitfall 15: Unit Conversion\nWatch for μF, mH, kΩ, etc.:\n10μF=10×10−6F10μF = 10 \\times 10^{-6} F10μF=10×10−6F 5mH=5×10−3H5mH = 5 \\times 10^{-3} H5mH=5×10−3H 2kΩ=2×103Ω2kΩ = 2 \\times 10^3 Ω2kΩ=2×103Ω Pitfall 16: Dimensional Inconsistency\nAll terms in an equation must have same dimensions:\nIn V(s)=I(s)Z(s)V(s) = I(s)Z(s)V(s)=I(s)Z(s): all terms must be voltage In I(s)=V(s)Z(s)I(s) = \\frac{V(s)}{Z(s)}I(s)=Z(s)V(s)​: all terms must be current Check by dimension analysis if unsure Summary Flow Charts Complete PATH A Process graph TD A[START: Time Domain Circuit] --\u003e B[Transform all components to s-domainR→R, C→1/sC, L→sL, sources→transformed] B --\u003e C[Draw s-domain circuitwithout initial conditions] C --\u003e D{Series or Parallel?} D --\u003e|Series| E[Apply KVL] D --\u003e|Parallel| F[Apply KCL] E --\u003e G[Get algebraic equation in s] F --\u003e G G --\u003e H{Initial conditions given?} H --\u003e|No| I[Equation completeSolve for Vs or Is] H --\u003e|Yes| J[Add initial condition sourcesto circuit and equation] J --\u003e K[Update equationSolve for Vs or Is] I --\u003e L[Expression for Vs or Is] K --\u003e L L --\u003e M[END: Ready for Inverse Laplace Transform] style A fill:#ffebee style C fill:#fff3e0 style G fill:#e8f5e9 style L fill:#e1f5ff style M fill:#c8e6c9 Complete PATH B Process graph TD A[START: Time Domain Circuit] --\u003e B[Apply KVL or KCL in time domain] B --\u003e C[Substitute component equationsv=Ri, v=L di/dt, i=C dv/dt] C --\u003e D[Manipulate to get single variable] D --\u003e E[Differential Equation in time domain] E --\u003e F{Initial conditions given?} F --\u003e|Yes| G[Note initial conditionsft=0, f't=0] F --\u003e|No| H[Solve for initial conditionsfrom t less than 0 circuit] G --\u003e I[Apply Laplace Transform] H --\u003e I I --\u003e J[Use differentiation propertyLdf/dt = sFs - f0] J --\u003e K[Substitute initial conditions] K --\u003e L[Algebraic equation in s] L --\u003e M[Solve for Vs or Is] M --\u003e N[END: Ready for Inverse Laplace Transform] style A fill:#ffebee style E fill:#ffe0b2 style I fill:#fff9c4 style L fill:#e8f5e9 style M fill:#e1f5ff style N fill:#c8e6c9 Choosing Between PATH A and PATH B graph TD A[Circuit Analysis Problem] --\u003e B{What does problem ask for?} B --\u003e|Convert to s-domain first| C[Use PATH ADirect Transformation] B --\u003e|Find differential equation| D[Use PATH Bor derive from PATH A] B --\u003e|Either approach works| E{What's easier?} E --\u003e|Complex circuit| C E --\u003e|Simple circuit| F[Either path fine] E --\u003e|Want to understand physics| D E --\u003e|Time pressure| C C --\u003e G[Transform → KVL/KCL → Algebraic equation] D --\u003e H[KVL/KCL → Diff Eq → Laplace Transform] F --\u003e G F --\u003e H G --\u003e I[Solve in s-domain] H --\u003e I style C fill:#e8f5e9 style D fill:#ffe0b2 style I fill:#c8e6c9 Quick Reference Tables s-Domain Transformations Summary Time Domain s-Domain Notes RRR RRR Resistor unchanged CCC 1sC\\frac{1}{sC}sC1​ Capacitor impedance LLL sLsLsL Inductor impedance vC(0)v_C(0)vC​(0) vC(0)s\\frac{v_C(0)}{s}svC​(0)​ Capacitor initial voltage (series) iL(0)i_L(0)iL​(0) LiL(0)Li_L(0)LiL​(0) Inductor initial current (series voltage) iL(0)i_L(0)iL​(0) iL(0)s\\frac{i_L(0)}{s}siL​(0)​ Inductor initial current (parallel current) V0u(t)V_0 u(t)V0​u(t) V0s\\frac{V_0}{s}sV0​​ Step function V0e−atu(t)V_0 e^{-at}u(t)V0​e−atu(t) V0s+a\\frac{V_0}{s+a}s+aV0​​ Exponential V0sin⁡(ωt)u(t)V_0 \\sin(\\omega t)u(t)V0​sin(ωt)u(t) V0ωs2+ω2\\frac{V_0\\omega}{s^2+\\omega^2}s2+ω2V0​ω​ Sine V0cos⁡(ωt)u(t)V_0 \\cos(\\omega t)u(t)V0​cos(ωt)u(t) V0ss2+ω2\\frac{V_0 s}{s^2+\\omega^2}s2+ω2V0​s​ Cosine Laplace Transform Properties Summary Property Time Domain s-Domain Linearity af(t)+bg(t)af(t) + bg(t)af(t)+bg(t) aF(s)+bG(s)aF(s) + bG(s)aF(s)+bG(s) First Derivative df(t)dt\\frac{df(t)}{dt}dtdf(t)​ sF(s)−f(0)sF(s) - f(0)sF(s)−f(0) Second Derivative d2f(t)dt2\\frac{d^2f(t)}{dt^2}dt2d2f(t)​ s2F(s)−sf(0)−f′(0)s^2F(s) - sf(0) - f'(0)s2F(s)−sf(0)−f′(0) Integration ∫0tf(τ)dτ\\int_0^t f(\\tau)d\\tau∫0t​f(τ)dτ F(s)s\\frac{F(s)}{s}sF(s)​ Time Shift f(t−a)u(t−a)f(t-a)u(t-a)f(t−a)u(t−a) e−asF(s)e^{-as}F(s)e−asF(s) Frequency Shift e−atf(t)e^{-at}f(t)e−atf(t) F(s+a)F(s+a)F(s+a) Inverse Correspondence (s-Domain to Time Domain Differential Equations) s-Domain Term Time Domain Term Notes V(s)V(s)V(s) v(t)v(t)v(t) Basic function sV(s)sV(s)sV(s) dv(t)dt\\frac{dv(t)}{dt}dtdv(t)​ First derivative (IC separate) s2V(s)s^2V(s)s2V(s) d2v(t)dt2\\frac{d^2v(t)}{dt^2}dt2d2v(t)​ Second derivative (IC separate) V(s)s\\frac{V(s)}{s}sV(s)​ ∫0tv(τ)dτ\\int_0^t v(\\tau)d\\tau∫0t​v(τ)dτ Integration 1s\\frac{1}{s}s1​ u(t)u(t)u(t) Unit step 1s+a\\frac{1}{s+a}s+a1​ e−ate^{-at}e−at Exponential ωs2+ω2\\frac{\\omega}{s^2+\\omega^2}s2+ω2ω​ sin⁡(ωt)\\sin(\\omega t)sin(ωt) Sine ss2+ω2\\frac{s}{s^2+\\omega^2}s2+ω2s​ cos⁡(ωt)\\cos(\\omega t)cos(ωt) Cosine Analysis Method Selection Guide Circuit Type Recommended Method Why Series RLC KVL (Mesh) Elements share same current Parallel RLC KCL (Node) Elements share same voltage Ladder network Node analysis Usually fewer nodes than loops Multiple sources Mesh analysis Often fewer loops Want current KVL/Mesh Directly gives current Want voltage KCL/Node Directly gives voltage 2-3 nodes Node analysis Quick setup 2-3 loops Mesh analysis Quick setup Common Circuit Transfer Functions Circuit Configuration Transfer Function H(s)=Vout(s)Vin(s)H(s) = \\frac{V_{out}(s)}{V_{in}(s)}H(s)=Vin​(s)Vout​(s)​ RC Low-pass Series RC, output across C 11+RCs\\frac{1}{1 + RCs}1+RCs1​ RC High-pass Series RC, output across R RCs1+RCs\\frac{RCs}{1 + RCs}1+RCsRCs​ RL Low-pass Series RL, output across R RR+sL\\frac{R}{R + sL}R+sLR​ RL High-pass Series RL, output across L sLR+sL\\frac{sL}{R + sL}R+sLsL​ Series RLC Output across C 1LCs2+RCs+1\\frac{1}{LCs^2 + RCs + 1}LCs2+RCs+11​ Parallel RLC Current divider to R 11+R(1sL+sC)\\frac{1}{1 + R(\\frac{1}{sL} + sC)}1+R(sL1​+sC)1​ Additional Worked Example: Mixed Circuit Example 6: Mixed Series-Parallel Circuit (Complete PATH A) Problem Statement Given the following circuit for t≥0t \\geq 0t≥0:\nv_s(t) = 12u(t) V ---[R1 = 4Ω]---+---[R2 = 6Ω]--- ground | C = 0.05F | ground Find: Voltage across capacitor vC(t)v_C(t)vC​(t)\nGiven later: vC(0)=2Vv_C(0) = 2VvC​(0)=2V\nStep 1: Convert to s-Domain Transform components:\nVoltage source: vs(t)=12u(t)→Vs(s)=12sv_s(t) = 12u(t) \\rightarrow V_s(s) = \\frac{12}{s}vs​(t)=12u(t)→Vs​(s)=s12​ R1=4ΩR_1 = 4ΩR1​=4Ω (unchanged) R2=6ΩR_2 = 6ΩR2​=6Ω (unchanged) Capacitor: C=0.05F→ZC=1sC=10.05s=20sC = 0.05F \\rightarrow Z_C = \\frac{1}{sC} = \\frac{1}{0.05s} = \\frac{20}{s}C=0.05F→ZC​=sC1​=0.05s1​=s20​ s-Domain circuit (without initial conditions):\nV_s(s) = 12/s ---[4Ω]---+---[6Ω]--- ground | 20/s | ground Step 2: Simplify Circuit - Combine Parallel Elements R2R_2R2​ and ZCZ_CZC​ are in parallel. Their equivalent impedance:\nZparallel=R2⋅ZCR2+ZC=6⋅20s6+20sZ_{parallel} = \\frac{R_2 \\cdot Z_C}{R_2 + Z_C} = \\frac{6 \\cdot \\frac{20}{s}}{6 + \\frac{20}{s}}Zparallel​=R2​+ZC​R2​⋅ZC​​=6+s20​6⋅s20​​\nZparallel=120s6s+20s=120s⋅s6s+20=1206s+20Z_{parallel} = \\frac{\\frac{120}{s}}{\\frac{6s + 20}{s}} = \\frac{120}{s} \\cdot \\frac{s}{6s + 20} = \\frac{120}{6s + 20}Zparallel​=s6s+20​s120​​=s120​⋅6s+20s​=6s+20120​\nZparallel=1202(3s+10)=603s+10Z_{parallel} = \\frac{120}{2(3s + 10)} = \\frac{60}{3s + 10}Zparallel​=2(3s+10)120​=3s+1060​\nSimplified circuit:\nV_s(s) = 12/s ---[4Ω]---[60/(3s+10)]--- ground Step 3: Apply KVL Current I(s)I(s)I(s) flows through series elements:\nVs(s)=I(s)⋅R1+I(s)⋅ZparallelV_s(s) = I(s) \\cdot R_1 + I(s) \\cdot Z_{parallel}Vs​(s)=I(s)⋅R1​+I(s)⋅Zparallel​\n12s=I(s)[4+603s+10]\\frac{12}{s} = I(s) \\left[4 + \\frac{60}{3s + 10}\\right]s12​=I(s)[4+3s+1060​]\n12s=I(s)[4(3s+10)+603s+10]\\frac{12}{s} = I(s) \\left[\\frac{4(3s + 10) + 60}{3s + 10}\\right]s12​=I(s)[3s+104(3s+10)+60​]\n12s=I(s)[12s+40+603s+10]\\frac{12}{s} = I(s) \\left[\\frac{12s + 40 + 60}{3s + 10}\\right]s12​=I(s)[3s+1012s+40+60​]\n12s=I(s)[12s+1003s+10]\\frac{12}{s} = I(s) \\left[\\frac{12s + 100}{3s + 10}\\right]s12​=I(s)[3s+1012s+100​]\nSolve for I(s):\nI(s)=12s⋅3s+1012s+100I(s) = \\frac{12}{s} \\cdot \\frac{3s + 10}{12s + 100}I(s)=s12​⋅12s+1003s+10​\nI(s)=12(3s+10)s(12s+100)I(s) = \\frac{12(3s + 10)}{s(12s + 100)}I(s)=s(12s+100)12(3s+10)​\nI(s)=12(3s+10)4s(3s+25)=3(3s+10)s(3s+25)I(s) = \\frac{12(3s + 10)}{4s(3s + 25)} = \\frac{3(3s + 10)}{s(3s + 25)}I(s)=4s(3s+25)12(3s+10)​=s(3s+25)3(3s+10)​\nStep 4: Find Voltage Across Capacitor The voltage across the parallel combination (which includes the capacitor):\nVC(s)=I(s)⋅ZparallelV_C(s) = I(s) \\cdot Z_{parallel}VC​(s)=I(s)⋅Zparallel​\nVC(s)=3(3s+10)s(3s+25)⋅603s+10V_C(s) = \\frac{3(3s + 10)}{s(3s + 25)} \\cdot \\frac{60}{3s + 10}VC​(s)=s(3s+25)3(3s+10)​⋅3s+1060​\nVC(s)=3(3s+10)⋅60s(3s+25)(3s+10)V_C(s) = \\frac{3(3s + 10) \\cdot 60}{s(3s + 25)(3s + 10)}VC​(s)=s(3s+25)(3s+10)3(3s+10)⋅60​\nVC(s)=180s(3s+25)V_C(s) = \\frac{180}{s(3s + 25)}VC​(s)=s(3s+25)180​\nStep 5: Add Initial Conditions Now given: vC(0)=2Vv_C(0) = 2VvC​(0)=2V\nThe initial condition voltage source vC(0)s=2s\\frac{v_C(0)}{s} = \\frac{2}{s}svC​(0)​=s2​ is in series with the capacitor impedance.\nWe need to go back to the original circuit and add this source.\nUpdated circuit with initial condition:\nV_s(s) = 12/s ---[4Ω]---+---[6Ω]--- ground | [20/s]---[+] [2/s] | ground The capacitor branch now has total impedance: 20s\\frac{20}{s}s20​ with a voltage source 2s\\frac{2}{s}s2​ in series.\nThis is more complex. Let’s use Node Analysis instead.\nStep 5 (Revised): Node Analysis with Initial Condition Let VC(s)V_C(s)VC​(s) be the voltage at the node between R1R_1R1​ and the parallel combination.\nApply KCL at this node:\nCurrent from source through R1R_1R1​: I1(s)=Vs(s)−VC(s)R1=12s−VC(s)4I_1(s) = \\frac{V_s(s) - V_C(s)}{R_1} = \\frac{\\frac{12}{s} - V_C(s)}{4}I1​(s)=R1​Vs​(s)−VC​(s)​=4s12​−VC​(s)​\nCurrent through R2R_2R2​: I2(s)=VC(s)R2=VC(s)6I_2(s) = \\frac{V_C(s)}{R_2} = \\frac{V_C(s)}{6}I2​(s)=R2​VC​(s)​=6VC​(s)​\nCurrent through capacitor (with initial condition):\nThe capacitor has impedance 20s\\frac{20}{s}s20​ and initial voltage source 2s\\frac{2}{s}s2​ in series.\nUsing the voltage across the capacitor branch: IC(s)=VC(s)−2s20s=VC(s)−2s20s=s[VC(s)−2s]20I_C(s) = \\frac{V_C(s) - \\frac{2}{s}}{\\frac{20}{s}} = \\frac{V_C(s) - \\frac{2}{s}}{\\frac{20}{s}} = \\frac{s[V_C(s) - \\frac{2}{s}]}{20}IC​(s)=s20​VC​(s)−s2​​=s20​VC​(s)−s2​​=20s[VC​(s)−s2​]​\nIC(s)=sVC(s)−220I_C(s) = \\frac{sV_C(s) - 2}{20}IC​(s)=20sVC​(s)−2​\nKCL: I1(s)=I2(s)+IC(s)I_1(s) = I_2(s) + I_C(s)I1​(s)=I2​(s)+IC​(s)\n12s−VC(s)4=VC(s)6+sVC(s)−220\\frac{\\frac{12}{s} - V_C(s)}{4} = \\frac{V_C(s)}{6} + \\frac{sV_C(s) - 2}{20}4s12​−VC​(s)​=6VC​(s)​+20sVC​(s)−2​\nMultiply through by 60 (LCM of 4, 6, 20):\n15[12s−VC(s)]=10VC(s)+3[sVC(s)−2]15\\left[\\frac{12}{s} - V_C(s)\\right] = 10V_C(s) + 3[sV_C(s) - 2]15[s12​−VC​(s)]=10VC​(s)+3[sVC​(s)−2]\n180s−15VC(s)=10VC(s)+3sVC(s)−6\\frac{180}{s} - 15V_C(s) = 10V_C(s) + 3sV_C(s) - 6s180​−15VC​(s)=10VC​(s)+3sVC​(s)−6\n180s+6=15VC(s)+10VC(s)+3sVC(s)\\frac{180}{s} + 6 = 15V_C(s) + 10V_C(s) + 3sV_C(s)s180​+6=15VC​(s)+10VC​(s)+3sVC​(s)\n180+6ss=VC(s)[25+3s]\\frac{180 + 6s}{s} = V_C(s)[25 + 3s]s180+6s​=VC​(s)[25+3s]\nSolve for VC(s)V_C(s)VC​(s):\nVC(s)=180+6ss(25+3s)=6(30+s)s(3s+25)V_C(s) = \\frac{180 + 6s}{s(25 + 3s)} = \\frac{6(30 + s)}{s(3s + 25)}VC​(s)=s(25+3s)180+6s​=s(3s+25)6(30+s)​\nVC(s)=2(30+s)s(s+253)V_C(s) = \\frac{2(30 + s)}{s(s + \\frac{25}{3})}VC​(s)=s(s+325​)2(30+s)​\nStep 6: Ready for Inverse Laplace Transform Final expression:\nVC(s)=2(30+s)s(s+253)=2s+60s(s+253)V_C(s) = \\frac{2(30 + s)}{s(s + \\frac{25}{3})} = \\frac{2s + 60}{s(s + \\frac{25}{3})}VC​(s)=s(s+325​)2(30+s)​=s(s+325​)2s+60​\nOr:\nVC(s)=6s+1803s(s+253)=6s+1803s2+25sV_C(s) = \\frac{6s + 180}{3s(s + \\frac{25}{3})} = \\frac{6s + 180}{3s^2 + 25s}VC​(s)=3s(s+325​)6s+180​=3s2+25s6s+180​\nAt this point, you would apply Inverse Laplace Transform using partial fraction expansion.\nDeriving Differential Equation from Example 6 If asked to find the differential equation that corresponds to the s-domain analysis:","additional-worked-example-mixed-circuit#Additional Worked Example: Mixed Circuit":"","advanced-tips#Advanced Tips":"","algebraic-errors#Algebraic Errors":"","alternative-derive-from-time-domain-kcl#Alternative: Derive from Time Domain KCL":"From the original circuit, at the node:\nvs(t)−vC(t)R1=vC(t)R2+CdvC(t)dt\\frac{v_s(t) - v_C(t)}{R_1} = \\frac{v_C(t)}{R_2} + C\\frac{dv_C(t)}{dt}R1​vs​(t)−vC​(t)​=R2​vC​(t)​+CdtdvC​(t)​\nSubstitute values: vs(t)=12u(t)v_s(t) = 12u(t)vs​(t)=12u(t), R1=4R_1 = 4R1​=4, R2=6R_2 = 6R2​=6, C=0.05C = 0.05C=0.05\n12−vC(t)4=vC(t)6+0.05dvC(t)dt\\frac{12 - v_C(t)}{4} = \\frac{v_C(t)}{6} + 0.05\\frac{dv_C(t)}{dt}412−vC​(t)​=6vC​(t)​+0.05dtdvC​(t)​\nMultiply by 12:\n3[12−vC(t)]=2vC(t)+0.6dvC(t)dt3[12 - v_C(t)] = 2v_C(t) + 0.6\\frac{dv_C(t)}{dt}3[12−vC​(t)]=2vC​(t)+0.6dtdvC​(t)​\n36−3vC(t)=2vC(t)+0.6dvC(t)dt36 - 3v_C(t) = 2v_C(t) + 0.6\\frac{dv_C(t)}{dt}36−3vC​(t)=2vC​(t)+0.6dtdvC​(t)​\n0.6dvC(t)dt+5vC(t)=360.6\\frac{dv_C(t)}{dt} + 5v_C(t) = 360.6dtdvC​(t)​+5vC​(t)=36\nDivide by 0.6:\ndvC(t)dt+253vC(t)=60\\frac{dv_C(t)}{dt} + \\frac{25}{3}v_C(t) = 60dtdvC​(t)​+325​vC​(t)=60\nThis is the first-order differential equation.","alternative-path-differential-equation-first#Alternative Path: Differential Equation First":"","analysis-method-selection-guide#Analysis Method Selection Guide":"","apply-inverse-correspondence#Apply Inverse Correspondence":"s2VC(s)→d2vC(t)dt2s^2V_C(s) \\rightarrow \\frac{d^2v_C(t)}{dt^2}s2VC​(s)→dt2d2vC​(t)​ (with initial conditions handled separately) sVC(s)→dvC(t)dtsV_C(s) \\rightarrow \\frac{dv_C(t)}{dt}sVC​(s)→dtdvC​(t)​ VC(s)→vC(t)V_C(s) \\rightarrow v_C(t)VC​(s)→vC​(t) s→ddts \\rightarrow \\frac{d}{dt}s→dtd​ (when applied to constants becomes derivative of that function) For the RHS: 6s+180→6ddt[constant]+1806s + 180 \\rightarrow 6\\frac{d}{dt}[\\text{constant}] + 1806s+180→6dtd​[constant]+180\nBut we need to track back to the source. The original source was 12u(t)12u(t)12u(t), so:\nThis is complex. The cleaner way: recognize that the differential equation would be derived from the time-domain KCL directly.","capacitor#Capacitor":"","choosing-between-path-a-and-path-b#Choosing Between PATH A and PATH B":"","common-circuit-transfer-functions#Common Circuit Transfer Functions":"","common-pitfalls#Common Pitfalls":"","complete-path-a-process#Complete PATH A Process":"","complete-path-b-process#Complete PATH B Process":"","complete-path-b-process-1#Complete PATH B Process":"","complete-time-domain-to-s-domain-table#Complete Time Domain to s-Domain Table":"","complete-worked-examples#Complete Worked Examples":"","component-transformation-equations#Component Transformation Equations":"","component-transformation-tips#Component Transformation Tips":"","comprehensive-guide-time-domain-to-s-domain-circuit-conversion#Comprehensive Guide: Time Domain to s-Domain Circuit Conversion":"","conceptual-errors#Conceptual Errors":"","conclusion#Conclusion":"This guide has covered the complete process of converting time-domain circuits to s-domain analysis:\nComponent transformations with detailed impedance and initial condition formulas Two distinct paths for circuit analysis (direct transformation vs. differential equation first) Complete step-by-step procedures for applying KVL/KCL in s-domain Methods for deriving differential equations from s-domain equations Multiple worked examples showing the entire process Reverse operations for working backwards through the process Practical tips and tricks for efficient problem-solving Common pitfalls to avoid The key insight is understanding that PATH A (direct s-domain transformation) gives you an algebraic equation in sss, while PATH B (differential equation first) explicitly shows the differential equation before transformation. Both approaches are valid and lead to the same result.\nYou are now prepared to:\nConvert any time-domain circuit to its s-domain equivalent Apply circuit analysis techniques in the s-domain Handle initial conditions correctly Set up equations ready for Laplace transformation or inverse transformation Work backwards to derive differential equations when needed The next step after this process is applying the Inverse Laplace Transform, which you mentioned you already have documentation for.","converting-s-domain-equation-to-differential-equation#Converting s-Domain Equation to Differential Equation":"","critical-clarification-on-differential-equations#Critical Clarification on \u0026ldquo;Differential Equations\u0026rdquo;":"","deriving-differential-equation-from-example-6#Deriving Differential Equation from Example 6":"","detailed-correspondence-rules#Detailed Correspondence Rules":"","detailed-steps-for-path-b#Detailed Steps for PATH B":"","detailed-transformation-rules#Detailed Transformation Rules":"","differential-equation-derivation-tips#Differential Equation Derivation Tips":"","differentiation-property-first-derivative#Differentiation Property (First Derivative)":"","equation-setup-tips#Equation Setup Tips":"","example-1-series-rc-circuit-path-a---standard-exam-format#Example 1: Series RC Circuit (PATH A - Standard Exam Format)":"","example-2-series-rl-circuit-with-initial-condition-path-a#Example 2: Series RL Circuit with Initial Condition (PATH A)":"","example-3-deriving-differential-equation-from-s-domain-path-a-with-step-3#Example 3: Deriving Differential Equation from s-Domain (PATH A with Step 3)":"","example-4-complete-path-b-process-differential-equation-first#Example 4: Complete PATH B Process (Differential Equation First)":"","example-5-parallel-rlc-with-node-analysis-path-a#Example 5: Parallel RLC with Node Analysis (PATH A)":"","example-6-mixed-series-parallel-circuit-complete-path-a#Example 6: Mixed Series-Parallel Circuit (Complete PATH A)":"","example-applying-laplace-transform-to-differential-equation#Example: Applying Laplace Transform to Differential Equation":"","example-converting-s-domain-to-differential-equation#Example: Converting s-Domain to Differential Equation":"","example-parallel-rlc-circuit---kcl-application#Example: Parallel RLC Circuit - KCL Application":"","example-series-rlc-circuit---kvl-application#Example: Series RLC Circuit - KVL Application":"","example-series-rlc-circuit-transformation#Example: Series RLC Circuit Transformation":"","final-checklist#Final Checklist":"Before stating “ready for inverse Laplace transform”:\ns-Domain equation is in the form V(s)=N(s)D(s)V(s) = \\frac{N(s)}{D(s)}V(s)=D(s)N(s)​ or I(s)=N(s)D(s)I(s) = \\frac{N(s)}{D(s)}I(s)=D(s)N(s)​ All initial conditions have been incorporated Algebraic simplification is complete Proper form for partial fraction expansion (degree of N(s)\u003cN(s) \u003cN(s)\u003c degree of D(s)D(s)D(s)) Units checked for consistency","final-summary-the-complete-journey#Final Summary: The Complete Journey":"","find-corresponding-differential-equation#Find: Corresponding Differential Equation":"","from-the-final-s-domain-equation#From the Final s-Domain Equation":"We have: VC(s)[s(3s+25)]=6s+180V_C(s)[s(3s + 25)] = 6s + 180VC​(s)[s(3s+25)]=6s+180\n3s2VC(s)+25sVC(s)=6s+1803s^2V_C(s) + 25sV_C(s) = 6s + 1803s2VC​(s)+25sVC​(s)=6s+180","general-strategy#General Strategy":"","given-s-domain-equation#Given: s-Domain Equation":"","important-clarification#IMPORTANT CLARIFICATION":"","inductor#Inductor":"","integration-property#Integration Property":"","inverse-correspondence-s-domain-to-time-domain-differential-equations#Inverse Correspondence (s-Domain to Time Domain Differential Equations)":"","inverse-laplace-correspondence-rules#Inverse Laplace Correspondence Rules":"","kcl-in-s-domain-node-analysis#KCL in s-Domain (Node Analysis)":"","key-time-domain-component-equations#Key Time-Domain Component Equations":"","kvl-in-s-domain-meshloop-analysis#KVL in s-Domain (Mesh/Loop Analysis)":"","laplace-transform-properties-for-path-b#Laplace Transform Properties (for PATH B)":"","laplace-transform-properties-summary#Laplace Transform Properties Summary":"","linearity-property#Linearity Property":"","option-a-s-domain-algebraic-equation-from-path-a#Option A: s-Domain Algebraic Equation (from PATH A)":"","option-b-time-domain-differential-equation-from-path-b#Option B: Time-Domain Differential Equation (from PATH B)":"","overview-and-order-of-operations#Overview and Order of Operations":"","part-1-given-time-domain-circuit#Part 1: Given Time Domain Circuit":"","part-1-given-time-domain-circuit-1#Part 1: Given Time Domain Circuit":"","part-1-given-time-domain-circuit-2#Part 1: Given Time Domain Circuit":"","part-1-given-time-domain-circuit-3#Part 1: Given Time Domain Circuit":"","part-2-apply-kvl-in-time-domain#Part 2: Apply KVL in Time Domain":"","part-2-convert-to-s-domain#Part 2: Convert to s-Domain":"","part-2-convert-to-s-domain-1#Part 2: Convert to s-Domain":"","part-2-convert-to-s-domain-2#Part 2: Convert to s-Domain":"","part-3-apply-kcl-at-top-node#Part 3: Apply KCL at Top Node":"","part-3-apply-kvl-in-s-domain#Part 3: Apply KVL in s-Domain":"","part-3-apply-kvl-in-s-domain-1#Part 3: Apply KVL in s-Domain":"","part-3-substitute-component-equations#Part 3: Substitute Component Equations":"","part-4-apply-laplace-transform#Part 4: Apply Laplace Transform":"","part-4-initial-conditions-given#Part 4: Initial Conditions Given":"","part-4-initial-conditions-given-1#Part 4: Initial Conditions Given":"","part-4-initial-conditions-given-later#Part 4: Initial Conditions Given Later":"","part-5-ready-for-inverse-laplace-transform#Part 5: Ready for Inverse Laplace Transform":"","part-5-ready-for-inverse-laplace-transform-1#Part 5: Ready for Inverse Laplace Transform":"","part-5-ready-for-inverse-laplace-transform-2#Part 5: Ready for Inverse Laplace Transform":"","part-5-ready-for-inverse-laplace-transform-3#Part 5: Ready for Inverse Laplace Transform":"","path-a-direct-s-domain-transformation-most-common-in-exams#PATH A: Direct s-Domain Transformation (Most Common in Exams)":"","path-a-most-common-direct-s-domain-transformation#PATH A (Most Common): Direct s-Domain Transformation":"Start: Time domain circuit with components and sources Transform: Replace all components with s-domain equivalents (impedances) Draw: s-Domain circuit diagram (without initial conditions initially) Analyze: Apply KVL or KCL to get algebraic equation in sss Initial Conditions: When given, add initial condition sources to circuit and equation Solve: Algebraically solve for V(s)V(s)V(s) or I(s)I(s)I(s) Result: Expression ready for inverse Laplace transform Key Point: You get an algebraic equation in sss, not a differential equation. The differential equation is implicit.","path-b-alternative-differential-equation-first#PATH B (Alternative): Differential Equation First":"Start: Time domain circuit Analyze: Apply KVL or KCL in time domain Substitute: Use component relationships (v=Riv = Riv=Ri, v=Ldidtv = L\\frac{di}{dt}v=Ldtdi​, i=Cdvdti = C\\frac{dv}{dt}i=Cdtdv​) Derive: Form differential equation in one variable Transform: Apply Laplace transform using differentiation property Initial Conditions: Substitute initial values from differentiation property Solve: Algebraically solve for V(s)V(s)V(s) or I(s)I(s)I(s) Result: Expression ready for inverse Laplace transform Key Point: You explicitly write the differential equation before transforming.","path-b-differential-equation-first-alternative-method#PATH B: Differential Equation First (Alternative Method)":"","problem-format#Problem Format":"","problem-solving-workflow#Problem-Solving Workflow":"","problem-statement#Problem Statement":"","quick-reference-tables#Quick Reference Tables":"","resistor#Resistor":"","reverse-operation-1-s-domain-to-time-domain-circuit#Reverse Operation 1: s-Domain to Time Domain Circuit":"","reverse-operation-2-s-domain-equation-to-differential-equation#Reverse Operation 2: s-Domain Equation to Differential Equation":"","reverse-operation-3-kvlkcl-back-to-circuit#Reverse Operation 3: KVL/KCL Back to Circuit":"","reverse-operation-4-differential-equation-to-kvlkcl#Reverse Operation 4: Differential Equation to KVL/KCL":"","reverse-transformation-table#Reverse Transformation Table":"","rule-1-basic-substitution#Rule 1: Basic Substitution":"","rule-1-resistor-transformation#Rule 1: Resistor Transformation":"","rule-2-capacitor-transformation#Rule 2: Capacitor Transformation":"","rule-2-multiplication-by--first-derivative#Rule 2: Multiplication by  (First Derivative)":"","rule-3-inductor-transformation#Rule 3: Inductor Transformation":"","rule-3-multiplication-by--second-derivative#Rule 3: Multiplication by  (Second Derivative)":"","rule-4-division-by--integration#Rule 4: Division by  (Integration)":"","rule-4-voltage-source-transformation#Rule 4: Voltage Source Transformation":"","rule-5-current-source-transformation#Rule 5: Current Source Transformation":"","s-domain-transformations-summary#s-Domain Transformations Summary":"","second-derivative-property#Second Derivative Property":"","sign-and-polarity-errors#Sign and Polarity Errors":"","step-1-apply-kvl-or-kcl-in-time-domain#Step 1: Apply KVL or KCL in Time Domain":"","step-1-convert-to-s-domain#Step 1: Convert to s-Domain":"","step-1-time-domain-circuit-to-s-domain-circuit#Step 1: Time Domain Circuit to s-Domain Circuit":"","step-2-apply-kvlkcl-to-s-domain-circuit#Step 2: Apply KVL/KCL to s-Domain Circuit":"","step-2-simplify-circuit---combine-parallel-elements#Step 2: Simplify Circuit - Combine Parallel Elements":"","step-2-substitute-component-equations#Step 2: Substitute Component Equations":"","step-3-apply-kvl#Step 3: Apply KVL":"","step-3-derive-differential-equations-from-s-domain#Step 3: Derive Differential Equations from s-Domain":"","step-3-eliminate-integralsderivatives#Step 3: Eliminate Integrals/Derivatives":"","step-4-apply-laplace-transform#Step 4: Apply Laplace Transform":"","step-4-find-voltage-across-capacitor#Step 4: Find Voltage Across Capacitor":"","step-4-setup-for-laplace-transform#Step 4: Setup for Laplace Transform":"","step-5-add-initial-conditions#Step 5: Add Initial Conditions":"","step-5-revised-node-analysis-with-initial-condition#Step 5 (Revised): Node Analysis with Initial Condition":"","step-6-ready-for-inverse-laplace-transform#Step 6: Ready for Inverse Laplace Transform":"","summary-flow-charts#Summary Flow Charts":"","table-of-contents#Table of Contents":"","the-bridge-converting-between-representations#The Bridge: Converting Between Representations":"You can always:\nTake an s-domain algebraic equation → derive the corresponding differential equation (inverse correspondence) Take a differential equation → apply Laplace transform → get s-domain equation (forward transformation) Take an s-domain circuit → work backwards to time domain circuit (reverse transformation)","the-standard-problem-progression#The Standard Problem Progression":"","tips-and-tricks#Tips and Tricks":"","transformation-errors#Transformation Errors":"","transformation-process#Transformation Process":"","understanding-the-reverse-process#Understanding the Reverse Process":"","units-and-scaling-errors#Units and Scaling Errors":"","using-kirchhoffs-laws-in-s-domain#Using Kirchhoff\u0026rsquo;s Laws in s-Domain":"","verification-tips#Verification Tips":"","when-to-use-this-path#When to Use This Path":"","which-path-to-choose#Which Path to Choose?":"Use PATH A when:\nProblem says “convert to s-domain” You want to work directly with impedances Circuit is complex with multiple components Exam time pressure Use PATH B when:\nProblem explicitly asks for differential equation You need to understand the physics Circuit is simple (RC or RL) You’re more comfortable with time-domain analysis Both paths lead to the same s-domain result!","working-backwards-inverse-operations#Working Backwards: Inverse Operations":""},"title":"time_to_s_to_diffeq_to_laplace"},"/electrical_notes/ee_300/tmp/":{"data":{"":"would you please divide this documentation up into modular smaller files respective to each high level topic and methodology, such as how to convert to s domain and get a differential equation, then the full process to go from time domain to s domain to diffeq to laplace. then the inverse of thos processes and more?"},"title":"tmp"},"/electrical_notes/ee_300/zir_zsr_cheatsheet/":{"data":{"calculating-total-response#Calculating Total Response":"Steps:\nAdd responses: vtotal(t)=vZSR(t)+vZIR(t)v_{\\text{total}}(t) = v_{\\text{ZSR}}(t) + v_{\\text{ZIR}}(t)vtotal​(t)=vZSR​(t)+vZIR​(t) Verify initial value: Check vtotal(0+)v_{\\text{total}}(0^+)vtotal​(0+) matches initial condition Verify final value: Check vtotal(∞)v_{\\text{total}}(\\infty)vtotal​(∞) matches DC steady state","calculating-zir-zero-input-response#Calculating ZIR (Zero-Input Response)":"Given: Circuit with input source and initial conditions\nSteps:\nTransform to S-domain: Replace all components with S-domain equivalents Zero input sources: Short voltage sources, open current sources Keep initial conditions: Leave initial condition sources active Capacitor: Keep vC(0−)s\\frac{v_C(0^-)}{s}svC​(0−)​ voltage source (or CvC(0−)Cv_C(0^-)CvC​(0−) current source) Inductor: Keep LiL(0−)Li_L(0^-)LiL​(0−) voltage source (or iL(0−)s\\frac{i_L(0^-)}{s}siL​(0−)​ current source) Analyze circuit: Use KVL/KCL/nodal/mesh to find VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s) or IZIR(s)I_{\\text{ZIR}}(s)IZIR​(s) Apply PFE: Factor denominator and find residues Inverse transform: Get vZIR(t)v_{\\text{ZIR}}(t)vZIR​(t) or iZIR(t)i_{\\text{ZIR}}(t)iZIR​(t)","calculating-zsr-zero-state-response#Calculating ZSR (Zero-State Response)":"Given: Circuit with input source and initial conditions\nSteps:\nTransform to S-domain: Replace all components with S-domain equivalents Zero initial conditions: Remove (short/open) all initial condition sources Capacitor: Remove vC(0−)s\\frac{v_C(0^-)}{s}svC​(0−)​ voltage source (or CvC(0−)Cv_C(0^-)CvC​(0−) current source) Inductor: Remove LiL(0−)Li_L(0^-)LiL​(0−) voltage source (or iL(0−)s\\frac{i_L(0^-)}{s}siL​(0−)​ current source) Keep input active: Leave Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s) in circuit Analyze circuit: Use KVL/KCL/nodal/mesh to find VZSR(s)V_{\\text{ZSR}}(s)VZSR​(s) or IZSR(s)I_{\\text{ZSR}}(s)IZSR​(s) Apply PFE: Factor denominator and find residues Inverse transform: Get vZSR(t)v_{\\text{ZSR}}(t)vZSR​(t) or iZSR(t)i_{\\text{ZSR}}(t)iZSR​(t)","capacitor#Capacitor":"","common-mistakes#Common Mistakes":"❌ Forgetting to zero initial conditions when calculating ZSR ❌ Forgetting to zero input when calculating ZIR ❌ Wrong polarity on inductor initial voltage source (should be −LiL(0−)-Li_L(0^-)−LiL​(0−)) ❌ Not verifying total response matches initial and final values ❌ Confusing natural response with ZIR (ZSR also has natural component!)","definitions#Definitions":"","finding-initial-conditions-for-#Finding Initial Conditions (for )":"Zero-Input Response (ZIR) and Zero-State Response (ZSR)Fundamental Concept vtotal(t)=vZSR(t)+vZIR(t)\\boxed{v_{\\text{total}}(t) = v_{\\text{ZSR}}(t) + v_{\\text{ZIR}}(t)}vtotal​(t)=vZSR​(t)+vZIR​(t)​Vtotal(s)=VZSR(s)+VZIR(s)\\boxed{V_{\\text{total}}(s) = V_{\\text{ZSR}}(s) + V_{\\text{ZIR}}(s)}Vtotal​(s)=VZSR​(s)+VZIR​(s)​ Definitions Zero-Input Response (ZIR) Response due to initial conditions only, with input set to zero.\nCaused by: Initial capacitor voltage vC(0−)v_C(0^-)vC​(0−) or inductor current iL(0−)i_L(0^-)iL​(0−) Input sources: Set to zero (voltage → short, current → open) Nature: Pure natural response (exponential decay) In S-domain: Generated by initial condition sources vC(0−)s\\frac{v_C(0^-)}{s}svC​(0−)​ or LiL(0−)Li_L(0^-)LiL​(0−) Zero-State Response (ZSR) Response due to input source only, with initial conditions set to zero.\nCaused by: External input vs(t)v_s(t)vs​(t) or is(t)i_s(t)is​(t) Initial conditions: Set to zero (vC(0−)=0v_C(0^-) = 0vC​(0−)=0, iL(0−)=0i_L(0^-) = 0iL​(0−)=0) Nature: Natural response + forced response In S-domain: Generated by input sources Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s) S-Domain Component Models Capacitor Impedance: ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​\nSeries model (use with KVL): VC(s)=1sCIC(s)+vC(0−)sV_C(s) = \\frac{1}{sC} I_C(s) + \\frac{v_C(0^-)}{s}VC​(s)=sC1​IC​(s)+svC​(0−)​Parallel model (use with KCL): IC(s)=sC⋅VC(s)−CvC(0−)I_C(s) = sC \\cdot V_C(s) - Cv_C(0^-)IC​(s)=sC⋅VC​(s)−CvC​(0−)Inductor Impedance: ZL=sLZ_L = sLZL​=sL\nSeries model (use with KVL): VL(s)=sL⋅IL(s)−LiL(0−)V_L(s) = sL \\cdot I_L(s) - Li_L(0^-)VL​(s)=sL⋅IL​(s)−LiL​(0−)Parallel model (use with KCL): IL(s)=VL(s)sL+iL(0−)sI_L(s) = \\frac{V_L(s)}{sL} + \\frac{i_L(0^-)}{s}IL​(s)=sLVL​(s)​+siL​(0−)​ Step-by-Step Solution Process Finding Initial Conditions (for t\u003c0t \u003c 0t\u003c0) Replace capacitors with open circuits (no current) Replace inductors with short circuits (no voltage) Solve DC circuit to find vC(0−)v_C(0^-)vC​(0−) and iL(0−)i_L(0^-)iL​(0−) Apply continuity: vC(0+)=vC(0−)v_C(0^+) = v_C(0^-)vC​(0+)=vC​(0−) and iL(0+)=iL(0−)i_L(0^+) = i_L(0^-)iL​(0+)=iL​(0−)","fundamental-concept#Fundamental Concept":"","inductor#Inductor":"","quick-reference-summary#Quick Reference Summary":"Aspect ZIR ZSR Cause Initial conditions only Input sources only Initial Conditions Active Zeroed Input Sources Zeroed Active Response Type Pure natural response Natural + forced Physical Meaning Stored energy dissipation System driven by input","s-domain-component-models#S-Domain Component Models":"","step-by-step-solution-process#Step-by-Step Solution Process":"","time-constants#Time Constants":"Series/Parallel RC: τ=RC\\tau = RCτ=RC\nSeries RL: τ=LR\\tau = \\frac{L}{R}τ=RL​\nParallel RL: τ=LR\\tau = \\frac{L}{R}τ=RL​","zero-input-response-zir#Zero-Input Response (ZIR)":"","zero-input-response-zir-and-zero-state-response-zsr#Zero-Input Response (ZIR) and Zero-State Response (ZSR)":"","zero-state-response-zsr#Zero-State Response (ZSR)":""},"title":"zir_zsr_cheatsheet"},"/electrical_notes/ee_300/zir_zsr_claude/":{"data":{"":"","-domain-device-characteristics-and-initial-conditions#-Domain Device Characteristics and Initial Conditions":"","1-theory-background-zir-and-zsr#1. Theory Background: ZIR and ZSR":"","2-relevant-topics-to-understand#2. Relevant Topics to Understand":"","3-step-by-step-methods-and-processes#3. Step-by-Step Methods and Processes":"","4-relevant-equations#4. Relevant Equations":"","5-partial-fraction-expansion-pfe#5. Partial Fraction Expansion (PFE)":"","6-worked-example-series-rc-circuit#6. Worked Example: Series RC Circuit":"","7-key-insights-and-common-mistakes#7. Key Insights and Common Mistakes":"","8-summary-table#8. Summary Table":"Aspect ZIR ZSR Cause Initial conditions only Input sources only Initial Conditions vC(0)≠0v_C(0) \\neq 0vC​(0)=0, iL(0)≠0i_L(0) \\neq 0iL​(0)=0 vC(0)=0v_C(0) = 0vC​(0)=0, iL(0)=0i_L(0) = 0iL​(0)=0 Input Sources Set to zero (short/open) Active Response Type Pure natural response Natural + forced response Physical Meaning Energy relaxation System response to excitation Time Constant Determined by RRR, LLL, CCC Same as ZIR","9-practice-problems#9. Practice Problems":"","capacitor--domain-model#Capacitor -Domain Model":"","common-mistakes#Common Mistakes":"Forgetting initial condition sources when calculating ZIR Not zeroing initial conditions when calculating ZSR Incorrect sss-domain models for capacitors and inductors Sign errors in initial condition sources Not verifying that ZIR + ZSR equals total response Confusing natural response with ZIR (ZSR also has a natural component!)","complex-conjugate-poles#Complex Conjugate Poles":"","detailed-process-for-zirzsr-separation-superposition-method#Detailed Process for ZIR/ZSR Separation (Superposition Method)":"","distinct-real-poles#Distinct Real Poles":"","general-form#General Form":"","inductor--domain-model#Inductor -Domain Model":"","key-insights#Key Insights":"Natural vs. Forced Response:\nZIR contains only the natural response (exponential decay based on circuit poles) ZSR contains both natural and forced responses Time Constants:\nBoth ZIR and ZSR exhibit the same time constants (determined by circuit poles) The difference is in the coefficients and the presence of forced response in ZSR Energy Considerations:\nZIR represents the release of initially stored energy ZSR represents energy delivered by the input source Superposition Validity:\nOnly valid for linear circuits Cannot be applied to circuits with nonlinear elements","laplace-transform-properties#Laplace Transform Properties":"","overview#Overview":"","physical-interpretation#Physical Interpretation":"ZIR: The capacitor initially at 5 V5\\,\\text{V}5V discharges exponentially toward 0 V0\\,\\text{V}0V with time constant τ=RC=1 s\\tau = RC = 1\\,\\text{s}τ=RC=1s ZSR: Starting from 0 V0\\,\\text{V}0V, the capacitor charges toward the input voltage 10 V10\\,\\text{V}10V with the same time constant Total: The capacitor voltage transitions from 5 V5\\,\\text{V}5V to 10 V10\\,\\text{V}10V exponentially","problem-1-series-rl-circuit#Problem 1: Series RL Circuit":"A series RL circuit has R=4 ΩR = 4\\,\\OmegaR=4Ω, L=2 HL = 2\\,\\text{H}L=2H, input vs(t)=12u(t) Vv_s(t) = 12u(t)\\,\\text{V}vs​(t)=12u(t)V, and iL(0)=1 Ai_L(0) = 1\\,\\text{A}iL​(0)=1A.\nFind iL(t)i_L(t)iL​(t) for t≥0t \\ge 0t≥0, separating into ZIR and ZSR.\nHint: Time constant τ=LR\\tau = \\frac{L}{R}τ=RL​","problem-2-parallel-rc-circuit#Problem 2: Parallel RC Circuit":"A parallel RC circuit has R=5 ΩR = 5\\,\\OmegaR=5Ω, C=0.2 FC = 0.2\\,\\text{F}C=0.2F, input current is(t)=2u(t) Ai_s(t) = 2u(t)\\,\\text{A}is​(t)=2u(t)A, and vC(0)=3 Vv_C(0) = 3\\,\\text{V}vC​(0)=3V.\nFind vC(t)v_C(t)vC​(t) for t≥0t \\ge 0t≥0, separating into ZIR and ZSR.\nHint: For parallel RC, τ=RC\\tau = RCτ=RC","references-and-further-reading#References and Further Reading":"Laplace Transform Tables: Essential for inverse transforms Circuit Analysis Textbooks: Alexander \u0026 Sadiku, Nilsson \u0026 Riedel Control Systems: Understanding poles and zeros Differential Equations: Foundation for circuit dynamics","repeated-poles#Repeated Poles":"","step-1--domain-circuit#Step 1: -Domain Circuit":"This documentation provides a comprehensive explanation of the Zero-Input Response (ZIR) and Zero-State Response (ZSR), drawing upon circuit theory concepts solved using the Laplace Transform (LT) methodology.\nOverview The total response of a linear circuit can be separated into two fundamental components: the zero-state response (ZSR) and the zero-input response (ZIR). This separation is possible because of the linearity property and the principle of superposition.\nTotal Response=Zero-State Response (ZSR)+Zero-Input Response (ZIR)\\text{Total Response} = \\text{Zero-State Response (ZSR)} + \\text{Zero-Input Response (ZIR)}Total Response=Zero-State Response (ZSR)+Zero-Input Response (ZIR)1. Theory Background: ZIR and ZSR Zero-Input Response (ZIR) The Zero-Input Response (ZIR) is the behavior of the circuit due solely to the initial conditions of energy storage elements (like capacitors or inductors), assuming no external input sources are active.\nDefinition: ZIR is the response due to the initial voltage on capacitors (or current in inductors). It is calculated as if there were zero input. Circuit State: To calculate ZIR, the input source (VsV_sVs​ or IsI_sIs​) of the circuit is set to zero. For voltage sources, this means replacing them with short circuits. For current sources, this means replacing them with open circuits. Nature: ZIR is the behavior due to device characteristics (R, C, L values) and is not related to any external sources. Consequently, all ZIRs are natural responses. The poles determining the natural characteristics are due to the values of R, C, and L. Physical Interpretation: ZIR represents the “decay” or “relaxation” of energy initially stored in the circuit. Zero-State Response (ZSR) The Zero-State Response (ZSR) is the behavior of the circuit due solely to the external input sources, assuming all initial energy storage in the circuit is zero.\nDefinition: ZSR is the response due to the input source, assuming a zero initial state (i.e., vC(0)=0v_C(0) = 0vC​(0)=0 for capacitors and iL(0)=0i_L(0) = 0iL​(0)=0 for inductors). Circuit State: To calculate ZSR, the initial state of all energy storage elements is set to zero. Response Origin: ZSR is the voltage (or current) that develops purely from the external excitation. Components: ZSR typically contains both a natural response component (due to circuit poles) and a forced response component (matching the form of the input). 2. Relevant Topics to Understand Understanding ZIR and ZSR primarily requires the application of the Laplace Transform (LT) to circuit analysis, specifically in the sss-domain.\nRelevant Topic Subtopics and Importance Laplace Transform (LT) and sss-Domain LT converts circuits from the time domain to the frequency (sss) domain, transforming differential equations into algebraic equations that are easier to solve. The Inverse LT converts the expression back to the time domain. LT Properties Properties like differentiation and integration are crucial for transforming differential equations involving inductors and capacitors, respectively. sss-Domain Device Characteristics Resistors: ZR=RZ_R = RZR​=R. Capacitors: ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​. Inductors: ZL=sLZ_L = sLZL​=sL. Each reactive element also has an associated initial condition term. Modeling Initial Conditions Initial conditions (energy stored at t=0t=0t=0) are converted into equivalent sources in the sss-domain. For a capacitor with initial voltage vC(0)v_C(0)vC​(0), this appears as a voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ in series with the impedance. For an inductor with initial current iL(0)i_L(0)iL​(0), this appears as a current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​ in parallel (or voltage source LiL(0)Li_L(0)LiL​(0) in series). Inverse LT Techniques Once the response in the sss-domain (V(s)V(s)V(s) or I(s)I(s)I(s)) is found, the Inverse LT is performed, often requiring Partial Fraction Expansion (PFE) and the cover-up method to find residues. Network Function The transfer function H(s)=Y(s)X(s)H(s) = \\frac{Y(s)}{X(s)}H(s)=X(s)Y(s)​ (output/input) characterizes the system. The roots of the denominator define the system poles, which determine the natural response. 3. Step-by-Step Methods and Processes Solving problems involving ZIR and ZSR typically involves applying the principle of superposition within the sss-domain.\nStep-by-Step Method (General Circuit Analysis using LT) The process of solving circuits using LT, including finding the total response, generally follows these steps:\nDerive the Differential Equation: Develop the differential equation(s) that describe the circuit in the time domain, usually by applying KVL (Kirchhoff’s Voltage Law) or KCL (Kirchhoff’s Current Law).\nAnalyze for t\u003c0t\u003c0t\u003c0 (Initial Conditions): Use circuit knowledge and DC steady-state analysis to find the initial conditions. For t\u003c0t \u003c 0t\u003c0, assume the circuit is in steady state:\nCapacitors act as open circuits (no current flows) Inductors act as short circuits (no voltage drop) Find vC(0−)v_C(0^-)vC​(0−) and iL(0−)i_L(0^-)iL​(0−) Apply Continuity: Use continuity conditions:\nCapacitor voltage cannot change instantaneously: vC(0+)=vC(0−)v_C(0^+) = v_C(0^-)vC​(0+)=vC​(0−) Inductor current cannot change instantaneously: iL(0+)=iL(0−)i_L(0^+) = i_L(0^-)iL​(0+)=iL​(0−) Transform to sss-Domain: For t≥0t \\ge 0t≥0, transform the circuit to the sss-domain:\nReplace each element with its sss-domain equivalent Include initial condition sources Transform input sources using Laplace Transform tables Solve for the sss-Domain Variable: Solve the resulting algebraic equations for the variable of interest, V(s)V(s)V(s) or I(s)I(s)I(s), using circuit analysis techniques (nodal analysis, mesh analysis, voltage/current division, etc.).\nSeparate into ZSR and ZIR (Superposition): Use superposition to explicitly separate the total response V(s)V(s)V(s) into VZSR(s)V_{\\text{ZSR}}(s)VZSR​(s) and VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s).\nInverse Transform: Perform the Inverse LT on VZSR(s)V_{\\text{ZSR}}(s)VZSR​(s) and VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s) separately using PFE and Laplace Transform tables to get vZSR(t)v_{\\text{ZSR}}(t)vZSR​(t) and vZIR(t)v_{\\text{ZIR}}(t)vZIR​(t).\nCalculate Total Response: Combine the responses: vtotal(t)=vZSR(t)+vZIR(t)for t≥0v_{\\text{total}}(t) = v_{\\text{ZSR}}(t) + v_{\\text{ZIR}}(t) \\quad \\text{for } t \\ge 0vtotal​(t)=vZSR​(t)+vZIR​(t)for t≥0 Detailed Process for ZIR/ZSR Separation (Superposition Method) The separation of ZIR and ZSR is achieved by modeling the circuit elements in the sss-domain and applying the superposition principle:\nPhase 1: Zero-State Response (ZSR) Calculation\nZero Initial Conditions: In the sss-domain equivalent circuit, set all initial condition sources to zero.\nFor a capacitor, remove (short-circuit) the vC(0)s\\frac{v_C(0)}{s}svC​(0)​ voltage source For an inductor, remove (open-circuit) the iL(0)s\\frac{i_L(0)}{s}siL​(0)​ current source Keep External Sources: Keep all external input sources (Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s)) active.\nCalculate sss-Domain ZSR: Analyze the circuit using standard techniques:\nNodal analysis (KCL at nodes) Mesh analysis (KVL around loops) Voltage/current division Thévenin/Norton equivalents Result: Obtain VZSR(s)V_{\\text{ZSR}}(s)VZSR​(s) or IZSR(s)I_{\\text{ZSR}}(s)IZSR​(s)\nInverse LT: Find vZSR(t)v_{\\text{ZSR}}(t)vZSR​(t) by applying the Inverse Laplace Transform to VZSR(s)V_{\\text{ZSR}}(s)VZSR​(s) using PFE.\nPhase 2: Zero-Input Response (ZIR) Calculation\nZero External Sources: Set all external input sources to zero:\nShort-circuit voltage sources (replace with wire) Open-circuit current sources (remove from circuit) Keep Initial Conditions: Keep all initial condition sources active:\nCapacitor: vC(0)s\\frac{v_C(0)}{s}svC​(0)​ voltage source in series with 1sC\\frac{1}{sC}sC1​ Inductor: iL(0)s\\frac{i_L(0)}{s}siL​(0)​ current source in parallel with sLsLsL (or equivalently, LiL(0)Li_L(0)LiL​(0) voltage source in series) Calculate sss-Domain ZIR: Analyze the resulting circuit to find the response VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s) (or IZIR(s)I_{\\text{ZIR}}(s)IZIR​(s)) due only to the initial conditions.\nResult: Obtain VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s) or IZIR(s)I_{\\text{ZIR}}(s)IZIR​(s)\nInverse LT: Find vZIR(t)v_{\\text{ZIR}}(t)vZIR​(t) by applying the Inverse Laplace Transform to VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s).\nPhase 3: Total Response\nSum in sss-Domain: Vtotal(s)=VZSR(s)+VZIR(s)V_{\\text{total}}(s) = V_{\\text{ZSR}}(s) + V_{\\text{ZIR}}(s)Vtotal​(s)=VZSR​(s)+VZIR​(s) Sum in Time Domain: vtotal(t)=vZSR(t)+vZIR(t)for t≥0v_{\\text{total}}(t) = v_{\\text{ZSR}}(t) + v_{\\text{ZIR}}(t) \\quad \\text{for } t \\ge 0vtotal​(t)=vZSR​(t)+vZIR​(t)for t≥0 4. Relevant Equations The analysis of ZIR and ZSR occurs entirely within the framework of linear circuit analysis using the Laplace Transform.\nSuperposition Principle (Total Response) Total Response=Response due to Input Sources+Response due to Initial Conditions\\text{Total Response} = \\text{Response due to Input Sources} + \\text{Response due to Initial Conditions}Total Response=Response due to Input Sources+Response due to Initial ConditionsVtotal(s)=VZSR(s)+VZIR(s)V_{\\text{total}}(s) = V_{\\text{ZSR}}(s) + V_{\\text{ZIR}}(s)Vtotal​(s)=VZSR​(s)+VZIR​(s)vtotal(t)=vZSR(t)+vZIR(t)v_{\\text{total}}(t) = v_{\\text{ZSR}}(t) + v_{\\text{ZIR}}(t)vtotal​(t)=vZSR​(t)+vZIR​(t)sss-Domain Device Characteristics and Initial Conditions Device Time Domain Relation sss-Domain Impedance Initial Condition Model Resistor (R) vR(t)=R⋅iR(t)v_R(t) = R \\cdot i_R(t)vR​(t)=R⋅iR​(t) ZR=RZ_R = RZR​=R None (no energy storage) Capacitor (C) iC(t)=CdvCdti_C(t) = C \\frac{dv_C}{dt}iC​(t)=CdtdvC​​ ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​ Voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​ in series Inductor (L) vL(t)=LdiLdtv_L(t) = L \\frac{di_L}{dt}vL​(t)=LdtdiL​​ ZL=sLZ_L = sLZL​=sL Current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​ in parallel (or voltage source LiL(0)Li_L(0)LiL​(0) in series) Capacitor sss-Domain Model A capacitor with initial voltage vC(0)v_C(0)vC​(0) is modeled as:\nVC(s)=1sCIC(s)+vC(0)sV_C(s) = \\frac{1}{sC} I_C(s) + \\frac{v_C(0)}{s}VC​(s)=sC1​IC​(s)+svC​(0)​Or equivalently, as an impedance 1sC\\frac{1}{sC}sC1​ in series with a voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​.\nInductor sss-Domain Model An inductor with initial current iL(0)i_L(0)iL​(0) is modeled as:\nVL(s)=sL⋅IL(s)−LiL(0)V_L(s) = sL \\cdot I_L(s) - Li_L(0)VL​(s)=sL⋅IL​(s)−LiL​(0)Or equivalently, as an impedance sLsLsL in series with a voltage source −LiL(0)-Li_L(0)−LiL​(0) (or +LiL(0)+Li_L(0)+LiL​(0) with opposite polarity).\nAlternatively, using current:\nIL(s)=VL(s)sL+iL(0)sI_L(s) = \\frac{V_L(s)}{sL} + \\frac{i_L(0)}{s}IL​(s)=sLVL​(s)​+siL​(0)​This represents an impedance sLsLsL in parallel with a current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​.\nLaplace Transform Properties Differentiation Property:\nL{df(t)dt}=sF(s)−f(0)\\mathcal{L}\\left\\{\\frac{df(t)}{dt}\\right\\} = sF(s) - f(0)L{dtdf(t)​}=sF(s)−f(0)Integration Property:\nL{∫0tf(τ)dτ}=F(s)s\\mathcal{L}\\left\\{\\int_0^t f(\\tau)d\\tau\\right\\} = \\frac{F(s)}{s}L{∫0t​f(τ)dτ}=sF(s)​Common Transform Pairs:\nTime Domain f(t)f(t)f(t) Laplace Domain F(s)F(s)F(s) Condition δ(t)\\delta(t)δ(t) (unit impulse) 111 u(t)u(t)u(t) (unit step) 1s\\frac{1}{s}s1​ e−atu(t)e^{-at}u(t)e−atu(t) 1s+a\\frac{1}{s+a}s+a1​ a\u003e0a \u003e 0a\u003e0 te−atu(t)te^{-at}u(t)te−atu(t) 1(s+a)2\\frac{1}{(s+a)^2}(s+a)21​ sin⁡(ωt)u(t)\\sin(\\omega t)u(t)sin(ωt)u(t) ωs2+ω2\\frac{\\omega}{s^2 + \\omega^2}s2+ω2ω​ cos⁡(ωt)u(t)\\cos(\\omega t)u(t)cos(ωt)u(t) ss2+ω2\\frac{s}{s^2 + \\omega^2}s2+ω2s​ 5. Partial Fraction Expansion (PFE) To perform the inverse Laplace transform, we typically need to decompose V(s)V(s)V(s) into simpler fractions using PFE.\nGeneral Form For a rational function:\nV(s)=N(s)D(s)=bmsm+bm−1sm−1+⋯+b0ansn+an−1sn−1+⋯+a0V(s) = \\frac{N(s)}{D(s)} = \\frac{b_ms^m + b_{m-1}s^{m-1} + \\cdots + b_0}{a_ns^n + a_{n-1}s^{n-1} + \\cdots + a_0}V(s)=D(s)N(s)​=an​sn+an−1​sn−1+⋯+a0​bm​sm+bm−1​sm−1+⋯+b0​​where m\u003cnm \u003c nm\u003cn (proper fraction), we factor the denominator:\nD(s)=an(s−p1)(s−p2)⋯(s−pn)D(s) = a_n(s - p_1)(s - p_2)\\cdots(s - p_n)D(s)=an​(s−p1​)(s−p2​)⋯(s−pn​)Distinct Real Poles If all poles p1,p2,…,pnp_1, p_2, \\ldots, p_np1​,p2​,…,pn​ are distinct:\nV(s)=k1s−p1+k2s−p2+⋯+kns−pnV(s) = \\frac{k_1}{s - p_1} + \\frac{k_2}{s - p_2} + \\cdots + \\frac{k_n}{s - p_n}V(s)=s−p1​k1​​+s−p2​k2​​+⋯+s−pn​kn​​Cover-Up Method: To find residue kik_iki​:\nki=[(s−pi)V(s)]s=pik_i = \\left[(s - p_i)V(s)\\right]_{s=p_i}ki​=[(s−pi​)V(s)]s=pi​​Repeated Poles If pole p1p_1p1​ has multiplicity rrr:\nV(s)=k1,r(s−p1)r+k1,r−1(s−p1)r−1+⋯+k1,1s−p1+(other terms)V(s) = \\frac{k_{1,r}}{(s - p_1)^r} + \\frac{k_{1,r-1}}{(s - p_1)^{r-1}} + \\cdots + \\frac{k_{1,1}}{s - p_1} + \\text{(other terms)}V(s)=(s−p1​)rk1,r​​+(s−p1​)r−1k1,r−1​​+⋯+s−p1​k1,1​​+(other terms)Residue Formulas:\nk1,r=[(s−p1)rV(s)]s=p1k_{1,r} = \\left[(s - p_1)^r V(s)\\right]_{s=p_1}k1,r​=[(s−p1​)rV(s)]s=p1​​k1,j=1(r−j)!dr−jdsr−j[(s−p1)rV(s)]s=p1k_{1,j} = \\frac{1}{(r-j)!} \\frac{d^{r-j}}{ds^{r-j}}\\left[(s - p_1)^r V(s)\\right]_{s=p_1}k1,j​=(r−j)!1​dsr−jdr−j​[(s−p1​)rV(s)]s=p1​​Complex Conjugate Poles If poles are complex: p=−α±jωp = -\\alpha \\pm j\\omegap=−α±jω\nV(s)=ks−(−α+jω)+k∗s−(−α−jω)+(other terms)V(s) = \\frac{k}{s - (-\\alpha + j\\omega)} + \\frac{k^*}{s - (-\\alpha - j\\omega)} + \\text{(other terms)}V(s)=s−(−α+jω)k​+s−(−α−jω)k∗​+(other terms)The inverse transform yields:\nv(t)=2∣k∣e−αtcos⁡(ωt+∠k)+(other terms)v(t) = 2|k|e^{-\\alpha t}\\cos(\\omega t + \\angle k) + \\text{(other terms)}v(t)=2∣k∣e−αtcos(ωt+∠k)+(other terms) 6. Worked Example: Series RC Circuit Consider a series RC circuit with:\nResistor: R=2 ΩR = 2\\,\\OmegaR=2Ω Capacitor: C=0.5 FC = 0.5\\,\\text{F}C=0.5F Input: Step voltage vs(t)=10u(t) Vv_s(t) = 10u(t)\\,\\text{V}vs​(t)=10u(t)V Initial condition: vC(0)=5 Vv_C(0) = 5\\,\\text{V}vC​(0)=5V Find: The capacitor voltage vC(t)v_C(t)vC​(t) for t≥0t \\ge 0t≥0, separating into ZIR and ZSR.\nStep 1: sss-Domain Circuit Transform to sss-domain:\nInput: Vs(s)=10sV_s(s) = \\frac{10}{s}Vs​(s)=s10​ Resistor: R=2 ΩR = 2\\,\\OmegaR=2Ω Capacitor: ZC=1sC=10.5s=2sZ_C = \\frac{1}{sC} = \\frac{1}{0.5s} = \\frac{2}{s}ZC​=sC1​=0.5s1​=s2​ with initial voltage source vC(0)s=5s\\frac{v_C(0)}{s} = \\frac{5}{s}svC​(0)​=s5​","step-2-total-response-without-separation#Step 2: Total Response (Without Separation)":"Using KVL around the loop:\nVs(s)=RIC(s)+1sCIC(s)+vC(0)sV_s(s) = RI_C(s) + \\frac{1}{sC}I_C(s) + \\frac{v_C(0)}{s}Vs​(s)=RIC​(s)+sC1​IC​(s)+svC​(0)​10s=2IC(s)+2sIC(s)+5s\\frac{10}{s} = 2I_C(s) + \\frac{2}{s}I_C(s) + \\frac{5}{s}s10​=2IC​(s)+s2​IC​(s)+s5​10s−5s=IC(s)(2+2s)\\frac{10}{s} - \\frac{5}{s} = I_C(s)\\left(2 + \\frac{2}{s}\\right)s10​−s5​=IC​(s)(2+s2​)5s=IC(s)2s+2s\\frac{5}{s} = I_C(s)\\frac{2s + 2}{s}s5​=IC​(s)s2s+2​IC(s)=52s+2=52(s+1)=2.5s+1I_C(s) = \\frac{5}{2s + 2} = \\frac{5}{2(s + 1)} = \\frac{2.5}{s + 1}IC​(s)=2s+25​=2(s+1)5​=s+12.5​The capacitor voltage:\nVC(s)=1sCIC(s)+vC(0)s=2s⋅2.5s+1+5sV_C(s) = \\frac{1}{sC}I_C(s) + \\frac{v_C(0)}{s} = \\frac{2}{s} \\cdot \\frac{2.5}{s+1} + \\frac{5}{s}VC​(s)=sC1​IC​(s)+svC​(0)​=s2​⋅s+12.5​+s5​VC(s)=5s(s+1)+5sV_C(s) = \\frac{5}{s(s+1)} + \\frac{5}{s}VC​(s)=s(s+1)5​+s5​Using PFE on the first term:\n5s(s+1)=As+Bs+1\\frac{5}{s(s+1)} = \\frac{A}{s} + \\frac{B}{s+1}s(s+1)5​=sA​+s+1B​A=[s⋅5s(s+1)]s=0=51=5A = \\left[s \\cdot \\frac{5}{s(s+1)}\\right]_{s=0} = \\frac{5}{1} = 5A=[s⋅s(s+1)5​]s=0​=15​=5B=[(s+1)⋅5s(s+1)]s=−1=5−1=−5B = \\left[(s+1) \\cdot \\frac{5}{s(s+1)}\\right]_{s=-1} = \\frac{5}{-1} = -5B=[(s+1)⋅s(s+1)5​]s=−1​=−15​=−5Therefore:\nVC(s)=5s−5s+1+5s=10s−5s+1V_C(s) = \\frac{5}{s} - \\frac{5}{s+1} + \\frac{5}{s} = \\frac{10}{s} - \\frac{5}{s+1}VC​(s)=s5​−s+15​+s5​=s10​−s+15​Inverse transform:\nvC(t)=10−5e−t=10−5e−t Vfor t≥0v_C(t) = 10 - 5e^{-t} = 10 - 5e^{-t}\\,\\text{V} \\quad \\text{for } t \\ge 0vC​(t)=10−5e−t=10−5e−tVfor t≥0","step-3-zero-state-response-zsr#Step 3: Zero-State Response (ZSR)":"Set initial condition to zero: vC(0)=0v_C(0) = 0vC​(0)=0\nVs(s)=RIC(s)+1sCIC(s)V_s(s) = RI_C(s) + \\frac{1}{sC}I_C(s)Vs​(s)=RIC​(s)+sC1​IC​(s)10s=IC(s)(2+2s)=IC(s)2s+2s\\frac{10}{s} = I_C(s)\\left(2 + \\frac{2}{s}\\right) = I_C(s)\\frac{2s + 2}{s}s10​=IC​(s)(2+s2​)=IC​(s)s2s+2​IC(s)=102s+2=5s+1I_C(s) = \\frac{10}{2s + 2} = \\frac{5}{s + 1}IC​(s)=2s+210​=s+15​VC,ZSR(s)=2s⋅5s+1=10s(s+1)V_{C,\\text{ZSR}}(s) = \\frac{2}{s} \\cdot \\frac{5}{s+1} = \\frac{10}{s(s+1)}VC,ZSR​(s)=s2​⋅s+15​=s(s+1)10​Using PFE:\n10s(s+1)=10s−10s+1\\frac{10}{s(s+1)} = \\frac{10}{s} - \\frac{10}{s+1}s(s+1)10​=s10​−s+110​Inverse transform:\nvC,ZSR(t)=10−10e−t Vfor t≥0v_{C,\\text{ZSR}}(t) = 10 - 10e^{-t}\\,\\text{V} \\quad \\text{for } t \\ge 0vC,ZSR​(t)=10−10e−tVfor t≥0","step-4-zero-input-response-zir#Step 4: Zero-Input Response (ZIR)":"Set input to zero: Vs(s)=0V_s(s) = 0Vs​(s)=0 (short circuit), keep initial condition vC(0)=5 Vv_C(0) = 5\\,\\text{V}vC​(0)=5V\n0=RIC(s)+1sCIC(s)+vC(0)s0 = RI_C(s) + \\frac{1}{sC}I_C(s) + \\frac{v_C(0)}{s}0=RIC​(s)+sC1​IC​(s)+svC​(0)​−5s=IC(s)2s+2s-\\frac{5}{s} = I_C(s)\\frac{2s + 2}{s}−s5​=IC​(s)s2s+2​IC(s)=−52(s+1)I_C(s) = -\\frac{5}{2(s+1)}IC​(s)=−2(s+1)5​VC,ZIR(s)=2s⋅(−52(s+1))+5s=−5s(s+1)+5sV_{C,\\text{ZIR}}(s) = \\frac{2}{s} \\cdot \\left(-\\frac{5}{2(s+1)}\\right) + \\frac{5}{s} = -\\frac{5}{s(s+1)} + \\frac{5}{s}VC,ZIR​(s)=s2​⋅(−2(s+1)5​)+s5​=−s(s+1)5​+s5​VC,ZIR(s)=−5s+5s+1+5s=5s+1V_{C,\\text{ZIR}}(s) = -\\frac{5}{s} + \\frac{5}{s+1} + \\frac{5}{s} = \\frac{5}{s+1}VC,ZIR​(s)=−s5​+s+15​+s5​=s+15​Inverse transform:\nvC,ZIR(t)=5e−t Vfor t≥0v_{C,\\text{ZIR}}(t) = 5e^{-t}\\,\\text{V} \\quad \\text{for } t \\ge 0vC,ZIR​(t)=5e−tVfor t≥0","step-5-verify-total-response#Step 5: Verify Total Response":"vC(t)=vC,ZSR(t)+vC,ZIR(t)=(10−10e−t)+5e−t=10−5e−t Vv_C(t) = v_{C,\\text{ZSR}}(t) + v_{C,\\text{ZIR}}(t) = (10 - 10e^{-t}) + 5e^{-t} = 10 - 5e^{-t}\\,\\text{V}vC​(t)=vC,ZSR​(t)+vC,ZIR​(t)=(10−10e−t)+5e−t=10−5e−tV✓ Matches the total response calculated earlier!","step-by-step-method-general-circuit-analysis-using-lt#Step-by-Step Method (General Circuit Analysis using LT)":"","superposition-principle-total-response#Superposition Principle (Total Response)":"","zero-input-response-zir#Zero-Input Response (ZIR)":"","zero-state-response-zsr#Zero-State Response (ZSR)":""},"title":"Zero-Input Response (ZIR) and Zero-State Response (ZSR)"},"/electrical_notes/ee_300/zir_zsr_complete/":{"data":{"1-conceptual-understanding#1. Conceptual Understanding":"","10-practice-problems#10. Practice Problems":"","2-s-domain-component-models#2. S-Domain Component Models":"","3-step-by-step-solution-process#3. Step-by-Step Solution Process":"","4-essential-laplace-transform-tools#4. Essential Laplace Transform Tools":"","5-partial-fraction-expansion-pfe#5. Partial Fraction Expansion (PFE)":"","6-worked-example-series-rc-circuit#6. Worked Example: Series RC Circuit":"Given:\nR=2 ΩR = 2\\,\\OmegaR=2Ω C=0.5 FC = 0.5\\,\\text{F}C=0.5F Input: vs(t)=10u(t) Vv_s(t) = 10u(t)\\,\\text{V}vs​(t)=10u(t)V Initial condition: vC(0)=5 Vv_C(0) = 5\\,\\text{V}vC​(0)=5V Find: Capacitor voltage vC(t)v_C(t)vC​(t) for t≥0t \\geq 0t≥0, separated into ZIR and ZSR.","7-quick-reference-summary#7. Quick Reference Summary":"Aspect ZIR ZSR Cause Initial conditions only Input sources only Initial Conditions Active: vC(0)≠0v_C(0) \\neq 0vC​(0)=0, iL(0)≠0i_L(0) \\neq 0iL​(0)=0 Zeroed: vC(0)=0v_C(0) = 0vC​(0)=0, iL(0)=0i_L(0) = 0iL​(0)=0 Input Sources Zeroed (short/open) Active Response Type Pure natural response Natural + forced response Physical Meaning Stored energy dissipation System driven by excitation Poles Circuit natural frequencies Same natural frequencies Time Constants Determined by R, L, C Same as ZIR","8-common-mistakes-to-avoid#8. Common Mistakes to Avoid":"❌ Forgetting initial condition sources when calculating ZIR ❌ Not zeroing initial conditions when calculating ZSR ❌ Incorrect polarity of initial condition sources ❌ Sign errors in series-connected sources ❌ Confusing natural response with ZIR (ZSR also has natural components!) ❌ Not verifying that ZIR + ZSR = Total Response ❌ Wrong impedance forms (forgetting the sss in sLsLsL or 1sC\\frac{1}{sC}sC1​)","9-time-constants-reference#9. Time Constants Reference":"Series RC: τ=RC\\tau = RCτ=RC\nSeries RL: τ=LR\\tau = \\frac{L}{R}τ=RL​\nParallel RC: τ=RC\\tau = RCτ=RC\nParallel RL: τ=LR\\tau = \\frac{L}{R}τ=RL​\nResponse form: v(t)=Vf+(Vi−Vf)e−t/τv(t) = V_f + (V_i - V_f)e^{-t/\\tau}v(t)=Vf​+(Vi​−Vf​)e−t/τ\nWhere:\nViV_iVi​ = initial value VfV_fVf​ = final (steady-state) value After 5τ5\\tau5τ, response reaches ~99.3% of final value","capacitor#Capacitor":"Impedance: ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​Complete S-domain model: VC(s)=1sCIC(s)+vC(0)sV_C(s) = \\frac{1}{sC} I_C(s) + \\frac{v_C(0)}{s}VC​(s)=sC1​IC​(s)+svC​(0)​Equivalent circuit: Impedance 1sC\\frac{1}{sC}sC1​ in series with voltage source vC(0)s\\frac{v_C(0)}{s}svC​(0)​","common-transform-pairs#Common Transform Pairs":"Time Domain f(t)f(t)f(t) S-Domain F(s)F(s)F(s) δ(t)\\delta(t)δ(t) 111 u(t)u(t)u(t) 1s\\frac{1}{s}s1​ e−atu(t)e^{-at}u(t)e−atu(t) 1s+a\\frac{1}{s+a}s+a1​ te−atu(t)te^{-at}u(t)te−atu(t) 1(s+a)2\\frac{1}{(s+a)^2}(s+a)21​ sin⁡(ωt)u(t)\\sin(\\omega t)u(t)sin(ωt)u(t) ωs2+ω2\\frac{\\omega}{s^2 + \\omega^2}s2+ω2ω​ cos⁡(ωt)u(t)\\cos(\\omega t)u(t)cos(ωt)u(t) ss2+ω2\\frac{s}{s^2 + \\omega^2}s2+ω2s​","complete-guide-zero-input-response-zir-and-zero-state-response-zsr#Complete Guide: Zero-Input Response (ZIR) and Zero-State Response (ZSR)":"Complete Guide: Zero-Input Response (ZIR) and Zero-State Response (ZSR)","differentiation-property-key-for-initial-conditions#Differentiation Property (Key for Initial Conditions)":"L{df(t)dt}=sF(s)−f(0)\\mathcal{L}\\left\\{\\frac{df(t)}{dt}\\right\\} = sF(s) - f(0)L{dtdf(t)​}=sF(s)−f(0)This property naturally separates the initial condition term f(0)f(0)f(0) from the transformed derivative.","for-complex-conjugate-poles#For Complex Conjugate Poles":"If poles are p=−α±jωp = -\\alpha \\pm j\\omegap=−α±jω, the inverse transform yields:\nv(t)=2∣k∣e−αtcos⁡(ωt+∠k)v(t) = 2|k|e^{-\\alpha t}\\cos(\\omega t + \\angle k)v(t)=2∣k∣e−αtcos(ωt+∠k)where kkk is the residue at one of the complex poles.","for-distinct-real-poles#For Distinct Real Poles":"If V(s)=N(s)(s−p1)(s−p2)⋯(s−pn)V(s) = \\frac{N(s)}{(s-p_1)(s-p_2)\\cdots(s-p_n)}V(s)=(s−p1​)(s−p2​)⋯(s−pn​)N(s)​ where all poles are distinct:\nV(s)=k1s−p1+k2s−p2+⋯+kns−pnV(s) = \\frac{k_1}{s-p_1} + \\frac{k_2}{s-p_2} + \\cdots + \\frac{k_n}{s-p_n}V(s)=s−p1​k1​​+s−p2​k2​​+⋯+s−pn​kn​​Cover-up method for residue kik_iki​: ki=[(s−pi)V(s)]s=pik_i = \\left[(s-p_i)V(s)\\right]_{s=p_i}ki​=[(s−pi​)V(s)]s=pi​​","for-repeated-poles#For Repeated Poles":"If pole p1p_1p1​ has multiplicity rrr:\nV(s)=k1,r(s−p1)r+k1,r−1(s−p1)r−1+⋯+k1,1s−p1+(other terms)V(s) = \\frac{k_{1,r}}{(s-p_1)^r} + \\frac{k_{1,r-1}}{(s-p_1)^{r-1}} + \\cdots + \\frac{k_{1,1}}{s-p_1} + \\text{(other terms)}V(s)=(s−p1​)rk1,r​​+(s−p1​)r−1k1,r−1​​+⋯+s−p1​k1,1​​+(other terms)Highest order residue: k1,r=[(s−p1)rV(s)]s=p1k_{1,r} = \\left[(s-p_1)^r V(s)\\right]_{s=p_1}k1,r​=[(s−p1​)rV(s)]s=p1​​Lower order residues: k1,j=1(r−j)!dr−jdsr−j[(s−p1)rV(s)]s=p1k_{1,j} = \\frac{1}{(r-j)!} \\frac{d^{r-j}}{ds^{r-j}}\\left[(s-p_1)^r V(s)\\right]_{s=p_1}k1,j​=(r−j)!1​dsr−jdr−j​[(s−p1​)rV(s)]s=p1​​","inductor#Inductor":"Impedance: ZL=sLZ_L = sLZL​=sLComplete S-domain model (voltage form): VL(s)=sL⋅IL(s)−LiL(0)V_L(s) = sL \\cdot I_L(s) - Li_L(0)VL​(s)=sL⋅IL​(s)−LiL​(0)Complete S-domain model (current form): IL(s)=VL(s)sL+iL(0)sI_L(s) = \\frac{V_L(s)}{sL} + \\frac{i_L(0)}{s}IL​(s)=sLVL​(s)​+siL​(0)​Equivalent circuits:\nImpedance sLsLsL in series with voltage source LiL(0)Li_L(0)LiL​(0) (opposite polarity), OR Impedance sLsLsL in parallel with current source iL(0)s\\frac{i_L(0)}{s}siL​(0)​","overview#Overview":"The total response of a linear circuit can be decomposed into two fundamental components using the principle of superposition:\nvtotal(t)=vZSR(t)+vZIR(t)\\boxed{v_{\\text{total}}(t) = v_{\\text{ZSR}}(t) + v_{\\text{ZIR}}(t)}vtotal​(t)=vZSR​(t)+vZIR​(t)​This separation is powerful because it allows us to analyze:\nInitial condition effects (ZIR) separately from Input source effects (ZSR)","phase-0-initial-setup#Phase 0: Initial Setup":"Step 1: Draw the time-domain circuit and identify all components\nStep 2: Find initial conditions for t\u003c0t \u003c 0t\u003c0 (steady-state DC analysis)\nCapacitors: Open circuits (no current flows) Inductors: Short circuits (no voltage drop) Calculate vC(0−)v_C(0^-)vC​(0−) and iL(0−)i_L(0^-)iL​(0−) Step 3: Apply continuity conditions\nCapacitor voltage cannot change instantly: vC(0+)=vC(0−)v_C(0^+) = v_C(0^-)vC​(0+)=vC​(0−) Inductor current cannot change instantly: iL(0+)=iL(0−)i_L(0^+) = i_L(0^-)iL​(0+)=iL​(0−) Step 4: Transform circuit to S-domain for t≥0t \\geq 0t≥0\nReplace each component with its S-domain equivalent Include initial condition sources Transform input sources using Laplace tables","phase-1-calculate-zero-state-response-zsr#Phase 1: Calculate Zero-State Response (ZSR)":"Step 1: Modify the S-domain circuit:\nZero all initial condition sources Remove (short circuit) capacitor voltage sources vC(0)s\\frac{v_C(0)}{s}svC​(0)​ Remove (open circuit) inductor current sources iL(0)s\\frac{i_L(0)}{s}siL​(0)​ Keep external input sources active Step 2: Analyze the circuit to find VZSR(s)V_{\\text{ZSR}}(s)VZSR​(s) or IZSR(s)I_{\\text{ZSR}}(s)IZSR​(s)\nUse KVL, KCL, nodal analysis, or mesh analysis Apply voltage/current dividers where applicable Step 3: Perform Partial Fraction Expansion (PFE) on VZSR(s)V_{\\text{ZSR}}(s)VZSR​(s)\nStep 4: Apply Inverse Laplace Transform to get vZSR(t)v_{\\text{ZSR}}(t)vZSR​(t)","phase-2-calculate-zero-input-response-zir#Phase 2: Calculate Zero-Input Response (ZIR)":"Step 1: Modify the S-domain circuit:\nZero all external input sources Short circuit voltage sources Open circuit current sources Keep initial condition sources active Step 2: Analyze the circuit to find VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s) or IZIR(s)I_{\\text{ZIR}}(s)IZIR​(s)\nStep 3: Perform Partial Fraction Expansion (PFE) on VZIR(s)V_{\\text{ZIR}}(s)VZIR​(s)\nStep 4: Apply Inverse Laplace Transform to get vZIR(t)v_{\\text{ZIR}}(t)vZIR​(t)","phase-3-combine-responses#Phase 3: Combine Responses":"Step 1: Add responses in time domain: vtotal(t)=vZSR(t)+vZIR(t)for t≥0v_{\\text{total}}(t) = v_{\\text{ZSR}}(t) + v_{\\text{ZIR}}(t) \\quad \\text{for } t \\geq 0vtotal​(t)=vZSR​(t)+vZIR​(t)for t≥0Step 2: Verify (optional but recommended):\nCalculate total response directly without separation Check that it equals ZSR + ZIR","problem-1-series-rl-circuit#Problem 1: Series RL Circuit":"R=4 ΩR = 4\\,\\OmegaR=4Ω, L=2 HL = 2\\,\\text{H}L=2H Input: vs(t)=12u(t) Vv_s(t) = 12u(t)\\,\\text{V}vs​(t)=12u(t)V Initial condition: iL(0)=1 Ai_L(0) = 1\\,\\text{A}iL​(0)=1A Find iL(t)i_L(t)iL​(t) for t≥0t \\geq 0t≥0, separating into ZIR and ZSR.","problem-2-parallel-rc-circuit#Problem 2: Parallel RC Circuit":"R=5 ΩR = 5\\,\\OmegaR=5Ω, C=0.2 FC = 0.2\\,\\text{F}C=0.2F Input: is(t)=2u(t) Ai_s(t) = 2u(t)\\,\\text{A}is​(t)=2u(t)A Initial condition: vC(0)=3 Vv_C(0) = 3\\,\\text{V}vC​(0)=3V Find vC(t)v_C(t)vC​(t) for t≥0t \\geq 0t≥0, separating into ZIR and ZSR.","resistor#Resistor":"ZR=RZ_R = RZR​=R No initial condition source (no energy storage)","solution-zero-input-response-zir#Solution: Zero-Input Response (ZIR)":"Step 1: Set input to zero (short circuit), keep vC(0)=5 Vv_C(0) = 5\\,\\text{V}vC​(0)=5V\nStep 2: S-domain circuit equation (KVL): 0=RIC(s)+1sCIC(s)+vC(0)s0 = RI_C(s) + \\frac{1}{sC}I_C(s) + \\frac{v_C(0)}{s}0=RIC​(s)+sC1​IC​(s)+svC​(0)​−5s=IC(s)2(s+1)s-\\frac{5}{s} = I_C(s)\\frac{2(s+1)}{s}−s5​=IC​(s)s2(s+1)​IC(s)=−52(s+1)I_C(s) = -\\frac{5}{2(s+1)}IC​(s)=−2(s+1)5​Step 3: Calculate capacitor voltage: VC,ZIR(s)=1sCIC(s)+vC(0)sV_{C,\\text{ZIR}}(s) = \\frac{1}{sC}I_C(s) + \\frac{v_C(0)}{s}VC,ZIR​(s)=sC1​IC​(s)+svC​(0)​VC,ZIR(s)=2s⋅(−52(s+1))+5sV_{C,\\text{ZIR}}(s) = \\frac{2}{s} \\cdot \\left(-\\frac{5}{2(s+1)}\\right) + \\frac{5}{s}VC,ZIR​(s)=s2​⋅(−2(s+1)5​)+s5​VC,ZIR(s)=−5s(s+1)+5sV_{C,\\text{ZIR}}(s) = -\\frac{5}{s(s+1)} + \\frac{5}{s}VC,ZIR​(s)=−s(s+1)5​+s5​Step 4: Simplify using PFE on first term: −5s(s+1)=−5s+5s+1-\\frac{5}{s(s+1)} = -\\frac{5}{s} + \\frac{5}{s+1}−s(s+1)5​=−s5​+s+15​VC,ZIR(s)=−5s+5s+1+5s=5s+1V_{C,\\text{ZIR}}(s) = -\\frac{5}{s} + \\frac{5}{s+1} + \\frac{5}{s} = \\frac{5}{s+1}VC,ZIR​(s)=−s5​+s+15​+s5​=s+15​Step 5: Inverse transform: vC,ZIR(t)=5e−t V\\boxed{v_{C,\\text{ZIR}}(t) = 5e^{-t}\\,\\text{V}}vC,ZIR​(t)=5e−tV​","solution-zero-state-response-zsr#Solution: Zero-State Response (ZSR)":"Step 1: Set vC(0)=0v_C(0) = 0vC​(0)=0, keep input active\nStep 2: S-domain circuit equation (KVL): Vs(s)=RIC(s)+1sCIC(s)V_s(s) = RI_C(s) + \\frac{1}{sC}I_C(s)Vs​(s)=RIC​(s)+sC1​IC​(s)10s=IC(s)(2+2s)=IC(s)2(s+1)s\\frac{10}{s} = I_C(s)\\left(2 + \\frac{2}{s}\\right) = I_C(s)\\frac{2(s+1)}{s}s10​=IC​(s)(2+s2​)=IC​(s)s2(s+1)​IC(s)=5s+1I_C(s) = \\frac{5}{s+1}IC​(s)=s+15​Step 3: Calculate capacitor voltage: VC,ZSR(s)=1sCIC(s)=2s⋅5s+1=10s(s+1)V_{C,\\text{ZSR}}(s) = \\frac{1}{sC} I_C(s) = \\frac{2}{s} \\cdot \\frac{5}{s+1} = \\frac{10}{s(s+1)}VC,ZSR​(s)=sC1​IC​(s)=s2​⋅s+15​=s(s+1)10​Step 4: Partial Fraction Expansion: 10s(s+1)=As+Bs+1\\frac{10}{s(s+1)} = \\frac{A}{s} + \\frac{B}{s+1}s(s+1)10​=sA​+s+1B​Using cover-up method:\nA=[s⋅10s(s+1)]s=0=10A = \\left[s \\cdot \\frac{10}{s(s+1)}\\right]_{s=0} = 10A=[s⋅s(s+1)10​]s=0​=10 B=[(s+1)⋅10s(s+1)]s=−1=−10B = \\left[(s+1) \\cdot \\frac{10}{s(s+1)}\\right]_{s=-1} = -10B=[(s+1)⋅s(s+1)10​]s=−1​=−10 VC,ZSR(s)=10s−10s+1V_{C,\\text{ZSR}}(s) = \\frac{10}{s} - \\frac{10}{s+1}VC,ZSR​(s)=s10​−s+110​Step 5: Inverse transform: vC,ZSR(t)=10(1−e−t) V\\boxed{v_{C,\\text{ZSR}}(t) = 10(1 - e^{-t})\\,\\text{V}}vC,ZSR​(t)=10(1−e−t)V​","total-response#Total Response":"vC(t)=vC,ZSR(t)+vC,ZIR(t)v_C(t) = v_{C,\\text{ZSR}}(t) + v_{C,\\text{ZIR}}(t)vC​(t)=vC,ZSR​(t)+vC,ZIR​(t)vC(t)=10(1−e−t)+5e−t=10−5e−t V\\boxed{v_C(t) = 10(1-e^{-t}) + 5e^{-t} = 10 - 5e^{-t}\\,\\text{V}}vC​(t)=10(1−e−t)+5e−t=10−5e−tV​Physical interpretation:\nZIR: Initial 5V decays exponentially to 0V (τ = RC = 1s) ZSR: Charges from 0V to 10V exponentially (same τ) Total: Transitions from 5V to 10V exponentially","zero-input-response-zir#Zero-Input Response (ZIR)":"Definition: The circuit response due only to initial conditions (stored energy), with all external inputs set to zero.\nKey Characteristics:\nCaused by: Initial capacitor voltage vC(0)v_C(0)vC​(0) or inductor current iL(0)i_L(0)iL​(0) Input sources: Set to zero (voltage sources → short circuit, current sources → open circuit) Nature: Pure natural response - determined entirely by circuit components (R, L, C) Physical meaning: Energy stored in the circuit “relaxing” or dissipating Response form: Exponential decay based on circuit time constants In S-domain: Generated by initial condition sources vC(0)s\\frac{v_C(0)}{s}svC​(0)​ or iL(0)s\\frac{i_L(0)}{s}siL​(0)​","zero-state-response-zsr#Zero-State Response (ZSR)":"Definition: The circuit response due only to external input sources, assuming zero initial energy storage.\nKey Characteristics:\nCaused by: External input vs(t)v_s(t)vs​(t) or is(t)i_s(t)is​(t) Initial conditions: Set to zero (vC(0)=0v_C(0) = 0vC​(0)=0, iL(0)=0i_L(0) = 0iL​(0)=0) Nature: Contains both natural and forced responses Physical meaning: System response to external excitation Response form: Natural component (exponentials) + forced component (matching input form) In S-domain: Generated by transformed input sources Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s)"},"title":"zir_zsr_complete"},"/electrical_notes/ee_300/zir_zsr_nblm/":{"data":{"":"","-domain-device-characteristics-and-initial-conditions#-Domain Device Characteristics and Initial Conditions":"This documentation provides a comprehensive explanation of the Zero-Input Response (ZIR) and Zero-State Response (ZSR), drawing upon circuit theory concepts solved using the Laplace Transform (LT) methodology.\nComprehensive Documentation: Zero-Input Response (ZIR) and Zero-State Response (ZSR) The total response of a linear circuit can be separated into two fundamental components: the zero-state response (ZSR) and the zero-input response (ZIR). This separation is possible because the effect of the initial state can be isolated.\nTotal Response=Zero-State Response (ZSR)+Zero-Input Response (ZIR)\\text{Total Response} = \\text{Zero-State Response (ZSR)} + \\text{Zero-Input Response (ZIR)} \\quad \\text{}Total Response=Zero-State Response (ZSR)+Zero-Input Response (ZIR)1. Theory Background: ZIR and ZSR Zero-Input Response (ZIR) The Zero-Input Response (ZIR) is the behavior of the circuit due solely to the initial conditions of energy storage elements (like capacitors or inductors), assuming no external input sources are active.\nDefinition: ZIR is the response due to the initial voltage (or current). It is calculated as if there were zero input. Circuit State: To calculate ZIR, the input source (VsV_sVs​ or IsI_sIs​) of the circuit is set to zero. For a specific example, if the voltage source V=0V=0V=0 (shut circuit) for t\u003e0t \u003e 0t\u003e0, the final response is the zero-input response (ZIR). Nature: ZIR is the behavior due to device characteristics (R, C, L values) and is not related to any external sources. Consequently, all ZIRs are natural responses. The poles determining the natural characteristics are due to the values of R, C, and L. Zero-State Response (ZSR) The Zero-State Response (ZSR) is the behavior of the circuit due solely to the external input sources, assuming all initial energy storage in the circuit is zero.\nDefinition: ZSR is the response due to the input, or charging/discharging of a capacitor, assuming a zero initial state voltage. ZSR is the response due to the integral term. Circuit State: To calculate ZSR, the initial state of the capacitor (or inductor) is set to zero. Response Origin: ZSR is the voltage on a capacitor if Vc=0V_c = 0Vc​=0 at t=0t = 0t=0, meaning the response is entirely derived from the input or charging/discharging. 2. Relevant Topics to Understand Understanding ZIR and ZSR primarily requires the application of the Laplace Transform (LT) to circuit analysis, specifically in the sss-domain.\nRelevant Topic Subtopics and Importance Source(s) Laplace Transform (LT) and sss-Domain LT converts circuits from the time domain to the phase (sss) domain, transforming differential equations into linear equations that are easier to solve. The Inverse LT converts the expression back to the time domain. LT Properties Properties like differentiation (Property 4) and integration (Property 5) are crucial for transforming differential equations involving inductors and capacitors, respectively. sss-Domain Device Characteristics Resistors become impedance RRR. Capacitors (C) and Inductors (L) are modeled in the sss-domain as an impedance plus an initial condition term. Modeling Initial Conditions Initial conditions (energy stored at t=0t=0t=0) are converted into equivalent sources in the sss-domain. For a capacitor, the initial voltage v(0)v(0)v(0) is modeled by an sss-domain voltage source Vc(0)/sV_c(0)/sVc​(0)/s. For an inductor, current response is typically used. Inverse LT Techniques Once the response in the sss-domain (V(s)V(s)V(s) or I(s)I(s)I(s)) is found, the Inverse LT is performed, often requiring Partial Fraction Expansion (PFE) and the cover-up method to find residues (kik_iki​). Network Function The partial fraction derived from the circuit is known as the network function H(s)H(s)H(s). The roots of the denominator of H(s)H(s)H(s) define the system poles. 3. Step-by-Step Methods and Processes Solving problems involving ZIR and ZSR typically involves applying the principle of superposition within the sss-domain.\nStep-by-Step Method (General Circuit Analysis using LT) The process of solving circuits using LT, including finding the total response, generally follows these steps:\nDerive the Differential Equation: Develop the differential equation(s) that describe the circuit in the time domain, usually by applying KVL or KCL. Analyze for t\u003c0t\u003c0t\u003c0 (Initial Conditions): Use circuit knowledge, physical insight, or classical techniques to find the required output variables (voltages, currents) for t\u003c0t \u003c 0t\u003c0, particularly vc(0)v_c(0)vc​(0) or iL(0)i_L(0)iL​(0). Transform to sss-Domain: For t≥0t \\ge 0t≥0, transform the differential equation into the sss-domain using the Laplace Transform, utilizing the differentiation property to incorporate initial conditions. Solve for the sss-Domain Variable: Solve the resulting linear algebraic equation for the variable of interest, V(s)V(s)V(s) or I(s)I(s)I(s). Separate into ZSR and ZIR (Superposition): Use superposition to explicitly separate the total response V(s)V(s)V(s) into VZSR(s)V_{ZSR}(s)VZSR​(s) and VZIR(s)V_{ZIR}(s)VZIR​(s). Inverse Transform: Perform the Inverse LT on VZSR(s)V_{ZSR}(s)VZSR​(s) and VZIR(s)V_{ZIR}(s)VZIR​(s) separately to get vZSR(t)v_{ZSR}(t)vZSR​(t) and vZIR(t)v_{ZIR}(t)vZIR​(t). The PFE/cover-up method is typically used here. Calculate Total Response: Combine vZSR(t)v_{ZSR}(t)vZSR​(t) and vZIR(t)v_{ZIR}(t)vZIR​(t) for the complete solution for t≥0t \\ge 0t≥0. Detailed Process for ZIR/ZSR Separation (Superposition Method) The separation of ZIR and ZSR is achieved by modeling the circuit elements in the sss-domain and applying the superposition principle:\nPhase 1: Zero-State Response (ZSR) Calculation\nZero Initial Conditions: In the sss-domain equivalent circuit, set all initial condition sources to zero. For a capacitor, zero the Vc(0)/sV_c(0)/sVc​(0)/s source. For an inductor, zero the IL(0)/sI_L(0)/sIL​(0)/s source (implied). Keep External Sources: Keep all external input sources (Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s)) active. Calculate sss-Domain ZSR: Analyze the circuit (e.g., using KCL/node method) to find the response VZSR(s)V_{ZSR}(s)VZSR​(s) (or IZSR(s)I_{ZSR}(s)IZSR​(s)) due to Vs(s)V_s(s)Vs​(s). Inverse LT: Find vZSR(t)v_{ZSR}(t)vZSR​(t) by applying the Inverse Laplace Transform to VZSR(s)V_{ZSR}(s)VZSR​(s). Phase 2: Zero-Input Response (ZIR) Calculation\nZero External Sources: Set all external input sources to zero (i.e., short-circuit voltage sources, open-circuit current sources). Keep Initial Conditions: Keep all initial condition sources (Vc(0)/sV_c(0)/sVc​(0)/s, IL(0)/sI_L(0)/sIL​(0)/s) active. Calculate sss-Domain ZIR: Analyze the resulting circuit to find the response VZIR(s)V_{ZIR}(s)VZIR​(s) (or IZIR(s)I_{ZIR}(s)IZIR​(s)) due only to the initial conditions. Note: The analysis may involve calculating the current from the initial inductor condition. Inverse LT: Find vZIR(t)v_{ZIR}(t)vZIR​(t) by applying the Inverse Laplace Transform to VZIR(s)V_{ZIR}(s)VZIR​(s). Phase 3: Total Response\nSum Responses: The total response in the sss-domain is Vtotal(s)=VZSR(s)+VZIR(s)V_{total}(s) = V_{ZSR}(s) + V_{ZIR}(s)Vtotal​(s)=VZSR​(s)+VZIR​(s). Total Time Domain Response: The total response in the time domain is vtotal(t)=vZSR(t)+vZIR(t)v_{total}(t) = v_{ZSR}(t) + v_{ZIR}(t)vtotal​(t)=vZSR​(t)+vZIR​(t). 4. Relevant Equations The analysis of ZIR and ZSR occurs entirely within the framework of linear circuit analysis using the Laplace Transform.\nSuperposition Principle (Total Response) Total Response=Response due to Input Sources+Response due to Initial Conditions\\text{Total Response} = \\text{Response due to Input Sources} + \\text{Response due to Initial Conditions} \\quad \\text{}Total Response=Response due to Input Sources+Response due to Initial ConditionsVtotal(s)=VZSR(s)+VZIR(s)V_{total}(s) = V_{ZSR}(s) + V_{ZIR}(s) \\quad \\text{}Vtotal​(s)=VZSR​(s)+VZIR​(s)vtotal(t)=vZSR(t)+vZIR(t)v_{total}(t) = v_{ZSR}(t) + v_{ZIR}(t) \\quad \\text{}vtotal​(t)=vZSR​(t)+vZIR​(t)sss-Domain Device Characteristics and Initial Conditions Device Time Domain (Example) sss-Domain Impedance (ZZZ) Initial Condition Model (Source) Source(s) Resistor (R) RRR RRR None Capacitor (C) vC(t)=1C∫iC(τ)dτv_C(t) = \\frac{1}{C} \\int i_C(\\tau) d\\tauvC​(t)=C1​∫iC​(τ)dτ ZC=1sCZ_C = \\frac{1}{sC}ZC​=sC1​ Voltage source: vC(0)s\\frac{v_C(0)}{s}svC​(0)​ Inductor (L) vL(t)=LdiLdtv_L(t) = L \\frac{di_L}{dt}vL​(t)=LdtdiL​​ ZLZ_LZL​ (implied sLsLsL) Current source (implied) or Voltage source In the sss-domain, the capacitor is equivalent to an impedance ZCZ_CZC​ plus its initial voltage effect.","1-theory-background-zir-and-zsr#1. Theory Background: ZIR and ZSR":"","2-relevant-topics-to-understand#2. Relevant Topics to Understand":"","3-step-by-step-methods-and-processes#3. Step-by-Step Methods and Processes":"","4-relevant-equations#4. Relevant Equations":"","comprehensive-documentation-zero-input-response-zir-and-zero-state-response-zsr#Comprehensive Documentation: Zero-Input Response (ZIR) and Zero-State Response (ZSR)":"","detailed-process-for-zirzsr-separation-superposition-method#Detailed Process for ZIR/ZSR Separation (Superposition Method)":"","laplace-transform-property-differentiation#Laplace Transform Property (Differentiation)":"This property is key for transforming the time-domain differential equation into the sss-domain, inherently separating the initial condition (f(0)f(0)f(0)) term:\nL{df(t)dt}=sF(s)−f(0)\\mathcal{L}\\left\\{\\frac{d f(t)}{d t}\\right\\}=s F(s)-f(0) \\quad \\text{}L{dtdf(t)​}=sF(s)−f(0)","step-by-step-method-general-circuit-analysis-using-lt#Step-by-Step Method (General Circuit Analysis using LT)":"","superposition-principle-total-response#Superposition Principle (Total Response)":"","zero-input-response-zir#Zero-Input Response (ZIR)":"","zero-state-response-zsr#Zero-State Response (ZSR)":""},"title":"zir_zsr_nbLM"},"/electrical_notes/ee_300/zir_zsr_nblm2/":{"data":{"":"please give me a detailed step by step guide on\nThis guide provides a synopsis of Zero-Input Response (ZIR) and Zero-State Response (ZSR) and outlines the steps for their calculation, primarily utilizing the Laplace Transform (LT) and S-domain circuit analysis.","i-circuit-preparation-s-domain-transformation#I. Circuit Preparation (S-Domain Transformation)":"Develop the Differential Equation: Derive the differential equation(s) that describe the circuit in the time domain. Determine Initial Conditions: Use circuit knowledge to find the output variable (voltage or current) for t\u003c0t \u003c 0t\u003c0. This establishes the initial conditions, such as vc(0)v_c(0)vc​(0) or iL(0)i_L(0)iL​(0). Transform to S-Domain: Convert the circuit components and equations for t≥0t \\geq 0t≥0 into the S-domain using the Laplace Transform. Model Components with Initial Conditions: In the S-domain, reactive devices (capacitors and inductors) are replaced by their impedance plus a source representing the initial condition: Capacitor: Equivalent to an impedance ZC=1/sCZ_C = 1/sCZC​=1/sC plus an initial voltage source Vc(0)/sV_c(0)/sVc​(0)/s. Inductor: Modeled similarly, including its impedance and initial current effect. (For inductors, current response is typically used; for capacitors, voltage response is typically used).","ii-calculation-of-zero-state-response-zsr#II. Calculation of Zero-State Response (ZSR)":"The ZSR is the response due to the external input source(s) only, assuming zero initial state.\nZero Initial Conditions: In the S-domain circuit, set all initial condition sources (e.g., Vc(0)/sV_c(0)/sVc​(0)/s) to zero. Note: If the initial condition is modeled as a voltage source, setting it to zero means replacing it with a short circuit. Analyze Circuit for Input Response: Using standard circuit analysis techniques (like KVL, KCL, Node method, or Current Divider), calculate the output variable of interest (e.g., Vc(s)V_c(s)Vc​(s) or IL(s)I_L(s)IL​(s)), considering only the transformed external input source Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s). Identify ZSR in S-Domain: The resulting expression, VZSR(s)V_{ZSR}(s)VZSR​(s) (or IZSR(s)I_{ZSR}(s)IZSR​(s)), is the Zero-State Response in the S-domain. Inverse Transform to Time Domain: Perform the Inverse Laplace Transform (Inverse LT) on VZSR(s)V_{ZSR}(s)VZSR​(s) to obtain the time-domain Zero-State Response, vZSR(t)v_{ZSR}(t)vZSR​(t). This often involves using Partial Fraction Expansion (PFE) and the cover-up method to find the residues.","iii-calculation-of-zero-input-response-zir#III. Calculation of Zero-Input Response (ZIR)":"The ZIR is the response due to the initial conditions only, assuming zero input.\nZero External Input: In the S-domain circuit, set all external input source(s) (e.g., Vs(s)V_s(s)Vs​(s) or Is(s)I_s(s)Is​(s)) to zero. Note: If the external source is a voltage source, setting it to zero means replacing it with a short circuit. Analyze Circuit for Initial Condition Response: Calculate the output variable of interest (e.g., Vc(s)V_c(s)Vc​(s) or IL(s)I_L(s)IL​(s)), considering only the initial condition sources (e.g., Vc(0)/sV_c(0)/sVc​(0)/s). Identify ZIR in S-Domain: The resulting expression, VZIR(s)V_{ZIR}(s)VZIR​(s) (or IZIR(s)I_{ZIR}(s)IZIR​(s)), is the Zero-Input Response in the S-domain. Inverse Transform to Time Domain: Perform the Inverse Laplace Transform on VZIR(s)V_{ZIR}(s)VZIR​(s) to obtain the time-domain Zero-Input Response, vZIR(t)v_{ZIR}(t)vZIR​(t). ZIR terms will typically show the natural characteristics of the devices, defined by the poles determined by R, C, and L values.","iv-total-response-calculation#IV. Total Response Calculation":"Sum Responses: The total response in the S-domain is the sum of the ZSR and ZIR responses: Vtotal(s)=VZSR(s)+VZIR(s)V_{total}(s) = V_{ZSR}(s) + V_{ZIR}(s)Vtotal​(s)=VZSR​(s)+VZIR​(s) Time Domain Result: The total output in the time domain, vtotal(t)v_{total}(t)vtotal​(t), is the sum of the inverse transformed components: vtotal(t)=vZSR(t)+vZIR(t)v_{total}(t) = v_{ZSR}(t) + v_{ZIR}(t)vtotal​(t)=vZSR​(t)+vZIR​(t) Complete Solution: Combine the waveform derived for t≥0t \\geq 0t≥0 with the behavior determined for t\u003c0t \u003c 0t\u003c0 for the complete solution.","step-by-step-guide-for-calculating-zsr-and-zir#Step-by-Step Guide for Calculating ZSR and ZIR":"To calculate ZSR and ZIR, circuit analysis is typically performed using the Laplace Transform (LT) to convert the time-domain circuit into the S-domain. This approach allows for the use of the superposition method to separate the responses caused by the input source and the initial condition sources.","synopsis-of-zero-input-response-zir-and-zero-state-response-zsr#Synopsis of Zero-Input Response (ZIR) and Zero-State Response (ZSR)":"The total response of an electric circuit can be separated into two components: the Zero-State Response (ZSR) and the Zero-Input Response (ZIR).","zero-input-response-zir#Zero-Input Response (ZIR)":"The Zero-Input Response (ZIR) is the behavior of the circuit due to its initial conditions (like initial capacitor voltage or inductor current).\nZIR is calculated as if there were zero input (meaning the external input source is set to zero). It is the response derived solely from the voltage on the capacitor (or current in the inductor) at the beginning (t=0t=0t=0). ZIR is due to device characteristics and is therefore equivalent to the natural response of the circuit. In the S-domain analysis of a capacitor, the ZIR component is generated by the initial condition source Vc(0)/sV_c(0)/sVc​(0)/s.","zero-state-response-zsr#Zero-State Response (ZSR)":"The Zero-State Response (ZSR) is the response due to the external input or charging/discharging of the capacitor, assuming the initial state (condition) is zero.\nZSR is the response due to the input source Vs(s)V_s(s)Vs​(s) when the initial state of the capacitor is zeroed. It is the response due to the integral term in the transformed differential equation."},"title":"zir_zsr_nblm2"},"/electrical_notes/ee_302/exam1_cheatsheet2/":{"data":{"":"","step-by-step-methodology-clipper-circuits#Step-by-Step Methodology: Clipper Circuits":"Clipper circuits are wave-shaping circuits that limit the output waveform by removing the portion of the input voltage that falls above or below a specified level.\nIdentify Clipping Levels (Breakpoints): Determine the critical input voltage levels (VinV_{in}Vin​) where the diodes change state (turn ON, OFF, or enter Zener breakdown). Account for the diode forward voltage drop (e.g., 0.60.60.6 V or 0.70.70.7 V) or the Zener breakdown voltage (VZV_ZVZ​). Define Operating Regions: Analyze the circuit across different ranges of VinV_{in}Vin​ corresponding to the possible combinations of diode states. Typically, analyze the negative cycle and positive cycle of VinV_{in}Vin​ separately. Analyze Linear Regions: For each defined operating region, treat the diodes as linear elements (short circuit, open circuit, or voltage source/resistor combination, depending on the diode model used). Calculate Output Voltage (VoutV_{out}Vout​): Use KVL, KCL, and Ohm’s law to determine the relationship between VoutV_{out}Vout​ and VinV_{in}Vin​ for each region. In regions where diodes are OFF, the slope of the transfer characteristic (VoutV_{out}Vout​ vs. VinV_{in}Vin​) is often 1, meaning Vout=VinV_{out} = V_{in}Vout​=Vin​ In regions where diodes are ON (clipping), VoutV_{out}Vout​ is generally limited to a constant voltage determined by the limiting elements (batteries, Zener diodes, and forward drops). Sketch Results: Sketch the transfer characteristics (VoutV_{out}Vout​ versus VinV_{in}Vin​) or the output waveform (vo(t)v_o(t)vo​(t)) for a given input waveform vin(t)v_{in}(t)vin​(t)","step-by-step-methodology-ideal-diode-analysis#Step-by-Step Methodology: Ideal Diode Analysis":"The ideal diode model treats the diode as a perfect conductor (short circuit) in the forward direction and an open circuit in the reverse direction, assuming the forward voltage drop and reverse current are negligible.\nAssume Diode States: Assume a state for each diode, either ON or OFF. For nnn diodes, consider 2n2^n2n possible combinations of diode states. Try to guess with your best judgment, considering the source direction. Replace Diodes: Redraw the circuit by replacing the assumed diode states with their linear equivalents: ON diodes →\\rightarrow→ Short circuit (VD=0V_D = 0VD​=0). OFF diodes →\\rightarrow→ Open circuit (ID=0I_D = 0ID​=0). Analyze Circuit: Analyze the resulting linear circuit using techniques like Kirchhoff’s laws and Ohm’s law to determine the following for each diode: Current (IDI_DID​) through the diodes assumed to be ON. Voltage (VDV_DVD​) across the diodes assumed to be OFF. Check Constraints: Check to see if the calculated results are consistent with the assumed state for each diode: For ON diodes: Current must flow in the forward direction (ID\u003e0I_D \u003e 0ID​\u003e0). For OFF diodes: The voltage must be reverse biased (VD\u003c0V_D \u003c 0VD​\u003c0), or positive at the cathode. Validate or Iterate: If the results are consistent with the assumed states, the analysis is finished. Otherwise, return to step 1 and choose a different combination of diode states. Note: In general, you cannot decide on the state of a particular diode until a combination works for all the diodes in the circuit.","step-by-step-methodology-load-line-method#Step-by-Step Methodology: Load-Line Method":"The load-line analysis technique is a graphical method used to analyze nonlinear circuits, such as those involving diodes or BJT amplifiers.\nSimplify the Circuit: If the circuit contains multiple linear elements connected to the nonlinear device (the load), replace the network external to the nonlinear device with its Thévenin equivalent circuit (VTHV_{TH}VTH​ and RTHR_{TH}RTH​). Apply KVL (Derive Load Line Equation): Apply Kirchhoff’s Voltage Law (KVL) to the simplified circuit loop containing the nonlinear device. This yields a linear equation (the load line equation) relating the device voltage (vDv_DvD​) and device current (iDi_DiD​). Notable Equation (Example Diode Circuit): VSS=RiD+vDV_{SS} = R i_D + v_DVSS​=RiD​+vD​ Plot the Load Line: Plot this linear KVL equation on the same set of axes used for the nonlinear device’s experimentally obtained volt–ampere characteristic. Determine two points to plot the straight line: The voltage axis intercept (where iD=0i_D = 0iD​=0): vD=VSSv_D = V_{SS}vD​=VSS​ The current axis intercept (where vD=0v_D = 0vD​=0): iD=VSSRi_D = \\frac{V_{SS}}{R}iD​=RVSS​​ Determine the Operating Point (Q-Point): The operating point is the intersection of the load line and the device characteristic curve. This point represents the simultaneous solution of the circuit. Read Results: Read the quiescent voltage (VDQV_{DQ}VDQ​) and current (IDQI_{DQ}IDQ​) at the operating point from the plot.","step-by-step-methodology-rectifier-circuits#Step-by-Step Methodology: Rectifier Circuits":"Rectifiers convert AC power into DC power, forming the basis for electronic power supplies.\nDetermine Diode Conduction Cycles: Based on the rectifier configuration (half-wave, full-wave bridge, or center-tapped), determine which diodes conduct current during the positive and negative half-cycles of the AC source voltage, vs(t)v_s(t)vs​(t) Analyze Forward Bias: When the source voltage causes a diode to be forward biased: For an Ideal Diode: The output voltage across the load (vo(t)v_o(t)vo​(t)) equals the source voltage. For an Actual Diode: The output voltage is typically reduced by the forward voltage drop, Vf≈0.7V_f \\approx 0.7Vf​≈0.7 V. Analyze Reverse Bias: When the source voltage causes the diodes to be reverse biased: For a resistive load, current flow stops, and vo(t)v_o(t)vo​(t) drops to zero (for half-wave). Calculate Peak Inverse Voltage (PIV): Determine the maximum reverse voltage that appears across the non-conducting diodes. For a half-wave rectifier with a resistive load, PIV =Vm= V_m=Vm​ (peak source voltage). For a full-wave center-tapped rectifier, PIV ≈2Vm\\approx 2 V_m≈2Vm​ Analyze Circuits with Smoothing Capacitors (If Applicable): If a capacitor (CCC) is placed in parallel with the load to smooth the voltage (reducing ripple VrV_rVr​), calculate the required capacitance or the average load voltage. Notable Equation (Average Load Voltage with Capacitor): VL≅Vm−Vr2V_L \\cong V_m - \\frac{V_r}{2}VL​≅Vm​−2Vr​​ Notable Equation (Capacitance for Half-Wave Rectifier): C≅ILTVrC \\cong \\frac{I_L T}{V_r}C≅Vr​IL​T​ Notable Equation (Capacitance for Full-Wave Rectifier): C=ILT2VrC = \\frac{I_L T}{2 V_r}C=2Vr​IL​T​ Where ILI_LIL​ is the average load current, TTT is the period, and VrV_rVr​ is the peak-to-peak ripple voltage."},"title":"Exam 1 Cheat Sheet"},"/electrical_notes/ee_302/exam_1_cheatsheet_comprehensive/":{"data":{"":"","additional-key-formulas-and-concepts#Additional Key Formulas and Concepts":"Peak Inverse Voltage (PIV):\nHalf-wave rectifier with resistive load: PIV = VmV_mVm​ Half-wave rectifier with smoothing capacitor: PIV \\approx 2Vm2V_m2Vm​ Full-wave center-tapped rectifier: PIV \\approx 2Vm2V_m2Vm​ Full-wave bridge rectifier: PIV = VmV_mVm​ Smoothing Capacitor Design:\nAverage load voltage: VL≅Vm−Vr2V_L \\cong V_m - \\frac{V_r}{2}VL​≅Vm​−2Vr​​ Half-wave rectifier capacitance: C≅ILTVrC \\cong \\frac{I_L T}{V_r}C≅Vr​IL​T​ Full-wave rectifier capacitance: C=ILT2VrC = \\frac{I_L T}{2V_r}C=2Vr​IL​T​ Where ILI_LIL​ = average load current, TTT = period, VrV_rVr​ = peak-to-peak ripple voltage Small-Signal Dynamic Resistance:\nrd=nVTIDQr_d = \\frac{nV_T}{I_{DQ}}rd​=IDQ​nVT​​ where VT=0.026V_T = 0.026VT​=0.026 V at 300K, n=1n = 1n=1 for silicon diodes At room temperature for n=1n = 1n=1: rd=26 mVIDQr_d = \\frac{26 \\text{ mV}}{I_{DQ}}rd​=IDQ​26 mV​ Load Line Slope:\nSlope = −1R-\\frac{1}{R}−R1​ where RRR is the total series resistance Load lines with different source voltages but same resistance are parallel Common Exam Mistakes to Avoid:\nForgetting diode forward voltage drop - Always account for 0.6-0.7V drop in practical diodes Wrong PIV calculation - Remember PIV increases with smoothing capacitors Incorrect load line intercepts - Check your math: iD=0→vD=VSSi_D = 0 \\rightarrow v_D = V_{SS}iD​=0→vD​=VSS​, vD=0→iD=VSSRv_D = 0 \\rightarrow i_D = \\frac{V_{SS}}{R}vD​=0→iD​=RVSS​​ Assuming wrong diode states - Must check ALL diodes in circuit for consistency Transfer characteristic slopes - Slope = 1 when diodes OFF, Slope = 0 when clipping occurs Quick Reference Values:\nSilicon diode forward drop: 0.6-0.7V VTV_TVT​ at room temperature: 26 mV Zener voltage tolerance: typically \\pm5% Circuit Analysis Shortcuts:\nFor Load-Line Method:\nIf one intercept is off the page, pick a convenient point on the visible area Load lines with same R are parallel Steeper load line (smaller R) → higher operating current For Rectifiers:\nHalf-wave: output for half the cycle only Full-wave: output for full cycle, requires 2 diodes minimum With capacitor: output stays near peak value with small ripple For Clippers:\nBattery + diode in series sets clipping level Diode orientation determines which peaks are clipped Multiple diodes can create multiple clipping levels For Ideal Diode Analysis:\nStart with most obvious diode states (follow source polarity) If ANY diode fails its constraint, try new combination For nnn diodes, maximum 2n2^n2n combinations possible Piecewise-Linear Model Quick Setup:\nVoltage axis intercept = VaV_aVa​ Slope = 1Ra\\frac{1}{R_a}Ra​1​ Model: RaR_aRa​ in series with VaV_aVa​ source","circuit-design-from-specifications-reverse-engineering#Circuit Design from Specifications (Reverse Engineering)":"Based on textbook principles for analyzing circuits containing nonlinear elements and wave-shaping circuits.\nGiven Transfer Characteristic → Design Clipper Circuit:\nIdentify clipping levels from horizontal segments of the characteristic Determine slopes of each segment: Slope = 1: No diodes conducting, vo=vinv_o = v_{in}vo​=vin​ Slope = 0: Diodes clipping, output held constant Calculate required battery voltages: For clipping at level VcV_cVc​: Battery voltage = Vc+VfV_c + V_fVc​+Vf​ (where VfV_fVf​ = 0.6-0.7V) Account for diode forward voltage drop in all calculations Determine diode orientations based on clipping direction: Upper clipping (positive peaks removed): Diode anode to output, cathode to positive voltage source Lower clipping (negative peaks removed): Diode cathode to output, anode to negative voltage source Select current-limiting resistor: Choose RRR large enough to limit diode current to safe levels (typically few mA), but small enough that reverse leakage current doesn’t cause significant voltage drop Given Output Waveform → Design Circuit:\nOverlay input and output waveforms to identify the modification type Measure critical levels from waveform plots Classify the circuit type: Clipping: Portions of waveform removed, creating flat tops/bottoms with sharp transitions Clamping: Entire waveform shifted vertically, maintaining original shape but different DC level Rectification: AC converted to pulsating DC, with portions of negative cycles removed or inverted Apply appropriate design methodology based on classification Verify design using load-line analysis or assumed states method Given Rectifier Specifications → Design Circuit:\nBased on textbook rectifier analysis principles:\nDetermine rectifier configuration:\nHalf-wave: Simple, 1 diode, but inefficient (conducts only half the time) Full-wave center-tap: 2 diodes, requires transformer with center tap, PIV = 2VmV_mVm​ Full-wave bridge: 4 diodes, no center tap needed, most common, PIV = VmV_mVm​ Calculate peak source voltage required:\nFor resistive load: Vm=Vload(desired)+VfV_m = V_{load(desired)} + V_fVm​=Vload(desired)​+Vf​ For capacitive filtering: Vm=Vload(avg)+Vr2+VfV_m = V_{load(avg)} + \\frac{V_r}{2} + V_fVm​=Vload(avg)​+2Vr​​+Vf​ Design smoothing capacitor (if required):\nHalf-wave: C=ILTVrC = \\frac{I_L T}{V_r}C=Vr​IL​T​ where TTT = full period Full-wave: C=ILT2VrC = \\frac{I_L T}{2V_r}C=2Vr​IL​T​ where TTT = full period Choose standard capacitor value \\geq calculated value Select diodes with appropriate PIV rating:\nPIV rating must exceed maximum reverse voltage by safety margin Half-wave with capacitor: PIV \\approx 2VmV_mVm​ Full-wave bridge: PIV = VmV_mVm​ Full-wave center-tap: PIV = 2VmV_mVm​ Add current limiting for battery charging applications:\nSeries resistance to limit peak charging current Consider that current flows only when source \u003e battery voltage","diode-fundamentals#Diode Fundamentals":"The most common type of diode, typically has a forward voltage 0.6-0.7V0.6\\text{-}0.7\\text{V}0.6-0.7V, so make this assumption Following the ideal diode graph, if you get a positive voltage you must check that your current is not negative, otherwise your guess is wrong.\nIn an ideal diode, if IdI_dId​ is positive, then the voltage is zero and the diode is on. If VdV_dVd​ is negative and the current is zero, then we say the diode is off. If a diode is supposed to be on, check that the current is greater than zero. If the current is 0, it can be either on or off, so you have to check the voltage. If you have a current greater than 0, and a voltage greater than 0, then thats fine, because you can’t have current flow without voltage. To confirm that a diode is off, you need a negative voltage. If the voltage is positive, then the diode can’t be off. Diode Bias - The triangle points in the direction of the bias of the diode. The anode (positive) must have a greater voltage than the cathode (negative) so that the voltage drop does not go against the diode (current flowing against diode bias). Voltage drop being in the reverse direction of a diode bias will result in the diode being off.\nPositive side of diode is the base of the triangle, negative side is the tip of the triangle. Current only goes through a diode one way, positive to negative. If it goes negative to positive, the current becomes 0 through the diode or current stops. If current flows in the same direction of where the diode is pointing, it is on, otherwise if the current is flowing against the diode, it is off. When Would You See 0 V Output? If the diode is reverse biased, so it’s blocking all current If the input voltage is below the forward threshold (e.g. 0.5 V \u003c 0.7 V) Zener Diode\nA regular diode allows current to flow only in the forward direction and blocks it in reverse, typically used for rectification. A Zener diode behaves like a regular diode in forward bias but is designed to conduct in reverse once a specific Zener voltage is reached, making it ideal for voltage regulation and circuit protection. In a basic circuit diagram, the Zener voltage (e.g. 5V, 10V) is typically labeled next to the Zener diode symbol to indicate the voltage at which it will start conducting in reverse bias. When a Zener diode is connected in reverse (cathode to positive), and the voltage across it exceeds the Zener voltage, it clamps the voltage across itself to approximately the Zener voltage, and conducts enough current to maintain that voltage (assuming a current-limiting resistor is present). This only works in reverse bias You must use a current-limiting resistor in series, or the diode can burn out The Zener voltage is not perfectly exact — it may vary slightly (e.g., 5.1 V \\pm 5%) Voltage Divider - The larger the resistor, the greater the voltage drop across it. The voltage divider principle applies specifically to components that are part of a single, closed series loop, not to two components in series but on different loops.\nSummary\nA pn-junction diode is a two-terminal device that conducts current easily in one direction (from anode to cathode), but not in the opposite direction. The volt–ampere characteristic has three regions: forward bias, reverse bias, and reverse breakdown. The Shockley equation relates current and voltage in a pn-junction diode. Nonlinear circuits, such as those containing a diode, can be analyzed by using the load-line technique. Zener diodes are intended to be operated in the reverse-breakdown region as constant-voltage references. Voltage regulators are circuits that produce a nearly constant output voltage while operating from a variable source. The ideal-diode model is a short circuit (on) if current flows in the forward direction and an open circuit (off) if voltage is applied in the reverse direction. In the method of assumed states, we assume a state for each diode (on or off), analyze the circuit, and check to see if the assumed states are consistent with the current directions and voltage polarities. This process is repeated until a valid set of states is found. In a piecewise-linear model for a nonlinear device, the volt–ampere characteristic is approximated by straight-line segments. On each segment, the device is modeled as a voltage source in series with a resistance. Rectifier circuits can be used to charge batteries and to convert ac voltages into constant dc voltages. Half-wave rectifiers conduct current only for one polarity of the ac input, whereas full-wave circuits conduct for both polarities. Wave-shaping circuits change the waveform of an input signal and deliver the modified wave-form to the output terminals. Clipper circuits remove that portion of the input waveform above (or below) a given level. Clamp circuits add or subtract a dc voltage, so that the positive (or negative) peaks have a specified voltage. The small-signal (incremental) equivalent circuit of a diode consists of a resistance. The value of the resistance depends on the operating point (Q point). Dc sources and coupling capacitors are replaced by short circuits in small-signal ac equivalent circuits. Diodes are replaced with their dynamic resistances","essential-circuit-patterns-to-memorize#Essential Circuit Patterns to Memorize":"Basic Clipper Configurations:\nUpper clipper: Diode cathode to positive voltage source Lower clipper: Diode anode to negative voltage source Dual clipper: Both upper and lower clippers in same circuit Zener clipper: Zener diode provides both upper and lower clipping Rectifier Configurations:\nHalf-wave: 1 diode, simple but inefficient Full-wave center-tap: 2 diodes, requires center-tapped transformer Full-wave bridge: 4 diodes, no center-tap needed, most common Load Line Construction:\nTwo-point method: Find voltage and current intercepts Alternative points: If intercept is off-page, use vD=2V,iD=VSS−2VRv_D = 2V, i_D = \\frac{V_{SS} - 2V}{R}vD​=2V,iD​=RVSS​−2V​ Multiple loads: Each different R value creates new load line slope","step-by-step-methodology-clamp-circuits#Step-by-Step Methodology: Clamp Circuits":"Clamp circuits add a DC component to an AC input waveform so that the positive or negative peaks are forced to take a specified value.\nIdentify Clamping Level: Determine the voltage to which peaks will be clamped (consider battery voltage and diode forward drop) Determine Clamping Direction: Positive peaks clamped: Diode anode connected to clamping voltage Negative peaks clamped: Diode cathode connected to clamping voltage Assume Large Capacitance: Voltage across capacitor remains approximately constant during each cycle Apply Superposition: vo(t)=vin(t)−VCv_o(t) = v_{in}(t) - V_Cvo​(t)=vin​(t)−VC​ where VCV_CVC​ is the DC voltage across the capacitor Find Steady-State Capacitor Voltage: The capacitor charges to a value that forces the appropriate peak to the clamping level Sketch Output: The output waveform is the input shifted vertically by the capacitor voltage","step-by-step-methodology-clipper-circuits#Step-by-Step Methodology: Clipper Circuits":"Clipper circuits are wave-shaping circuits that limit the output waveform by removing the portion of the input voltage that falls above or below a specified level.\nFor Output Waveform Analysis:\nIdentify Amplitude and Frequency for initial output wave form Chart basic wave form using full amplitude and frequency from original function Identify Clipping Levels (Breakpoints): Determine the critical input voltage levels (VinV_{in}Vin​) where the diodes change state (turn ON, OFF, or enter Zener breakdown). Account for the diode forward voltage drop (e.g., 0.60.60.6 V or 0.70.70.7 V) or the Zener breakdown voltage (VZV_ZVZ​). Define Operating Regions: Analyze the circuit across different ranges of VinV_{in}Vin​ corresponding to the possible combinations of diode states. Typically, analyze the negative cycle and positive cycle of VinV_{in}Vin​ separately. Analyze Linear Regions: For each defined operating region, treat the diodes as linear elements (short circuit, open circuit, or voltage source/resistor combination, depending on the diode model used). Calculate Output Voltage (VoutV_{out}Vout​): Use KVL, KCL, and Ohm’s law to determine the relationship between VoutV_{out}Vout​ and VinV_{in}Vin​ for each region. In regions where diodes are OFF, the slope of the transfer characteristic (VoutV_{out}Vout​ vs. VinV_{in}Vin​) is often 1, meaning Vout=VinV_{out} = V_{in}Vout​=Vin​ In regions where diodes are ON (clipping), VoutV_{out}Vout​ is generally limited to a constant voltage determined by the limiting elements (batteries, Zener diodes, and forward drops). Sketch Results: Sketch the transfer characteristics (VoutV_{out}Vout​ versus VinV_{in}Vin​) or the output waveform (vo(t)v_o(t)vo​(t)) for a given input waveform vin(t)v_{in}(t)vin​(t) For Transfer Characteristic Analysis:\nSet Up Axes: Plot VoutV_{out}Vout​ vs VinV_{in}Vin​ with appropriate scales Find Breakpoints: Identify critical voltages where diodes change state Determine Slopes: Slope = 1 when no diodes are conducting (output follows input) Slope = 0 when diodes are clipping (output is constant) Draw Piecewise Linear Segments: Connect breakpoints with appropriate slopes Verify Consistency: Check that diode states match the calculated voltages and currents","step-by-step-methodology-ideal-diode-analysis#Step-by-Step Methodology: Ideal Diode Analysis":"The ideal diode model treats the diode as a perfect conductor (short circuit) in the forward direction and an open circuit in the reverse direction, assuming the forward voltage drop and reverse current are negligible.\nAssume Diode States: Assume a state for each diode, either ON or OFF. For nnn diodes, consider 2n2^n2n possible combinations of diode states. Try to guess with your best judgment, considering the source direction. Replace Diodes: Redraw the circuit by replacing the assumed diode states with their linear equivalents: ON diodes →\\rightarrow→ Short circuit (VD=0V_D = 0VD​=0). OFF diodes →\\rightarrow→ Open circuit (ID=0I_D = 0ID​=0). Analyze Circuit: Analyze the resulting linear circuit using techniques like Kirchhoff’s laws and Ohm’s law to determine the following for each diode: Current (IDI_DID​) through the diodes assumed to be ON. Voltage (VDV_DVD​) across the diodes assumed to be OFF. Check Constraints: Check to see if the calculated results are consistent with the assumed state for each diode: For ON diodes: Current must flow in the forward direction (ID\u003e0I_D \u003e 0ID​\u003e0). For OFF diodes: The voltage must be reverse biased (VD\u003c0V_D \u003c 0VD​\u003c0), or positive at the cathode. Validate or Iterate: If the results are consistent with the assumed states, the analysis is finished. Otherwise, return to step 1 and choose a different combination of diode states. Note: In general, you cannot decide on the state of a particular diode until a combination works for all the diodes in the circuit.","step-by-step-methodology-load-line-method#Step-by-Step Methodology: Load-Line Method":"The load-line analysis technique is a graphical method used to analyze nonlinear circuits, such as those involving diodes or BJT amplifiers.\nSimplify the Circuit: If the circuit contains multiple linear elements connected to the nonlinear device (the load), replace the network external to the nonlinear device with its Thévenin equivalent circuit (VTHV_{TH}VTH​ and RTHR_{TH}RTH​). Apply KVL (Derive Load Line Equation): Apply Kirchhoff’s Voltage Law (KVL) to the simplified circuit loop containing the nonlinear device. This yields a linear equation (the load line equation) relating the device voltage (vDv_DvD​) and device current (iDi_DiD​). Notable Equation (Example Diode Circuit): VSS=RiD+vDV_{SS} = R i_D + v_DVSS​=RiD​+vD​ Plot the Load Line: Plot this linear KVL equation on the same set of axes used for the nonlinear device’s experimentally obtained volt–ampere characteristic. Determine two points to plot the straight line: The voltage axis intercept (where iD=0i_D = 0iD​=0): vD=VSSv_D = V_{SS}vD​=VSS​ The current axis intercept (where vD=0v_D = 0vD​=0): iD=VSSRi_D = \\frac{V_{SS}}{R}iD​=RVSS​​ Determine the Operating Point (Q-Point): The operating point is the intersection of the load line and the device characteristic curve. This point represents the simultaneous solution of the circuit. Read Results: Read the quiescent voltage (VDQV_{DQ}VDQ​) and current (IDQI_{DQ}IDQ​) at the operating point from the plot.","step-by-step-methodology-rectifier-circuits#Step-by-Step Methodology: Rectifier Circuits":"Rectifiers convert AC power into DC power, forming the basis for electronic power supplies.\nDetermine Diode Conduction Cycles: Based on the rectifier configuration (half-wave, full-wave bridge, or center-tapped), determine which diodes conduct current during the positive and negative half-cycles of the AC source voltage, vs(t)v_s(t)vs​(t) Analyze Forward Bias: When the source voltage causes a diode to be forward biased: For an Ideal Diode: The output voltage across the load (vo(t)v_o(t)vo​(t)) equals the source voltage. For an Actual Diode: The output voltage is typically reduced by the forward voltage drop, Vf≈0.7V_f \\approx 0.7Vf​≈0.7 V. Analyze Reverse Bias: When the source voltage causes the diodes to be reverse biased: For a resistive load, current flow stops, and vo(t)v_o(t)vo​(t) drops to zero (for half-wave). Calculate Peak Inverse Voltage (PIV): Determine the maximum reverse voltage that appears across the non-conducting diodes. For a half-wave rectifier with a resistive load, PIV =Vm= V_m=Vm​ (peak source voltage). For a full-wave center-tapped rectifier, PIV ≈2Vm\\approx 2 V_m≈2Vm​ Analyze Circuits with Smoothing Capacitors (If Applicable): If a capacitor (CCC) is placed in parallel with the load to smooth the voltage (reducing ripple VrV_rVr​), calculate the required capacitance or the average load voltage. Notable Equation (Average Load Voltage with Capacitor): VL≅Vm−Vr2V_L \\cong V_m - \\frac{V_r}{2}VL​≅Vm​−2Vr​​ Notable Equation (Capacitance for Half-Wave Rectifier): C≅ILTVrC \\cong \\frac{I_L T}{V_r}C≅Vr​IL​T​ Notable Equation (Capacitance for Full-Wave Rectifier): C=ILT2VrC = \\frac{I_L T}{2 V_r}C=2Vr​IL​T​ Where ILI_LIL​ is the average load current, TTT is the period, and VrV_rVr​ is the peak-to-peak ripple voltage."},"title":"Exam 1 Cheat Sheet Comprehensive"},"/electrical_notes/ee_302/exam_1_cheatsheet_pandoc/":{"data":{"":"","additional-key-formulas-and-concepts#Additional Key Formulas and Concepts":"Peak Inverse Voltage (PIV):\nHalf-wave rectifier with resistive load: PIV = VmV_mVm​ Half-wave rectifier with smoothing capacitor: PIV \\approx 2Vm2V_m2Vm​ Full-wave center-tapped rectifier: PIV \\approx 2Vm2V_m2Vm​ Full-wave bridge rectifier: PIV = VmV_mVm​ Smoothing Capacitor Design:\nAverage load voltage: VL≅Vm−Vr2V_L \\cong V_m - \\frac{V_r}{2}VL​≅Vm​−2Vr​​ Half-wave rectifier capacitance: C≅ILTVrC \\cong \\frac{I_L T}{V_r}C≅Vr​IL​T​ Full-wave rectifier capacitance: C=ILT2VrC = \\frac{I_L T}{2V_r}C=2Vr​IL​T​ Where ILI_LIL​ = average load current, TTT = period, VrV_rVr​ = peak-to-peak ripple voltage Small-Signal Dynamic Resistance:\nrd=nVTIDQr_d = \\frac{nV_T}{I_{DQ}}rd​=IDQ​nVT​​ where VT=0.026V_T = 0.026VT​=0.026 V at 300K, n=1n = 1n=1 for silicon diodes At room temperature for n=1n = 1n=1: rd=26 mVIDQr_d = \\frac{26 \\text{ mV}}{I_{DQ}}rd​=IDQ​26 mV​ Load Line Slope:\nSlope = −1R-\\frac{1}{R}−R1​ where RRR is the total series resistance Load lines with different source voltages but same resistance are parallel Common Exam Mistakes to Avoid:\nForgetting diode forward voltage drop - Always account for 0.6-0.7V drop in practical diodes Wrong PIV calculation - Remember PIV increases with smoothing capacitors Incorrect load line intercepts - Check your math: iD=0→vD=VSSi_D = 0 \\rightarrow v_D = V_{SS}iD​=0→vD​=VSS​, vD=0→iD=VSSRv_D = 0 \\rightarrow i_D = \\frac{V_{SS}}{R}vD​=0→iD​=RVSS​​ Assuming wrong diode states - Must check ALL diodes in circuit for consistency Transfer characteristic slopes - Slope = 1 when diodes OFF, Slope = 0 when clipping occurs Quick Reference Values:\nSilicon diode forward drop: 0.6-0.7V VTV_TVT​ at room temperature: 26 mV Zener voltage tolerance: typically \\pm5% Circuit Analysis Shortcuts:\nFor Load-Line Method:\nIf one intercept is off the page, pick a convenient point on the visible area Load lines with same R are parallel Steeper load line (smaller R) → higher operating current For Rectifiers:\nHalf-wave: output for half the cycle only Full-wave: output for full cycle, requires 2 diodes minimum With capacitor: output stays near peak value with small ripple For Clippers:\nBattery + diode in series sets clipping level Diode orientation determines which peaks are clipped Multiple diodes can create multiple clipping levels For Ideal Diode Analysis:\nStart with most obvious diode states (follow source polarity) If ANY diode fails its constraint, try new combination For nnn diodes, maximum 2n2^n2n combinations possible Piecewise-Linear Model Quick Setup:\nVoltage axis intercept = VaV_aVa​ Slope = 1Ra\\frac{1}{R_a}Ra​1​ Model: RaR_aRa​ in series with VaV_aVa​ source","circuit-design-from-specifications-reverse-engineering#Circuit Design from Specifications (Reverse Engineering)":"Based on textbook principles for analyzing circuits containing nonlinear elements and wave-shaping circuits.\nGiven Transfer Characteristic → Design Clipper Circuit:\nIdentify clipping levels from horizontal segments of the characteristic Determine slopes of each segment: Slope = 1: No diodes conducting, vo=vinv_o = v_{in}vo​=vin​ Slope = 0: Diodes clipping, output held constant Calculate required battery voltages: For clipping at level VcV_cVc​: Battery voltage = Vc+VfV_c + V_fVc​+Vf​ (where VfV_fVf​ = 0.6-0.7V) Account for diode forward voltage drop in all calculations Determine diode orientations based on clipping direction: Upper clipping (positive peaks removed): Diode anode to output, cathode to positive voltage source Lower clipping (negative peaks removed): Diode cathode to output, anode to negative voltage source Select current-limiting resistor: Choose RRR large enough to limit diode current to safe levels (typically few mA), but small enough that reverse leakage current doesn’t cause significant voltage drop Given Output Waveform → Design Circuit:\nOverlay input and output waveforms to identify the modification type Measure critical levels from waveform plots Classify the circuit type: Clipping: Portions of waveform removed, creating flat tops/bottoms with sharp transitions Clamping: Entire waveform shifted vertically, maintaining original shape but different DC level Rectification: AC converted to pulsating DC, with portions of negative cycles removed or inverted Apply appropriate design methodology based on classification Verify design using load-line analysis or assumed states method Given Rectifier Specifications → Design Circuit:\nBased on textbook rectifier analysis principles:\nDetermine rectifier configuration:\nHalf-wave: Simple, 1 diode, but inefficient (conducts only half the time) Full-wave center-tap: 2 diodes, requires transformer with center tap, PIV = 2VmV_mVm​ Full-wave bridge: 4 diodes, no center tap needed, most common, PIV = VmV_mVm​ Calculate peak source voltage required:\nFor resistive load: Vm=Vload(desired)+VfV_m = V_{load(desired)} + V_fVm​=Vload(desired)​+Vf​ For capacitive filtering: Vm=Vload(avg)+Vr2+VfV_m = V_{load(avg)} + \\frac{V_r}{2} + V_fVm​=Vload(avg)​+2Vr​​+Vf​ Design smoothing capacitor (if required):\nHalf-wave: C=ILTVrC = \\frac{I_L T}{V_r}C=Vr​IL​T​ where TTT = full period Full-wave: C=ILT2VrC = \\frac{I_L T}{2V_r}C=2Vr​IL​T​ where TTT = full period Choose standard capacitor value \\geq calculated value Select diodes with appropriate PIV rating:\nPIV rating must exceed maximum reverse voltage by safety margin Half-wave with capacitor: PIV \\approx 2VmV_mVm​ Full-wave bridge: PIV = VmV_mVm​ Full-wave center-tap: PIV = 2VmV_mVm​ Add current limiting for battery charging applications:\nSeries resistance to limit peak charging current Consider that current flows only when source \u003e battery voltage","diode-fundamentals#Diode Fundamentals":"The most common type of diode, typically has a forward voltage 0.6-0.7V0.6\\text{-}0.7\\text{V}0.6-0.7V, so make this assumption Following the ideal diode graph, if you get a positive voltage you must check that your current is not negative, otherwise your guess is wrong.\nIn an ideal diode, if IdI_dId​ is positive, then the voltage is zero and the diode is on. If VdV_dVd​ is negative and the current is zero, then we say the diode is off. If a diode is supposed to be on, check that the current is greater than zero. If the current is 0, it can be either on or off, so you have to check the voltage. If you have a current greater than 0, and a voltage greater than 0, then thats fine, because you can’t have current flow without voltage. To confirm that a diode is off, you need a negative voltage. If the voltage is positive, then the diode can’t be off. Diode Bias - The triangle points in the direction of the bias of the diode. The anode (positive) must have a greater voltage than the cathode (negative) so that the voltage drop does not go against the diode (current flowing against diode bias). Voltage drop being in the reverse direction of a diode bias will result in the diode being off.\nPositive side of diode is the base of the triangle, negative side is the tip of the triangle. Current only goes through a diode one way, positive to negative. If it goes negative to positive, the current becomes 0 through the diode or current stops. If current flows in the same direction of where the diode is pointing, it is on, otherwise if the current is flowing against the diode, it is off. When Would You See 0 V Output? If the diode is reverse biased, so it’s blocking all current If the input voltage is below the forward threshold (e.g. 0.5 V \u003c 0.7 V) Zener Diode\nA regular diode allows current to flow only in the forward direction and blocks it in reverse, typically used for rectification. A Zener diode behaves like a regular diode in forward bias but is designed to conduct in reverse once a specific Zener voltage is reached, making it ideal for voltage regulation and circuit protection. In a basic circuit diagram, the Zener voltage (e.g. 5V, 10V) is typically labeled next to the Zener diode symbol to indicate the voltage at which it will start conducting in reverse bias. When a Zener diode is connected in reverse (cathode to positive), and the voltage across it exceeds the Zener voltage, it clamps the voltage across itself to approximately the Zener voltage, and conducts enough current to maintain that voltage (assuming a current-limiting resistor is present). This only works in reverse bias You must use a current-limiting resistor in series, or the diode can burn out The Zener voltage is not perfectly exact — it may vary slightly (e.g., 5.1 V \\pm 5%) Voltage Divider - The larger the resistor, the greater the voltage drop across it. The voltage divider principle applies specifically to components that are part of a single, closed series loop, not to two components in series but on different loops.\nSummary\nA pn-junction diode is a two-terminal device that conducts current easily in one direction (from anode to cathode), but not in the opposite direction. The volt–ampere characteristic has three regions: forward bias, reverse bias, and reverse breakdown. The Shockley equation relates current and voltage in a pn-junction diode. Nonlinear circuits, such as those containing a diode, can be analyzed by using the load-line technique. Zener diodes are intended to be operated in the reverse-breakdown region as constant-voltage references. Voltage regulators are circuits that produce a nearly constant output voltage while operating from a variable source. The ideal-diode model is a short circuit (on) if current flows in the forward direction and an open circuit (off) if voltage is applied in the reverse direction. In the method of assumed states, we assume a state for each diode (on or off), analyze the circuit, and check to see if the assumed states are consistent with the current directions and voltage polarities. This process is repeated until a valid set of states is found. In a piecewise-linear model for a nonlinear device, the volt–ampere characteristic is approximated by straight-line segments. On each segment, the device is modeled as a voltage source in series with a resistance. Rectifier circuits can be used to charge batteries and to convert ac voltages into constant dc voltages. Half-wave rectifiers conduct current only for one polarity of the ac input, whereas full-wave circuits conduct for both polarities. Wave-shaping circuits change the waveform of an input signal and deliver the modified wave-form to the output terminals. Clipper circuits remove that portion of the input waveform above (or below) a given level. Clamp circuits add or subtract a dc voltage, so that the positive (or negative) peaks have a specified voltage. The small-signal (incremental) equivalent circuit of a diode consists of a resistance. The value of the resistance depends on the operating point (Q point). Dc sources and coupling capacitors are replaced by short circuits in small-signal ac equivalent circuits. Diodes are replaced with their dynamic resistances","essential-circuit-patterns-to-memorize#Essential Circuit Patterns to Memorize":"Basic Clipper Configurations:\nUpper clipper: Diode cathode to positive voltage source Lower clipper: Diode anode to negative voltage source Dual clipper: Both upper and lower clippers in same circuit Zener clipper: Zener diode provides both upper and lower clipping Rectifier Configurations:\nHalf-wave: 1 diode, simple but inefficient Full-wave center-tap: 2 diodes, requires center-tapped transformer Full-wave bridge: 4 diodes, no center-tap needed, most common Load Line Construction:\nTwo-point method: Find voltage and current intercepts Alternative points: If intercept is off-page, use vD=2V,iD=VSS−2VRv_D = 2V, i_D = \\frac{V_{SS} - 2V}{R}vD​=2V,iD​=RVSS​−2V​ Multiple loads: Each different R value creates new load line slope","step-by-step-methodology-clamp-circuits#Step-by-Step Methodology: Clamp Circuits":"Clamp circuits add a DC component to an AC input waveform so that the positive or negative peaks are forced to take a specified value.\nIdentify Clamping Level: Determine the voltage to which peaks will be clamped (consider battery voltage and diode forward drop) Determine Clamping Direction: Positive peaks clamped: Diode anode connected to clamping voltage Negative peaks clamped: Diode cathode connected to clamping voltage Assume Large Capacitance: Voltage across capacitor remains approximately constant during each cycle Apply Superposition: vo(t)=vin(t)−VCv_o(t) = v_{in}(t) - V_Cvo​(t)=vin​(t)−VC​ where VCV_CVC​ is the DC voltage across the capacitor Find Steady-State Capacitor Voltage: The capacitor charges to a value that forces the appropriate peak to the clamping level Sketch Output: The output waveform is the input shifted vertically by the capacitor voltage","step-by-step-methodology-clipper-circuits#Step-by-Step Methodology: Clipper Circuits":"Clipper circuits are wave-shaping circuits that limit the output waveform by removing the portion of the input voltage that falls above or below a specified level.\nFor Output Waveform Analysis:\nIdentify Amplitude and Frequency for initial output wave form Chart basic wave form using full amplitude and frequency from original function Identify Clipping Levels (Breakpoints): Determine the critical input voltage levels (VinV_{in}Vin​) where the diodes change state (turn ON, OFF, or enter Zener breakdown). Account for the diode forward voltage drop (e.g., 0.60.60.6 V or 0.70.70.7 V) or the Zener breakdown voltage (VZV_ZVZ​). Define Operating Regions: Analyze the circuit across different ranges of VinV_{in}Vin​ corresponding to the possible combinations of diode states. Typically, analyze the negative cycle and positive cycle of VinV_{in}Vin​ separately. Analyze Linear Regions: For each defined operating region, treat the diodes as linear elements (short circuit, open circuit, or voltage source/resistor combination, depending on the diode model used). Calculate Output Voltage (VoutV_{out}Vout​): Use KVL, KCL, and Ohm’s law to determine the relationship between VoutV_{out}Vout​ and VinV_{in}Vin​ for each region. In regions where diodes are OFF, the slope of the transfer characteristic (VoutV_{out}Vout​ vs. VinV_{in}Vin​) is often 1, meaning Vout=VinV_{out} = V_{in}Vout​=Vin​ In regions where diodes are ON (clipping), VoutV_{out}Vout​ is generally limited to a constant voltage determined by the limiting elements (batteries, Zener diodes, and forward drops). Sketch Results: Sketch the transfer characteristics (VoutV_{out}Vout​ versus VinV_{in}Vin​) or the output waveform (vo(t)v_o(t)vo​(t)) for a given input waveform vin(t)v_{in}(t)vin​(t) For Transfer Characteristic Analysis:\nSet Up Axes: Plot VoutV_{out}Vout​ vs VinV_{in}Vin​ with appropriate scales Find Breakpoints: Identify critical voltages where diodes change state Determine Slopes: Slope = 1 when no diodes are conducting (output follows input) Slope = 0 when diodes are clipping (output is constant) Draw Piecewise Linear Segments: Connect breakpoints with appropriate slopes Verify Consistency: Check that diode states match the calculated voltages and currents","step-by-step-methodology-ideal-diode-analysis#Step-by-Step Methodology: Ideal Diode Analysis":"The ideal diode model treats the diode as a perfect conductor (short circuit) in the forward direction and an open circuit in the reverse direction, assuming the forward voltage drop and reverse current are negligible.\nAssume Diode States: Assume a state for each diode, either ON or OFF. For nnn diodes, consider 2n2^n2n possible combinations of diode states. Try to guess with your best judgment, considering the source direction. Replace Diodes: Redraw the circuit by replacing the assumed diode states with their linear equivalents: ON diodes →\\rightarrow→ Short circuit (VD=0V_D = 0VD​=0). OFF diodes →\\rightarrow→ Open circuit (ID=0I_D = 0ID​=0). Analyze Circuit: Analyze the resulting linear circuit using techniques like Kirchhoff’s laws and Ohm’s law to determine the following for each diode: Current (IDI_DID​) through the diodes assumed to be ON. Voltage (VDV_DVD​) across the diodes assumed to be OFF. Check Constraints: Check to see if the calculated results are consistent with the assumed state for each diode: For ON diodes: Current must flow in the forward direction (ID\u003e0I_D \u003e 0ID​\u003e0). For OFF diodes: The voltage must be reverse biased (VD\u003c0V_D \u003c 0VD​\u003c0), or positive at the cathode. Validate or Iterate: If the results are consistent with the assumed states, the analysis is finished. Otherwise, return to step 1 and choose a different combination of diode states. Note: In general, you cannot decide on the state of a particular diode until a combination works for all the diodes in the circuit.","step-by-step-methodology-load-line-method#Step-by-Step Methodology: Load-Line Method":"The load-line analysis technique is a graphical method used to analyze nonlinear circuits, such as those involving diodes or BJT amplifiers.\nSimplify the Circuit: If the circuit contains multiple linear elements connected to the nonlinear device (the load), replace the network external to the nonlinear device with its Thévenin equivalent circuit (VTHV_{TH}VTH​ and RTHR_{TH}RTH​). Apply KVL (Derive Load Line Equation): Apply Kirchhoff’s Voltage Law (KVL) to the simplified circuit loop containing the nonlinear device. This yields a linear equation (the load line equation) relating the device voltage (vDv_DvD​) and device current (iDi_DiD​). Notable Equation (Example Diode Circuit): VSS=RiD+vDV_{SS} = R i_D + v_DVSS​=RiD​+vD​ Plot the Load Line: Plot this linear KVL equation on the same set of axes used for the nonlinear device’s experimentally obtained volt–ampere characteristic. Determine two points to plot the straight line: The voltage axis intercept (where iD=0i_D = 0iD​=0): vD=VSSv_D = V_{SS}vD​=VSS​ The current axis intercept (where vD=0v_D = 0vD​=0): iD=VSSRi_D = \\frac{V_{SS}}{R}iD​=RVSS​​ Determine the Operating Point (Q-Point): The operating point is the intersection of the load line and the device characteristic curve. This point represents the simultaneous solution of the circuit. Read Results: Read the quiescent voltage (VDQV_{DQ}VDQ​) and current (IDQI_{DQ}IDQ​) at the operating point from the plot.","step-by-step-methodology-rectifier-circuits#Step-by-Step Methodology: Rectifier Circuits":"Rectifiers convert AC power into DC power, forming the basis for electronic power supplies.\nDetermine Diode Conduction Cycles: Based on the rectifier configuration (half-wave, full-wave bridge, or center-tapped), determine which diodes conduct current during the positive and negative half-cycles of the AC source voltage, vs(t)v_s(t)vs​(t) Analyze Forward Bias: When the source voltage causes a diode to be forward biased: For an Ideal Diode: The output voltage across the load (vo(t)v_o(t)vo​(t)) equals the source voltage. For an Actual Diode: The output voltage is typically reduced by the forward voltage drop, Vf≈0.7V_f \\approx 0.7Vf​≈0.7 V. Analyze Reverse Bias: When the source voltage causes the diodes to be reverse biased: For a resistive load, current flow stops, and vo(t)v_o(t)vo​(t) drops to zero (for half-wave). Calculate Peak Inverse Voltage (PIV): Determine the maximum reverse voltage that appears across the non-conducting diodes. For a half-wave rectifier with a resistive load, PIV =Vm= V_m=Vm​ (peak source voltage). For a full-wave center-tapped rectifier, PIV ≈2Vm\\approx 2 V_m≈2Vm​ Analyze Circuits with Smoothing Capacitors (If Applicable): If a capacitor (CCC) is placed in parallel with the load to smooth the voltage (reducing ripple VrV_rVr​), calculate the required capacitance or the average load voltage. Notable Equation (Average Load Voltage with Capacitor): VL≅Vm−Vr2V_L \\cong V_m - \\frac{V_r}{2}VL​≅Vm​−2Vr​​ Notable Equation (Capacitance for Half-Wave Rectifier): C≅ILTVrC \\cong \\frac{I_L T}{V_r}C≅Vr​IL​T​ Notable Equation (Capacitance for Full-Wave Rectifier): C=ILT2VrC = \\frac{I_L T}{2 V_r}C=2Vr​IL​T​ Where ILI_LIL​ is the average load current, TTT is the period, and VrV_rVr​ is the peak-to-peak ripple voltage."},"title":"Exam 1 Cheat Sheet Comprehensive"},"/electrical_notes/ee_302/exam_1_cheetsheet/":{"data":{"":"The most common type of diode, typically has a forward voltage 0.6-7V0.6\\text{-}7\\text{V}0.6-7V, so make this assumption Following the ideal diode graph, if you get a positive voltage you must check that your current is not negative, otherwise your guess is wrong.\nIn an ideal diode, if IdI_dId​ is positive, then the voltage is zero and the diode is on. If VdV_dVd​ is negative and the current is zero, then we say the diode is off.\nIf a diode is supposed to be on, check that the current is greater than zero. If the current is 0, it can be either on or off, so you have to check the voltage.\nIf you have a current greater than 0, and a voltage greater than 0, then thats fine, because you can’t have current flow without voltage. To confirm that a diode is off, you need a negative voltage. If the voltage is positive, then the diode can’t be off.\nDiode Bias - The triangle points in the direction of the bias of the diode. the anode (positive) must have a greater voltage than the cathode (negative) so that the voltage drop does not go against the diode (current flowing against diode bias). Voltage drop being in the reverse direction of a diode bias will result in the diode being off.\nPositive side of diode is the base of the triangle, negative side is the tip of the triangle. Current only goes through a diode one way, positive to negative. If it goes negative to positive, the current becomes 0 through the diode or current stops. If current flows in the same direction of where the diode is pointing, it is on, otherwise if the current is flowing against the diode, it is off. Voltage Divider - The larger the resistor, the greater the voltage drop across it. The voltage divider principle applies specifically to components that are part of a single, closed series loop, not to two components in series but on different loops.","step-by-step-methodology-ideal-diode-analysis#Step-by-Step Methodology: Ideal Diode Analysis":"Assume diode states: For nnn diodes, consider 2n2^n2n possible ON/OFF combinations Replace diodes: ON → short circuit, OFF → open circuit Analyze linear circuit: Calculate IDI_DID​ and VDV_DVD​ for each diode Check constraints: ON diodes: ID\u003e0I_D \u003e 0ID​\u003e0 OFF diodes: VD\u003c0V_D \u003c 0VD​\u003c0 Validate or iterate: If constraints satisfied, solution found; otherwise try different states","step-by-step-methodology-load-line-analysis#Step-by-Step Methodology: Load-Line Analysis":"Derive KVL equation: Write voltage equation relating device voltage and current Identify intercepts: Find voltage and current intercepts Plot load line: Draw line on device characteristic plot Find Q-point: Locate intersection of load line and device curve Analyze operation: Determine voltage, current, and power at Q-point","step-by-step-methodology-wave-shaping-analysis#Step-by-Step Methodology: Wave-Shaping Analysis":"Identify breakpoints: Determine input voltages where diodes change state Analyze regions: Consider each operating region separately Apply circuit laws: Use KVL/KCL for each diode state Construct transfer characteristic: Plot VoV_oVo​ vs VinV_{in}Vin​ Verify operation: Check diode states are consistent with assumptions"},"title":"Exam 1 Cheat Sheet"},"/electrical_notes/ee_302/exam_1_roadmap_chat/":{"data":{"":"","1-diode-fundamentals-and-models#1. Diode Fundamentals and Models":"","2-load-line-analysis#2. Load-Line Analysis":"","3-amplifier-analysis#3. Amplifier Analysis":"","4-rectifiers#4. Rectifiers":"","5-wave-shaping-circuits-clippers-and-clamp-circuits#5. Wave-Shaping Circuits (Clippers and Clamp Circuits)":"","course-usage-and-key-concepts#Course Usage and Key Concepts":"Diodes are fundamental electronic devices used primarily because of their nonlinear volt–ampere characteristics.\nShockley Diode Equation (real diode behavior): ID=IS(eVDnVT−1) I_D = I_S \\left( e^{\\frac{V_D}{nV_T}} - 1 \\right) ID​=IS​(enVT​VD​​−1)Where:\nISI_SIS​ = reverse saturation current VDV_DVD​ = diode voltage VT=kTqV_T = \\frac{kT}{q}VT​=qkT​ = thermal voltage (~26 mV at room temperature) nnn = ideality factor (typically 1–2) Ideal Diode Model: ID={0,VD\u003c0(reverse bias)any ID\u003e0,VD=0(forward bias) I_D = \\begin{cases} 0, \u0026 V_D \u003c 0 \\quad (\\text{reverse bias}) \\\\ \\text{any } I_D \u003e 0, \u0026 V_D = 0 \\quad (\\text{forward bias}) \\end{cases} ID​={0,any ID​\u003e0,​VD​\u003c0(reverse bias)VD​=0(forward bias)​ Piecewise-Linear Model:\nApproximates forward bias as:\nVD≈Vγ+IDRD V_D \\approx V_\\gamma + I_D R_D VD​≈Vγ​+ID​RD​Where VγV_\\gammaVγ​ is the threshold (\\approx0.7 V for silicon) and RDR_DRD​ is the diode’s dynamic resistance.\nZener Diode (Reverse Breakdown): VZ≈constant (e.g., 5.1 V)for IZ≥IZ,min V_Z \\approx \\text{constant (e.g., } 5.1 \\, \\text{V)} \\quad \\text{for } I_Z \\geq I_{Z,\\text{min}} VZ​≈constant (e.g., 5.1V)for IZ​≥IZ,min​","course-usage-and-key-concepts-1#Course Usage and Key Concepts":"Load-line analysis finds the operating point (Q-point) where the diode’s characteristic curve intersects the circuit’s linear constraint.\nCircuit Equation (KVL): VSS=IDR+VD V_{SS} = I_D R + V_D VSS​=ID​R+VD​Rearranged as:\nID=VSS−VDR I_D = \\frac{V_{SS} - V_D}{R} ID​=RVSS​−VD​​This is the load line.\nIntercepts: Voltage intercept: VD=VSSV_D = V_{SS}VD​=VSS​ (when ID=0I_D = 0ID​=0) Current intercept: ID=VSSRI_D = \\frac{V_{SS}}{R}ID​=RVSS​​ (when VD=0V_D = 0VD​=0) Operating Point:\nIntersection of the load line with the nonlinear device equation (e.g., Shockley equation).","course-usage-and-key-concepts-2#Course Usage and Key Concepts":"Amplifiers are analyzed using large-signal DC bias (to set the operating point) and small-signal AC models (to calculate gain).\nBJT Large-Signal Equations: IC≈βIB,VBE≈0.7 V (forward-active) I_C \\approx \\beta I_B, \\quad V_{BE} \\approx 0.7 \\, \\text{V (forward-active)} IC​≈βIB​,VBE​≈0.7V (forward-active)VCE=VC−VE V_{CE} = V_C - V_E VCE​=VC​−VE​ BJT Small-Signal Parameters: gm=ICVT,rπ=βgm g_m = \\frac{I_C}{V_T}, \\quad r_\\pi = \\frac{\\beta}{g_m} gm​=VT​IC​​,rπ​=gm​β​ Common-Emitter Voltage Gain: Av=−gmRC∥RL A_v = -g_m R_C \\parallel R_L Av​=−gm​RC​∥RL​ MOSFET Small-Signal Model: id=gmvgs,gm=2IDVOV,VOV=VGS−Vth i_d = g_m v_{gs}, \\quad g_m = \\frac{2 I_D}{V_{OV}}, \\quad V_{OV} = V_{GS} - V_{th} id​=gm​vgs​,gm​=VOV​2ID​​,VOV​=VGS​−Vth​ Op Amp Ideal Gain Equations: Inverting:\nAv=−RfRin A_v = -\\frac{R_f}{R_{in}} Av​=−Rin​Rf​​ Noninverting:\nAv=1+RfRin A_v = 1 + \\frac{R_f}{R_{in}} Av​=1+Rin​Rf​​","course-usage-and-key-concepts-3#Course Usage and Key Concepts":"Rectifiers convert AC input into DC output.\nHalf-Wave Rectifier Average DC Output: VDC=Vmπ V_{DC} = \\frac{V_m}{\\pi} VDC​=πVm​​ Full-Wave Rectifier Average DC Output: VDC=2Vmπ V_{DC} = \\frac{2 V_m}{\\pi} VDC​=π2Vm​​Where VmV_mVm​ is the peak input voltage.\nRipple Voltage with Filter Capacitor: Vr≈IloadfC V_r \\approx \\frac{I_{load}}{f C} Vr​≈fCIload​​Where:\nIloadI_{load}Iload​ = average load current fff = ripple frequency (fACf_{AC}fAC​ for half-wave, 2fAC2f_{AC}2fAC​ for full-wave) CCC = filter capacitance Peak Inverse Voltage (PIV): Half-wave: PIV=VmPIV = V_mPIV=Vm​ Full-wave bridge: PIV=VmPIV = V_mPIV=Vm​","course-usage-and-key-concepts-4#Course Usage and Key Concepts":"Wave-shaping circuits modify signals using clipping or clamping action.\nSeries Clipper Transfer Relation: Vo={0,Vin\u003eVγ(positive clip)Vin,Vin≤Vγ V_o = \\begin{cases} 0, \u0026 V_{in} \u003e V_\\gamma \\quad (\\text{positive clip}) \\\\ V_{in}, \u0026 V_{in} \\leq V_\\gamma \\end{cases} Vo​={0,Vin​,​Vin​\u003eVγ​(positive clip)Vin​≤Vγ​​ Parallel Clipper with DC Source: Vo≈Vrefwhen diode conducts (clipping level) V_o \\approx V_{ref} \\quad \\text{when diode conducts (clipping level)} Vo​≈Vref​when diode conducts (clipping level) Clamp Circuit Equation:\nFor a capacitor and diode clamper, Vo(t)=Vin(t)+VDC V_o(t) = V_{in}(t) + V_{DC} Vo​(t)=Vin​(t)+VDC​Where VDCV_{DC}VDC​ is the clamping voltage determined by diode orientation and reference source.\nRC Time Constant Condition: τ=RC≫Tsignal \\tau = RC \\gg T_{signal} τ=RC≫Tsignal​Ensures capacitor voltage doesn’t discharge significantly during one cycle.","high-level-topics-for-understanding-and-analysis#High-Level Topics for Understanding and Analysis":"The subjects you need to understand can be categorized into five core topics:\nDiode Fundamentals and Models (Including Ideal Diodes, Piecewise Linear Models, and Zener Diodes) Load-Line Analysis (Graphical Method for Nonlinear Circuits) Amplifier Analysis (Large-Signal DC Bias and Small-Signal AC Models for BJT/FET) Rectifiers (AC-to-DC Conversion) Wave-Shaping Circuits (Clippers and Clamp Circuits)"},"title":"Diode Fundamentals Roadmap Chat"},"/electrical_notes/ee_302/exam_1_roadmap_notebooklm/":{"data":{"":"","active-region#Active Region":"IC=βIBVBE=0.7 V (typical)Constraint:VCE\u003e0.2 V,IB\u003e0 \\begin{aligned} I_C \u0026= \\beta I_B \\\\ V_{BE} \u0026= 0.7 \\text{ V (typical)} \\\\ \\text{Constraint:} \\quad \u0026V_{CE} \u003e 0.2 \\text{ V}, \\quad I_B \u003e 0 \\end{aligned} IC​VBE​Constraint:​=βIB​=0.7 V (typical)VCE​\u003e0.2 V,IB​\u003e0​","bjt-operating-regions-and-models#BJT Operating Regions and Models":"","clipper-circuit-analysis#Clipper Circuit Analysis":"","common-configurations#Common Configurations":"Inverting amplifier:Av=−R2R1Non-inverting amplifier:Av=1+R2R1 \\begin{aligned} \\text{Inverting amplifier:} \\quad \u0026A_v = -\\frac{R_2}{R_1} \\\\ \\text{Non-inverting amplifier:} \\quad \u0026A_v = 1 + \\frac{R_2}{R_1} \\end{aligned} Inverting amplifier:Non-inverting amplifier:​Av​=−R1​R2​​Av​=1+R1​R2​​​","diode-models-and-equations#Diode Models and Equations":"","fet-small-signal-parameters#FET Small-Signal Parameters":"gm=∂ID∂VGS∣Qrd=∂VDS∂ID∣Q \\begin{aligned} g_m \u0026= \\frac{\\partial I_D}{\\partial V_{GS}}\\bigg|_{Q} \\\\ r_d \u0026= \\frac{\\partial V_{DS}}{\\partial I_D}\\bigg|_{Q} \\end{aligned} gm​rd​​=∂VGS​∂ID​​​Q​=∂ID​∂VDS​​​Q​​","full-wave-rectifier#Full-Wave Rectifier":"VDC=2VmπIDC=2ImπPIV=2Vm (center-tap) \\begin{aligned} V_{DC} \u0026= \\frac{2V_m}{\\pi} \\\\ I_{DC} \u0026= \\frac{2I_m}{\\pi} \\\\ \\text{PIV} \u0026= 2V_m \\text{ (center-tap)} \\end{aligned} VDC​IDC​PIV​=π2Vm​​=π2Im​​=2Vm​ (center-tap)​","half-wave-rectifier#Half-Wave Rectifier":"VDC=VmπIDC=ImπPIV=Vm \\begin{aligned} V_{DC} \u0026= \\frac{V_m}{\\pi} \\\\ I_{DC} \u0026= \\frac{I_m}{\\pi} \\\\ \\text{PIV} \u0026= V_m \\end{aligned} VDC​IDC​PIV​=πVm​​=πIm​​=Vm​​","i-diode-fundamentals-and-models#I. Diode Fundamentals and Models":"","ideal-diode-model#Ideal Diode Model":"{VD=0,ID≥0 (ON state)ID=0,VD\u003c0 (OFF state) \\begin{cases} V_D = 0, \u0026 I_D \\geq 0 \\text{ (ON state)} \\\\ I_D = 0, \u0026 V_D \u003c 0 \\text{ (OFF state)} \\end{cases} {VD​=0,ID​=0,​ID​≥0 (ON state)VD​\u003c0 (OFF state)​","ideal-op-amp-constraints#Ideal Op-Amp Constraints":"V+=V−(summing-point constraint)I+=I−=0(infinite input impedance) \\begin{aligned} V^+ \u0026= V^- \\quad \\text{(summing-point constraint)} \\\\ I^+ \u0026= I^- = 0 \\quad \\text{(infinite input impedance)} \\end{aligned} V+I+​=V−(summing-point constraint)=I−=0(infinite input impedance)​","ii-load-line-analysis#II. Load-Line Analysis":"","iii-amplifier-analysis-bjtfet#III. Amplifier Analysis (BJT/FET)":"","iv-rectifier-circuits#IV. Rectifier Circuits":"","load-line-equations#Load-Line Equations":"For a circuit with voltage source VSSV_{SS}VSS​ and resistance RRR:\nVSS=VD+IDRV_{SS} = V_D + I_D RVSS​=VD​+ID​RLoad line parameters: Voltage intercept:VD∣ID=0=VSSCurrent intercept:ID∣VD=0=VSSRSlope:dIDdVD=−1R \\begin{aligned} \\text{Voltage intercept:} \\quad \u0026V_D|_{I_D=0} = V_{SS} \\\\ \\text{Current intercept:} \\quad \u0026I_D|_{V_D=0} = \\frac{V_{SS}}{R} \\\\ \\text{Slope:} \\quad \u0026\\frac{dI_D}{dV_D} = -\\frac{1}{R} \\end{aligned} Voltage intercept:Current intercept:Slope:​VD​∣ID​=0​=VSS​ID​∣VD​=0​=RVSS​​dVD​dID​​=−R1​​","op-amp-analysis#Op-Amp Analysis":"","parallel-clipper-transfer-function#Parallel Clipper Transfer Function":"Vo={Vref+VD,Vin\u003eVref+VDVin,Vin≤Vref+VD V_o = \\begin{cases} V_{ref} + V_D, \u0026 V_{in} \u003e V_{ref} + V_D \\\\ V_{in}, \u0026 V_{in} \\leq V_{ref} + V_D \\end{cases} Vo​={Vref​+VD​,Vin​,​Vin​\u003eVref​+VD​Vin​≤Vref​+VD​​","piecewise-linear-model#Piecewise-Linear Model":"{VD=VD0+rdID,ID\u003e0 (forward bias)ID=0,VD\u003cVD0 (reverse bias) \\begin{cases} V_D = V_{D0} + r_d I_D, \u0026 I_D \u003e 0 \\text{ (forward bias)} \\\\ I_D = 0, \u0026 V_D \u003c V_{D0} \\text{ (reverse bias)} \\end{cases} {VD​=VD0​+rd​ID​,ID​=0,​ID​\u003e0 (forward bias)VD​\u003cVD0​ (reverse bias)​Where VD0V_{D0}VD0​ is the forward voltage drop and rdr_drd​ is the dynamic resistance.","rectifier-analysis#Rectifier Analysis":"","ripple-with-capacitive-filter#Ripple with Capacitive Filter":"Vr=IDCfC V_r = \\frac{I_{DC}}{fC} Vr​=fCIDC​​Where fff is the ripple frequency and CCC is the filter capacitance.","series-clipper-transfer-function#Series Clipper Transfer Function":"Vo={Vin−VD,Vin\u003eVref+VDVref,Vin≤Vref+VD V_o = \\begin{cases} V_{in} - V_D, \u0026 V_{in} \u003e V_{ref} + V_D \\\\ V_{ref}, \u0026 V_{in} \\leq V_{ref} + V_D \\end{cases} Vo​={Vin​−VD​,Vref​,​Vin​\u003eVref​+VD​Vin​≤Vref​+VD​​","small-signal-parameters#Small-Signal Parameters":"gm=ICVT=IC26 mVrπ=βgm=βVTIC \\begin{aligned} g_m \u0026= \\frac{I_C}{V_T} = \\frac{I_C}{26 \\text{ mV}} \\\\ r_\\pi \u0026= \\frac{\\beta}{g_m} = \\frac{\\beta V_T}{I_C} \\end{aligned} gm​rπ​​=VT​IC​​=26 mVIC​​=gm​β​=IC​βVT​​​","step-by-step-methodology-ideal-diode-analysis#Step-by-Step Methodology: Ideal Diode Analysis":"Assume diode states: For nnn diodes, consider 2n2^n2n possible ON/OFF combinations Replace diodes: ON → short circuit, OFF → open circuit Analyze linear circuit: Calculate IDI_DID​ and VDV_DVD​ for each diode Check constraints: ON diodes: ID\u003e0I_D \u003e 0ID​\u003e0 OFF diodes: VD\u003c0V_D \u003c 0VD​\u003c0 Validate or iterate: If constraints satisfied, solution found; otherwise try different states","step-by-step-methodology-load-line-analysis#Step-by-Step Methodology: Load-Line Analysis":"Derive KVL equation: Write voltage equation relating device voltage and current Identify intercepts: Find voltage and current intercepts Plot load line: Draw line on device characteristic plot Find Q-point: Locate intersection of load line and device curve Analyze operation: Determine voltage, current, and power at Q-point","step-by-step-methodology-transistor-bias-analysis#Step-by-Step Methodology: Transistor Bias Analysis":"Assume operating region: Start with active region for amplifiers Apply large-signal model: Use appropriate equations for assumed region Solve DC circuit: Calculate IB,IC,VBE,VCEI_B, I_C, V_{BE}, V_{CE}IB​,IC​,VBE​,VCE​ Check constraints: Verify region constraints are satisfied Iterate if necessary: Try different region if constraints violated","step-by-step-methodology-wave-shaping-analysis#Step-by-Step Methodology: Wave-Shaping Analysis":"Identify breakpoints: Determine input voltages where diodes change state Analyze regions: Consider each operating region separately Apply circuit laws: Use KVL/KCL for each diode state Construct transfer characteristic: Plot VoV_oVo​ vs VinV_{in}Vin​ Verify operation: Check diode states are consistent with assumptions flowchart TD A[\"Input Signal v_in(t)\"] --\u003e B[\"Diode Circuit Analysis\"] B --\u003e C[\"Determine Diode States\"] C --\u003e D[\"Apply Circuit Model\"] D --\u003e E[\"Calculate Output v_o(t)\"] E --\u003e F{\"Circuit Type\"} F --\u003e F1[\"Rectifier Circuit\"] F --\u003e F2[\"Amplifier Circuit\"] F --\u003e F3[\"Wave-Shaping Circuit\"] F1 --\u003e G1[\"AC-to-DC Conversion\"] F2 --\u003e G2[\"Signal Amplification\"] F3 --\u003e G3[\"Waveform Modification\"] G1 --\u003e H[\"Design Verification\"] G2 --\u003e H G3 --\u003e H H --\u003e I[\"Performance Analysis\"] I --\u003e J{\"Meet Specifications?\"} J --\u003e K[\"Final Design\"] J --\u003e L[\"Iterate Design\"] L --\u003e B","subtopics-to-familiarize#Subtopics to Familiarize":"Basic Diode Operation: Anode and cathode terminals, forward-bias region (low resistance), reverse-bias region (high resistance), reverse-breakdown region Shockley Equation: ID=IS(eVD/nVT−1)I_D = I_S(e^{V_D/nV_T} - 1)ID​=IS​(eVD​/nVT​−1) Ideal Diode Model: Perfect switch approximation Piecewise-Linear Models: Straight-line segment approximations Zener Diodes: Constant-voltage references in breakdown region","subtopics-to-familiarize-1#Subtopics to Familiarize":"Load-line equation: KVL-derived linear relationship Operating point: Intersection of load line and device characteristic Q-point stability: Effect of parameter variations Signal swing analysis: Maximum undistorted output","subtopics-to-familiarize-2#Subtopics to Familiarize":"Operating regions: Active, saturation, cutoff DC bias analysis: Large-signal models and Q-point determination Small-signal analysis: Linear equivalent circuits Amplifier parameters: Gain (AvA_vAv​), input impedance (ZinZ_{in}Zin​), output impedance (ZoZ_oZo​)","subtopics-to-familiarize-3#Subtopics to Familiarize":"Half-wave rectifiers: Single diode, 50% conduction Full-wave rectifiers: Center-tap and bridge configurations Smoothing capacitors: Ripple reduction Peak Inverse Voltage (PIV): Maximum reverse voltage rating","subtopics-to-familiarize-4#Subtopics to Familiarize":"Clipper circuits: Remove portions of waveforms, (Waveform Trimming) Clamper circuits: Shift DC levels Transfer characteristics: Input-output relationships Zener clippers: Precision voltage limiting","use-in-the-course#Use in the Course":"Analyze nonlinear electronic circuits using simplified models Understand forward/reverse bias behavior and switching characteristics Design voltage regulation and wave-shaping circuits","use-in-the-course-1#Use in the Course":"Graphical method for solving nonlinear circuits Determine operating points (Q-points) for amplifiers Analyze stability and signal swing limitations","use-in-the-course-2#Use in the Course":"Design and analyze transistor amplifier circuits Separate DC bias analysis from AC small-signal analysis Calculate gain, input/output impedance","use-in-the-course-3#Use in the Course":"Convert AC to DC power Design power supply circuits Analyze ripple and filtering","use-in-the-course-4#Use in the Course":"Design clipper and clamper circuits Shape waveforms for signal processing Implement voltage limiting and level shifting","v-wave-shaping-circuits#V. Wave-Shaping Circuits":"","zener-diode-model#Zener Diode Model":"{VD=VZ,ID\u003c0 and ∣VD∣≥VZID=0,∣VD∣\u003cVZ \\begin{cases} V_D = V_Z, \u0026 I_D \u003c 0 \\text{ and } |V_D| \\geq V_Z \\\\ I_D = 0, \u0026 |V_D| \u003c V_Z \\end{cases} {VD​=VZ​,ID​=0,​ID​\u003c0 and ∣VD​∣≥VZ​∣VD​∣\u003cVZ​​"},"title":"Comprehensive Diode and Electronic Circuit Analysis Roadmap"},"/electrical_notes/ee_302/op_amp_chat/":{"data":{"1-voltage-constraint-virtual-short-circuit#1. Voltage Constraint (Virtual Short Circuit)":"Because the differential gain (AOLA_{OL}AOL​) is infinite, any tiny differential input voltage (vidv_{id}vid​) would drive the output to saturation unless vidv_{id}vid​ is forced to zero. vinverting=vnoninvertingv_{inverting} = v_{noninverting}vinverting​=vnoninverting​Virtual Ground: If the noninverting terminal is grounded, the inverting terminal is considered a “virtual ground” (i.e., at 0 V). This is called “virtual” because the node is at 0V potential but cannot sink or source current.","2-current-constraint-virtual-open-circuit#2. Current Constraint (Virtual Open Circuit)":"Since the input impedance (RinR_{in}Rin​) is infinite, no current flows into the input terminals. iinverting=0andinoninverting=0i_{inverting} = 0 \\quad \\text{and} \\quad i_{noninverting} = 0iinverting​=0andinoninverting​=0","a-introduction-to-operational-amplifiers#A. Introduction to Operational Amplifiers":"An operational amplifier (op-amp) is fundamentally a differential amplifier designed as an integrated circuit (IC). They originated historically in analog computing circuits to perform mathematical functions like addition, subtraction, integration, and differentiation—hence the name.","a-offset-voltage-compensation#A. Offset Voltage Compensation":"Real op-amps have input offset voltage that can cause DC errors. To compensate:\nMethod 1: Balancing Resistors\nAdd a resistor R3=R1∥R2R_3 = R_1 \\parallel R_2R3​=R1​∥R2​ at the noninverting input to balance bias current effects.\nMethod 2: Offset Nulling\nMany op-amps have offset null pins. Connect a potentiometer between these pins to manually adjust the offset to zero.","a-the-summing-point-constraint-ideal-assumption#A. The Summing-Point Constraint (Ideal Assumption)":"When analyzing an ideal op-amp circuit with negative feedback, we apply the summing-point constraint. This constraint simplifies the circuit model greatly by replacing the infinite gain property with two simple conditions:","appendix-important-parameters-and-typical-values#Appendix: Important Parameters and Typical Values":"","b-characteristics-of-an-ideal-operational-amplifier#B. Characteristics of an Ideal Operational Amplifier":"To simplify analysis, op-amps are often modeled as ideal operational amplifiers. An ideal op amp has the following key characteristics:\nCharacteristic Ideal Value Implication for Analysis Input Impedance (RinR_{in}Rin​) Infinite (∞\\infty∞) Input currents (i+i_+i+​ and i−i_-i−​) are zero. Differential Voltage Gain (AOLA_{OL}AOL​) Infinite (∞\\infty∞) In negative feedback, the differential input voltage (vidv_{id}vid​) is forced to zero. Common-Mode Voltage Gain Zero The amplifier perfectly rejects common-mode noise. Output Impedance (RoutR_{out}Rout​) Zero (0) The output voltage is independent of the load resistance. Bandwidth Infinite Supports all frequencies without gain reduction. Slew Rate (SR) Infinite Instantaneous change in output voltage is possible. Output Offset Voltage Zero Zero output voltage when the input voltages are zero. Key Takeaway: The two most important ideal characteristics for circuit analysis are:\nNo current flows into the input terminals (i+=i−=0i_+ = i_- = 0i+​=i−​=0) No voltage difference exists between the input terminals when negative feedback is present (v+=v−v_+ = v_-v+​=v−​)","b-frequency-response-and-stability#B. Frequency Response and Stability":"Open-Loop Gain vs Frequency:\nReal op-amps have frequency-dependent gain: A(f)=A01+j(f/f0)A(f) = \\frac{A_0}{1 + j(f/f_0)}A(f)=1+j(f/f0​)A0​​where A0A_0A0​ is DC gain and f0f_0f0​ is the break frequency.\nClosed-Loop Bandwidth:\nThe bandwidth of a feedback circuit is: fCL=ftACLf_{CL} = \\frac{f_t}{A_{CL}}fCL​=ACL​ft​​where ftf_tft​ is the gain-bandwidth product and ACLA_{CL}ACL​ is the closed-loop gain.\nStability Considerations:\nPhase margin should be \u003e 45° for stability Excessive capacitive loading can cause oscillation Compensation capacitors may be needed for unity-gain stable operation","b-step-by-step-procedure-for-solving-ideal-op-amp-circuits#B. Step-by-Step Procedure for Solving Ideal Op-Amp Circuits":"Given the prerequisites (understanding of KCL, KVL, and Ohm’s Law), solving op-amp circuits involves three systematic steps:","basic-op-amp-symbol-and-terminals#Basic Op-Amp Symbol and Terminals":"+Vcc (Positive Supply) | v₁ -----|\\ | \\ | \\______ vₒ (Output) | / v₂ -----|/ | -Vee (Negative Supply) v₁ = Noninverting input (+) v₂ = Inverting input (-) The op-amp amplifies the difference between its two input signals. It typically uses dual power supplies (VCCV_{CC}VCC​ and VEEV_{EE}VEE​), often ±15 V\\pm 15\\,\\text{V}±15V, though these connections are frequently omitted from circuit diagrams for simplicity.","c-characteristics-of-real-operational-amplifiers-imperfections#C. Characteristics of Real Operational Amplifiers (Imperfections)":"While the ideal model is used for design and basic circuit analysis, real op amps exhibit several limitations, especially in the linear range and under large-signal/high-frequency conditions.","c-input-and-output-current-limits#C. Input and Output Current Limits":"Maximum Output Current:\nMost op-amps can source/sink 20-40 mA. For higher currents:\nUse a current booster stage (push-pull buffer) Select power op-amps rated for higher output current Input Current:\nBias currents flow through source impedances, creating offset voltages Use matched source impedances or FET-input op-amps to minimize effects","common-op-amp-specifications-lm741-example#Common Op-Amp Specifications (LM741 Example)":"Parameter Typical Value Units Open-loop gain (AOLA_{OL}AOL​) 200,000 V/V Input offset voltage (VosV_{os}Vos​) 1-5 mV Input bias current (IBI_BIB​) 80 nA Input offset current (IosI_{os}Ios​) 20 nA Slew rate (SR) 0.5 V/μ\\muμs Gain-bandwidth product 1 MHz Input impedance 2 MΩ\\OmegaΩ Output impedance 75 Ω\\OmegaΩ Common-mode rejection ratio (CMRR) 90 dB","comprehensive-operational-amplifier-circuit-documentation#Comprehensive Operational Amplifier Circuit Documentation":"Comprehensive Operational Amplifier Circuit DocumentationThis documentation provides a complete understanding of operational amplifier (op-amp) circuits, assuming foundational knowledge of basic circuit analysis techniques such as Ohm’s Law, Kirchhoff’s Current Law (KCL), and Kirchhoff’s Voltage Law (KVL), along with familiarity with nonlinear circuit elements like diodes, clippers, and clamps.","conclusion#Conclusion":"Mastering op-amp circuits requires understanding both ideal behavior (for design) and real-world limitations (for implementation). The summing-point constraint simplifies analysis dramatically, reducing complex amplifier circuits to straightforward KCL/KVL problems. Always verify negative feedback, apply the two golden rules (zero input current, equal input voltages), and systematically work through the circuit using basic circuit analysis principles.","d-common-op-amp-applications#D. Common Op-Amp Applications":"Active Filters:\nLow-pass, high-pass, band-pass, and notch filters Sallen-Key and Multiple Feedback topologies Instrumentation Amplifier:\nThree op-amp configuration Very high input impedance Excellent common-mode rejection ratio (CMRR) Comparators:\nOperates without feedback (open-loop) Output saturates to positive or negative rail Used for level detection and waveform generation Oscillators:\nWien bridge oscillator Phase-shift oscillator Requires positive feedback Precision Rectifiers:\nOvercomes diode voltage drop Half-wave and full-wave configurations","dc-imperfections-offsets#DC Imperfections (Offsets)":"These factors introduce an undesirable DC voltage component added to the intended output signal.\nInput Bias Current (IBI_BIB​): DC current that flows into (or from) the input terminals. Typically in the nA to μA\\mu\\text{A}μA range. IB=IB++IB−2I_B = \\frac{I_{B+} + I_{B-}}{2}IB​=2IB+​+IB−​​ Input Offset Current (IoffI_{off}Ioff​): The difference between the two bias currents: Ioff=IB+−IB−I_{off} = I_{B+} - I_{B-}Ioff​=IB+​−IB−​ Input Offset Voltage (VoffV_{off}Voff​): A small DC source (typically 1-5 mV) in series with one input terminal that models why the output is non-zero even when inputs are grounded.","e-common-mistakes-and-troubleshooting#E. Common Mistakes and Troubleshooting":"Common Errors:\nForgetting to check for negative feedback before applying summing-point constraint Sign errors in KCL equations due to incorrect current direction assumptions Ignoring saturation limits when calculating theoretical outputs Assuming infinite bandwidth for high-frequency applications Not accounting for input bias currents in high-impedance circuits Troubleshooting Checklist:\nVerify power supply connections and voltages Check for correct feedback topology (negative vs. positive) Measure DC offset at output with inputs grounded Verify component values and connections Check for oscillation with an oscilloscope Ensure output isn’t being asked to exceed current limits","example-1-the-basic-inverting-amplifier#Example 1: The Basic Inverting Amplifier":"R₁ R₂ vᵢₙ ----/\\/\\/----+----/\\/\\/---- vₒ | | (-)|\\ | | \\ | 0V --|+) \u003e-------+ | / |/ The inverting amplifier configuration applies the input signal (vinv_{in}vin​) to the inverting terminal through resistor R1R_1R1​, while the noninverting terminal is grounded. Negative feedback is applied through resistor R2R_2R2​ connecting the output (vov_ovo​) back to the inverting input.\nAnalysis using Summing-Point Constraint and KCL:\nSet Constraints:\nThe noninverting terminal is grounded: vnoninverting=0 Vv_{noninverting} = 0\\,\\text{V}vnoninverting​=0V By Constraint 1: vinverting=vnoninverting=0 Vv_{inverting} = v_{noninverting} = 0\\,\\text{V}vinverting​=vnoninverting​=0V (virtual ground) By Constraint 2: iop−amp=0i_{op-amp} = 0iop−amp​=0 Apply KCL at the Inverting Node (vinvertingv_{inverting}vinverting​): The current from the input (i1i_1i1​) must flow through the feedback path (i2i_2i2​), as no current enters the op amp terminal. i1=i2i_1 = i_2i1​=i2​ Apply Ohm’s Law to define currents:\nInput Current (i1i_1i1​): Flows from vinv_{in}vin​ to the virtual ground (0 V0\\,\\text{V}0V) i1=vin−0R1=vinR1i_1 = \\frac{v_{in} - 0}{R_1} = \\frac{v_{in}}{R_1}i1​=R1​vin​−0​=R1​vin​​ Feedback Current (i2i_2i2​): Flows from the virtual ground (0 V0\\,\\text{V}0V) to the output (vov_ovo​) i2=0−voR2=−voR2i_2 = \\frac{0 - v_o}{R_2} = - \\frac{v_o}{R_2}i2​=R2​0−vo​​=−R2​vo​​ Solve for Gain (Av=vo/vinA_v = v_o/v_{in}Av​=vo​/vin​): Substitute current expressions into the KCL equation (i1=i2i_1 = i_2i1​=i2​): vinR1=−voR2\\frac{v_{in}}{R_1} = - \\frac{v_o}{R_2}R1​vin​​=−R2​vo​​ vovin=−R2R1\\frac{v_o}{v_{in}} = - \\frac{R_2}{R_1}vin​vo​​=−R1​R2​​ Resulting Characteristics:\nClosed-Loop Voltage Gain: Av=−R2R1A_v = -\\frac{R_2}{R_1}Av​=−R1​R2​​ Phase: Inverting (negative sign indicates 180∘180^\\circ180∘ phase shift) Input Impedance: Rin=R1R_{in} = R_1Rin​=R1​ (since the inverting node is at virtual ground) Output Impedance (Ideal): Rout=0R_{out} = 0Rout​=0","example-2-the-basic-noninverting-amplifier#Example 2: The Basic Noninverting Amplifier":"R₂ +----/\\/\\/----+ | | vᵢₙ ---|+)|\\ | | \\ | +-|-) \u003e------+---- vₒ | | / | |/ | +----/\\/\\/---- 0V R₁ The noninverting amplifier applies the input signal (vinv_{in}vin​) directly to the noninverting terminal. The feedback is a voltage divider composed of R1R_1R1​ (to ground) and R2R_2R2​ (from output to inverting terminal).\nAnalysis using Summing-Point Constraint and Voltage Division:\nSet Constraints:\nThe noninverting terminal voltage is vinv_{in}vin​ By Constraint 1: vinverting=vnoninverting=vinv_{inverting} = v_{noninverting} = v_{in}vinverting​=vnoninverting​=vin​ By Constraint 2: The current flowing into the inverting node (iii_iii​) is zero Apply Voltage Division to the Feedback Network: Because ii=0i_i = 0ii​=0, the voltage divider formed by R1R_1R1​ and R2R_2R2​ is isolated. The voltage across R1R_1R1​ is vinvertingv_{inverting}vinverting​ (which is constrained to be vinv_{in}vin​). We apply the voltage division principle: vin=vinverting=vo(R1R1+R2)v_{in} = v_{inverting} = v_{o} \\left( \\frac{R_1}{R_1 + R_2} \\right)vin​=vinverting​=vo​(R1​+R2​R1​​) Solve for Gain (Av=vo/vinA_v = v_o/v_{in}Av​=vo​/vin​): Rearranging the equation yields the closed-loop gain: vovin=R1+R2R1=1+R2R1\\frac{v_o}{v_{in}} = \\frac{R_1 + R_2}{R_1} = 1 + \\frac{R_2}{R_1}vin​vo​​=R1​R1​+R2​​=1+R1​R2​​ Resulting Characteristics:\nClosed-Loop Voltage Gain: Av=1+R2R1A_v = 1 + \\frac{R_2}{R_1}Av​=1+R1​R2​​ Phase: Noninverting (positive gain, no phase shift) Input Impedance (Ideal): Rin=∞R_{in} = \\inftyRin​=∞ (because the input current is zero) Output Impedance (Ideal): Rout=0R_{out} = 0Rout​=0 Note: For the special case where R2=0R_2 = 0R2​=0 and R1=∞R_1 = \\inftyR1​=∞ (or removed), the gain becomes 1, creating a voltage follower or buffer (Av=1A_v = 1Av​=1).","example-3-the-voltage-follower-unity-gain-buffer#Example 3: The Voltage Follower (Unity-Gain Buffer)":"vᵢₙ ---|+)|\\ | \\ +--|-) \u003e---- vₒ | | / | |/ | +--------+ Analysis:\nv−=v+=vinv_- = v_+ = v_{in}v−​=v+​=vin​ Output is directly connected to inverting input: vo=v−v_o = v_-vo​=v−​ Therefore: vo=vinv_o = v_{in}vo​=vin​ Resulting Characteristics:\nVoltage Gain: Av=1A_v = 1Av​=1 Input Impedance: Rin=∞R_{in} = \\inftyRin​=∞ (ideal) Output Impedance: Rout=0R_{out} = 0Rout​=0 (ideal) Application: Impedance matching, buffering signals without loading the source","example-4-the-summing-amplifier#Example 4: The Summing Amplifier":"Rₐ vₐ ----/\\/\\/----+ | Rf Rᵦ |----/\\/\\/---- vₒ vᵦ ----/\\/\\/----+ | | | (-)|\\ | | \\ | 0V --|+) \u003e-------+ | / |/ A summing amplifier is a variation of the inverting amplifier used to combine multiple input signals, vAv_AvA​ and vBv_BvB​, each fed through its own resistor (RAR_ARA​ and RBR_BRB​) to the inverting input node.\nAnalysis using Summing-Point Constraint and KCL:\nSet Constraints: vinverting=0 Vv_{inverting} = 0\\,\\text{V}vinverting​=0V and iop−amp=0i_{op-amp} = 0iop−amp​=0\nApply KCL at the Inverting Node (Summing Point): The sum of input currents (iA+iBi_A + i_BiA​+iB​) must flow through the feedback path (ifi_fif​), since iop−amp=0i_{op-amp} = 0iop−amp​=0. iA+iB=ifi_A + i_B = i_fiA​+iB​=if​ Apply Ohm’s Law: iA=vARA,iB=vBRB,if=0−voRf=−voRfi_A = \\frac{v_A}{R_A}, \\quad i_B = \\frac{v_B}{R_B}, \\quad i_f = \\frac{0 - v_o}{R_f} = - \\frac{v_o}{R_f}iA​=RA​vA​​,iB​=RB​vB​​,if​=Rf​0−vo​​=−Rf​vo​​ Solve for vov_ovo​: vARA+vBRB=−voRf\\frac{v_A}{R_A} + \\frac{v_B}{R_B} = - \\frac{v_o}{R_f}RA​vA​​+RB​vB​​=−Rf​vo​​ vo=−(RfRAvA+RfRBvB)v_o = - \\left( \\frac{R_f}{R_A} v_A + \\frac{R_f}{R_B} v_B \\right)vo​=−(RA​Rf​​vA​+RB​Rf​​vB​) General Form (n inputs): vo=−(RfR1v1+RfR2v2+⋯+RfRnvn)v_o = - \\left( \\frac{R_f}{R_1} v_1 + \\frac{R_f}{R_2} v_2 + \\cdots + \\frac{R_f}{R_n} v_n \\right)vo​=−(R1​Rf​​v1​+R2​Rf​​v2​+⋯+Rn​Rf​​vn​)This configuration acts as a linear weighted summer or adder.","example-5-the-difference-amplifier-subtractor#Example 5: The Difference Amplifier (Subtractor)":"R₁ R₂ v₁ ----/\\/\\/----+----/\\/\\/---- vₒ | | (-)|\\ | | \\ | +---|+) \u003e-------+ | | / R₃ | |/ v₂ ---/\\/\\/--+ | +----/\\/\\/---- 0V R₄ The difference amplifier outputs a voltage proportional to the difference between two input voltages.\nAnalysis:\nFind v+v_+v+​ using voltage division: v+=v2(R4R3+R4)v_+ = v_2 \\left( \\frac{R_4}{R_3 + R_4} \\right)v+​=v2​(R3​+R4​R4​​) Apply constraint: v−=v+v_- = v_+v−​=v+​\nApply KCL at inverting node: v1−v−R1=v−−voR2\\frac{v_1 - v_-}{R_1} = \\frac{v_- - v_o}{R_2}R1​v1​−v−​​=R2​v−​−vo​​ Substitute and solve: vo=v2(R4R3+R4)(1+R2R1)−v1(R2R1)v_o = v_2 \\left( \\frac{R_4}{R_3 + R_4} \\right) \\left( 1 + \\frac{R_2}{R_1} \\right) - v_1 \\left( \\frac{R_2}{R_1} \\right)vo​=v2​(R3​+R4​R4​​)(1+R1​R2​​)−v1​(R1​R2​​) Special Case: If R1=R3R_1 = R_3R1​=R3​ and R2=R4R_2 = R_4R2​=R4​: vo=R2R1(v2−v1)v_o = \\frac{R_2}{R_1} (v_2 - v_1)vo​=R1​R2​​(v2​−v1​)Resulting Characteristics:\nAmplifies the difference between two signals Provides common-mode rejection Used in instrumentation and measurement applications","example-6-the-integrator#Example 6: The Integrator":"R C vᵢₙ ----/\\/\\/----+----||---- vₒ | | (-)|\\ | | \\ | 0V --|+) \u003e-----+ | / |/ The integrator replaces the feedback resistor with a capacitor.\nAnalysis:\nVirtual ground: v−=0 Vv_- = 0\\,\\text{V}v−​=0V\nCurrent through R: iR=vinRi_R = \\frac{v_{in}}{R}iR​=Rvin​​ Current through C: Same as iRi_RiR​ (no current into op-amp) iC=CdvCdt=Cd(0−vo)dt=−Cdvodti_C = C \\frac{dv_C}{dt} = C \\frac{d(0 - v_o)}{dt} = -C \\frac{dv_o}{dt}iC​=CdtdvC​​=Cdtd(0−vo​)​=−Cdtdvo​​ Equate currents: vinR=−Cdvodt\\frac{v_{in}}{R} = -C \\frac{dv_o}{dt}Rvin​​=−Cdtdvo​​ Solve for vov_ovo​: vo=−1RC∫vin dtv_o = -\\frac{1}{RC} \\int v_{in} \\, dtvo​=−RC1​∫vin​dt Resulting Characteristics:\nOutput is the negative integral of the input Time constant: τ=RC\\tau = RCτ=RC For DC input: vo=−VinRCtv_o = -\\frac{V_{in}}{RC} tvo​=−RCVin​​t (ramp output) Phase shift: −90∘-90^\\circ−90∘ for sinusoidal inputs","example-7-the-differentiator#Example 7: The Differentiator":"C R vᵢₙ ----||-------+----/\\/\\/---- vₒ | | (-)|\\ | | \\ | 0V --|+) \u003e-------+ | / |/ The differentiator uses a capacitor at the input and resistor in feedback.\nAnalysis:\nVirtual ground: v−=0 Vv_- = 0\\,\\text{V}v−​=0V\nCurrent through C: iC=Cd(vin−0)dt=Cdvindti_C = C \\frac{d(v_{in} - 0)}{dt} = C \\frac{dv_{in}}{dt}iC​=Cdtd(vin​−0)​=Cdtdvin​​ Current through R: Same as iCi_CiC​ iR=0−voR=−voRi_R = \\frac{0 - v_o}{R} = -\\frac{v_o}{R}iR​=R0−vo​​=−Rvo​​ Equate currents: Cdvindt=−voRC \\frac{dv_{in}}{dt} = -\\frac{v_o}{R}Cdtdvin​​=−Rvo​​ Solve for vov_ovo​: vo=−RCdvindtv_o = -RC \\frac{dv_{in}}{dt}vo​=−RCdtdvin​​ Resulting Characteristics:\nOutput is the negative derivative of the input Time constant: τ=RC\\tau = RCτ=RC Phase shift: +90∘+90^\\circ+90∘ for sinusoidal inputs Caution: Sensitive to high-frequency noise; often requires input filtering","formula-quick-reference#Formula Quick Reference":"Configuration Voltage Gain Input Impedance Notes Inverting −R2R1-\\frac{R_2}{R_1}−R1​R2​​ R1R_1R1​ 180∘180^\\circ180∘ phase shift Noninverting 1+R2R11 + \\frac{R_2}{R_1}1+R1​R2​​ ∞\\infty∞ No phase shift Voltage Follower 111 ∞\\infty∞ Buffer Summing −∑RfRivi-\\sum \\frac{R_f}{R_i}v_i−∑Ri​Rf​​vi​ Depends on input Weighted sum Difference R2R1(v2−v1)\\frac{R_2}{R_1}(v_2 - v_1)R1​R2​​(v2​−v1​) Varies For matched resistors Integrator −1RC∫vindt-\\frac{1}{RC}\\int v_{in} dt−RC1​∫vin​dt RRR −90∘-90^\\circ−90∘ phase shift Differentiator −RCdvindt-RC\\frac{dv_{in}}{dt}−RCdtdvin​​ Varies +90∘+90^\\circ+90∘ phase shift","input-signal-components#Input Signal Components":"The two input voltages (v1v_1v1​ and v2v_2v2​) can be decomposed into two components:\nDifferential Signal (vidv_{id}vid​): The difference between the inputs: vid=v1−v2v_{id} = v_1 - v_2vid​=v1​−v2​ Common-Mode Signal (vicmv_{icm}vicm​): The average of the inputs: vicm=12(v1+v2)v_{icm} = \\frac{1}{2}(v_1 + v_2)vicm​=21​(v1​+v2​) The output voltage (vov_ovo​) is proportional to the differential signal multiplied by the open-loop gain (AOLA_{OL}AOL​): vo=AOL(v1−v2)v_o = A_{OL}(v_1 - v_2)vo​=AOL​(v1​−v2​)","linear-range-imperfections#Linear Range Imperfections":"Finite Open-Loop Gain (A0OLA_{0OL}A0OL​): Real gain is large but finite (typically 10410^4104 to 10610^6106).\nFinite Bandwidth: The gain magnitude reduces at higher frequencies. The product of DC gain and bandwidth is constant (ft=A0OLfBOLf_t = A_{0OL} f_{BOL}ft​=A0OL​fBOL​), known as the unity-gain–bandwidth or gain-bandwidth product (GBW).\nFinite Input Impedance (typically 1−10 MΩ1-10\\,\\text{M}\\Omega1−10MΩ) and Nonzero Output Impedance (typically 50−100 Ω50-100\\,\\Omega50−100Ω).","nonlinear-limitations#Nonlinear Limitations":"Output Voltage Swing: The output voltage is strictly limited by the power supply voltages, leading to clipping if the ideal output exceeds these limits (e.g., typically ±14 V\\pm 14\\,\\text{V}±14V for ±15 V\\pm 15\\,\\text{V}±15V supplies). Vout,min≤vo≤Vout,maxV_{out,min} \\leq v_o \\leq V_{out,max}Vout,min​≤vo​≤Vout,max​ Slew-Rate (SR) Limitation: The maximum rate of change of the output voltage is finite (e.g., 0.5 V/μs0.5\\,\\text{V}/\\mu\\text{s}0.5V/μs for the LM741). SR=∣dvodt∣maxSR = \\left|\\frac{dv_o}{dt}\\right|_{max}SR=​dtdvo​​​max​ If the required rate of output change is 2πfVom2\\pi f V_{om}2πfVom​ (for a sine wave) and this exceeds SR, the output will distort, often becoming a triangular wave.\nThe Full-Power Bandwidth (fFPf_{FP}fFP​) is the highest frequency at which the op amp can produce a full-amplitude sinusoidal output without distortion due to slew-rate limiting: fFP=SR2πVomf_{FP} = \\frac{SR}{2\\pi V_{om}}fFP​=2πVom​SR​","part-i-operational-amplifier-circuit-theory-and-characteristics#Part I: Operational Amplifier Circuit Theory and Characteristics":"","part-ii-methodologies-for-solving-op-amp-problems#Part II: Methodologies for Solving Op-Amp Problems":"Op-amps are highly stable and predictable when configured with negative feedback, where a portion of the output signal is fed back to the inverting terminal to oppose the source signal. This configuration forces the op amp to operate in its linear region, allowing for straightforward analysis.","part-iii-standard-op-amp-circuit-configurations#Part III: Standard Op-Amp Circuit Configurations":"","part-iv-advanced-topics-and-practical-considerations#Part IV: Advanced Topics and Practical Considerations":"","part-v-problem-solving-strategy-summary#Part V: Problem-Solving Strategy Summary":"","power-supply-considerations#Power Supply Considerations":"Standard dual supplies: ±15 V\\pm 15\\,\\text{V}±15V, ±12 V\\pm 12\\,\\text{V}±12V, ±5 V\\pm 5\\,\\text{V}±5V Single supply operation possible (e.g., 0V to +5V) Rail-to-rail op-amps can swing output closer to supply rails Quiescent current typically 1-3 mA","quick-reference-analysis-steps#Quick Reference: Analysis Steps":"Identify the configuration (inverting, noninverting, summing, etc.) Verify negative feedback exists (connection to inverting input) Apply summing-point constraint: v+=v−v_+ = v_-v+​=v−​ i+=i−=0i_+ = i_- = 0i+​=i−​=0 Write KCL at the summing node (usually the inverting input) Express currents using Ohm’s Law and known node voltages Solve algebraically for the desired output Check for reasonableness (gain, phase, saturation limits)","step-1-verify-negative-feedback#Step 1: Verify Negative Feedback":"Check that part of the output signal is returned to the inverting input terminal. If positive feedback is present (output returned to the noninverting terminal), the circuit will typically saturate, and the summing-point constraint cannot be used.","step-2-apply-the-summing-point-constraint#Step 2: Apply the Summing-Point Constraint":"Set the differential input voltage and input currents to zero based on the ideal op-amp properties derived above.","step-3-apply-standard-circuit-analysis-principles#Step 3: Apply Standard Circuit Analysis Principles":"Use KCL, KVL, and Ohm’s Law to solve for the currents and voltages of interest.\nFocus on KCL/KVL Setup (Step 3 Details):\nNodal Analysis (KCL) is Primary: Due to the zero-current constraint, KCL applied at the inverting input node (vinvertingv_{inverting}vinverting​) is often the fastest method. The current entering the node must equal the current leaving the node (and the current into the op amp is zero). Example (Inverting node): If currents i1i_1i1​ and ifi_fif​ enter the inverting node and current iop−ampi_{op-amp}iop−amp​ flows into the op-amp input: i1+if=iop−ampi_1 + i_f = i_{op-amp}i1​+if​=iop−amp​. Since iop−amp=0i_{op-amp} = 0iop−amp​=0, we have i1+if=0i_1 + i_f = 0i1​+if​=0, or i1=−ifi_1 = -i_fi1​=−if​.\nOhm’s Law Application: Currents are calculated across the external resistors by applying Ohm’s Law (i=v/Ri = v/Ri=v/R), using the node voltages established by the constraints. Example (Current through resistor R connecting vAv_AvA​ to vinvertingv_{inverting}vinverting​): i=vA−vinvertingRi = \\frac{v_A - v_{inverting}}{R}i=RvA​−vinverting​​ Loop Analysis (KVL) for Output: KVL may be necessary to define the output voltage (vov_ovo​) based on the voltage drop across the feedback elements, although nodal analysis usually yields vov_ovo​ directly."},"title":"op_amp_chat"},"/electrical_notes/ee_302/op_amp_chat2/":{"data":{"1-introduction-to-operational-amplifiers#1. Introduction to Operational Amplifiers":"","10-problem-solving-guide#10. Problem-Solving Guide":"","101-quick-analysis-strategy#10.1 Quick Analysis Strategy":"For ANY op-amp circuit:\nIdentify configuration (inverting, noninverting, summing, etc.) Check for negative feedback (required for linear operation) Apply summing-point constraint: v+=v−v_+ = v_-v+​=v−​ i+=0i_+ = 0i+​=0, i−=0i_- = 0i−​=0 Write KCL at summing node (usually inverting input) Apply Ohm’s Law to express currents Solve algebraically for desired quantity Verify result (check sign, magnitude, saturation limits)","102-common-problem-types#10.2 Common Problem Types":"","103-troubleshooting-checklist#10.3 Troubleshooting Checklist":"If circuit doesn’t work as expected:\nVerify power supply connections and voltages Check for negative feedback (correct topology) Verify all component values and connections Check for output saturation (measure with DMM) Look for oscillation (check with oscilloscope) Verify input signal amplitude and frequency Check for excessive output loading Measure DC offset at output with inputs grounded Verify op-amp not damaged (swap with known good unit) Check ground connections and ground loops","104-common-mistakes-to-avoid#10.4 Common Mistakes to Avoid":"Conceptual Errors:\n❌ Applying summing-point constraint to positive feedback circuits ❌ Assuming current flows into op-amp inputs ❌ Forgetting negative sign in inverting amplifier gain ❌ Confusing voltage gain with power gain Calculation Errors:\n❌ Wrong sign in KCL equation (current directions) ❌ Incorrect voltage difference in Ohm’s Law (v1−v2v_1 - v_2v1​−v2​ vs. v2−v1v_2 - v_1v2​−v1​) ❌ Forgetting to include “1+” in noninverting gain formula ❌ Using voltage divider formula when currents aren’t zero Design Errors:\n❌ Choosing resistor values too high (\u003e1MΩ) or too low (\u003c1kΩ) ❌ Ignoring frequency limitations (bandwidth, slew rate) ❌ Not checking for output saturation ❌ Forgetting decoupling capacitors on power supplies Practical Errors:\n❌ No ground connection or poor grounding ❌ Breadboard parasitics causing oscillation ❌ Excessive capacitive loading on output ❌ Wrong pin connections (consult datasheet)","11-quick-reference-tables#11. Quick Reference Tables":"","11-what-is-an-operational-amplifier#1.1 What is an Operational Amplifier?":"","111-configuration-summary#11.1 Configuration Summary":"Configuration Gain Formula Input Z Phase Min Gain Inverting −R2R1-\\frac{R_2}{R_1}−R1​R2​​ R1R_1R1​ 180° \u003c1 Noninverting 1+R2R11 + \\frac{R_2}{R_1}1+R1​R2​​ ∞ 0° 1 Voltage Follower 111 ∞ 0° 1 Summing −∑RfRivi-\\sum\\frac{R_f}{R_i}v_i−∑Ri​Rf​​vi​ Varies 180° — Difference R2R1(v2−v1)\\frac{R_2}{R_1}(v_2-v_1)R1​R2​​(v2​−v1​) Varies 0° or 180° — Integrator −1RC∫vindt-\\frac{1}{RC}\\int v_{in}dt−RC1​∫vin​dt RRR -90° — Differentiator −RCdvindt-RC\\frac{dv_{in}}{dt}−RCdtdvin​​ Varies +90° —","112-standard-op-amp-specifications-lm741-example#11.2 Standard Op-Amp Specifications (LM741 Example)":"Parameter Symbol Typical Value Units Open-loop gain AOLA_{OL}AOL​ 200,000 (106 dB) V/V Input offset voltage VosV_{os}Vos​ 1 mV Input bias current IBI_BIB​ 80 nA Input offset current IosI_{os}Ios​ 20 nA Input impedance ZinZ_{in}Zin​ 2 MΩ Output impedance ZoutZ_{out}Zout​ 75 Ω Slew rate SR 0.5 V/μs Gain-bandwidth product GBW 1 MHz CMRR — 90 dB Power supply voltage VCC,VEEV_{CC}, V_{EE}VCC​,VEE​ \\pm15 V Output voltage swing Vo(max)V_{o(max)}Vo(max)​ \\pm14 V Quiescent current IQI_QIQ​ 1.7 mA","113-typical-op-amp-families#11.3 Typical Op-Amp Families":"Type Input IBI_BIB​ VosV_{os}Vos​ SR GBW Application LM741 BJT 80 nA 1 mV 0.5 V/μs 1 MHz General purpose TL071 JFET 65 pA 3 mV 13 V/μs 3 MHz Low noise audio LM358 BJT 45 nA 2 mV 0.3 V/μs 1 MHz Single supply LF411 JFET 50 pA 0.5 mV 15 V/μs 4 MHz High speed OP07 BJT 4 nA 25 μV 0.3 V/μs 0.6 MHz Precision AD8065 BJT 2 μA 2 mV 180 V/μs 145 MHz High speed OPA627 BJT 1 nA 100 μV 55 V/μs 16 MHz Audio/precision","114-resistor-selection-guidelines#11.4 Resistor Selection Guidelines":"Application Recommended Range Reason Input resistors 1kΩ - 100kΩ Balance between noise and bias current effects Feedback resistors 1kΩ - 1MΩ Avoid excessive offset from bias current Summing networks 10kΩ - 100kΩ Standard range for most applications High impedance inputs \u003e100kΩ Use FET-input op-amps Low noise \u003c10kΩ Minimize thermal noise DC applications Equal source impedances Minimize offset from bias currents","115-capacitor-selection-guidelines#11.5 Capacitor Selection Guidelines":"Application Type Value Range Notes Integrator Film, ceramic 10 nF - 10 μF Low leakage, stable Differentiator Film, ceramic 100 pF - 1 nF Small values, add series R AC coupling Electrolytic, film 1 μF - 100 μF Consider polarity Power supply decoupling Ceramic 0.1 μF Close to IC pins Power supply bulk Electrolytic 10 μF - 100 μF At power entry Compensation Ceramic 10 pF - 100 pF High-speed op-amps","116-important-formulas-quick-reference#11.6 Important Formulas Quick Reference":"Gain Conversions:\nVoltage gain to dB: AdB=20log⁡10∣Av∣A_{dB} = 20\\log_{10}|A_v|AdB​=20log10​∣Av​∣ dB to voltage gain: ∣Av∣=10AdB/20|A_v| = 10^{A_{dB}/20}∣Av​∣=10AdB​/20 Frequency Calculations:\nCutoff frequency (RC): fc=12πRCf_c = \\frac{1}{2\\pi RC}fc​=2πRC1​ Closed-loop bandwidth: fCL=ftACLf_{CL} = \\frac{f_t}{A_{CL}}fCL​=ACL​ft​​ Full-power bandwidth: fFP=SR2πVomf_{FP} = \\frac{SR}{2\\pi V_{om}}fFP​=2πVom​SR​ Time Constants:\nRC time constant: τ=RC\\tau = RCτ=RC 5τ rule: Circuit settles to 99.3% in 5τ Power and Energy:\nPower dissipation: P=V2R=I2R=VIP = \\frac{V^2}{R} = I^2R = VIP=RV2​=I2R=VI Energy in capacitor: E=12CV2E = \\frac{1}{2}CV^2E=21​CV2","117-standard-resistor-values-e12-series#11.7 Standard Resistor Values (E12 Series)":"10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82 (and multiples)\nCommon ratios for gain:\nGain of 2: R2/R1=1R_2/R_1 = 1R2​/R1​=1 (10k/10k for noninverting) Gain of 5: R2/R1=4R_2/R_1 = 4R2​/R1​=4 (82k/22k = 3.73, close to 4) Gain of 10: R2/R1=9R_2/R_1 = 9R2​/R1​=9 (100k/11k \\approx 9) Gain of 11: R2/R1=10R_2/R_1 = 10R2​/R1​=10 (100k/10k)","118-decibel-reference-table#11.8 Decibel Reference Table":"Ratio dB Ratio dB 0.1 -20 10 +20 0.2 -14 5 +14 0.5 -6 2 +6 0.707 -3 1.41 +3 1.0 0 1.0 0","119-design-example-worksheet#11.9 Design Example Worksheet":"Problem: Design an inverting amplifier with gain of -5, input impedance of 10kΩ.\nSolution Steps:\nConfiguration: Inverting amplifier Input impedance = R1=10kΩR_1 = 10k\\OmegaR1​=10kΩ ✓ Gain formula: Av=−R2R1A_v = -\\frac{R_2}{R_1}Av​=−R1​R2​​ Required: −5=−R210k-5 = -\\frac{R_2}{10k}−5=−10kR2​​ Therefore: R2=50kΩR_2 = 50k\\OmegaR2​=50kΩ ✓ Check bandwidth: If ft=1MHzf_t = 1MHzft​=1MHz, then fCL=1MHz5=200kHzf_{CL} = \\frac{1MHz}{5} = 200kHzfCL​=51MHz​=200kHz ✓ Check saturation: For \\pm15V supplies, Vo,max=±14VV_{o,max} = \\pm 14VVo,max​=±14V, so Vin,max=14V5=2.8VV_{in,max} = \\frac{14V}{5} = 2.8VVin,max​=514V​=2.8V ✓ Final Design:\nR1=10kΩR_1 = 10k\\OmegaR1​=10kΩ R2=47kΩR_2 = 47k\\OmegaR2​=47kΩ or 50kΩ50k\\Omega50kΩ (use standard value) Av=−4.7A_v = -4.7Av​=−4.7 or −5.0-5.0−5.0","12-advanced-concepts-and-theory#12. Advanced Concepts and Theory":"","12-op-amp-symbol-and-terminals#1.2 Op-Amp Symbol and Terminals":"","121-loop-gain-and-feedback-theory#12.1 Loop Gain and Feedback Theory":"Loop gain (AβA\\betaAβ): T=AOL⋅βT = A_{OL} \\cdot \\betaT=AOL​⋅β\nWhere:\nAOLA_{OL}AOL​ = open-loop gain β\\betaβ = feedback factor Closed-loop gain: ACL=AOL1+AOLβA_{CL} = \\frac{A_{OL}}{1 + A_{OL}\\beta}ACL​=1+AOL​βAOL​​\nFor large loop gain (AOLβ\u003e\u003e1A_{OL}\\beta \u003e\u003e 1AOL​β\u003e\u003e1): ACL≈1βA_{CL} \\approx \\frac{1}{\\beta}ACL​≈β1​\nFeedback factor examples:\nInverting: β=−R1R1+R2\\beta = -\\frac{R_1}{R_1 + R_2}β=−R1​+R2​R1​​ Noninverting: β=R1R1+R2\\beta = \\frac{R_1}{R_1 + R_2}β=R1​+R2​R1​​","122-noise-analysis#12.2 Noise Analysis":"Input-referred noise: vn,total=vn,opamp2+vn,R12+vn,R22+⋯v_{n,total} = \\sqrt{v_{n,opamp}^2 + v_{n,R1}^2 + v_{n,R2}^2 + \\cdots}vn,total​=vn,opamp2​+vn,R12​+vn,R22​+⋯​\nThermal noise in resistor: vn=4kTRBv_n = \\sqrt{4kTRB}vn​=4kTRB​\nWhere:\nk=1.38×10−23k = 1.38 \\times 10^{-23}k=1.38×10−23 J/K (Boltzmann constant) TTT = temperature (K) RRR = resistance (Ω) BBB = bandwidth (Hz) Noise minimization:\nUse low-noise op-amps Minimize resistor values (where practical) Limit bandwidth to minimum required Use matched impedances","123-psrr-power-supply-rejection-ratio#12.3 PSRR (Power Supply Rejection Ratio)":"Measures ability to reject power supply variations:\nPSRR=20log⁡(ΔVsupplyΔVoffset)\\text{PSRR} = 20\\log\\left(\\frac{\\Delta V_{supply}}{\\Delta V_{offset}}\\right)PSRR=20log(ΔVoffset​ΔVsupply​​)\nTypical values: 80-120 dB\nImportance: High PSRR reduces output variations due to supply noise","124-input-common-mode-range#12.4 Input Common-Mode Range":"Maximum voltage range that can be applied to both inputs simultaneously while maintaining linear operation.\nTypical:\nStandard op-amps: VEE+2VV_{EE} + 2VVEE​+2V to VCC−2VV_{CC} - 2VVCC​−2V Rail-to-rail input: VEEV_{EE}VEE​ to VCCV_{CC}VCC​","125-output-current-limiting#12.5 Output Current Limiting":"Short-circuit current: Typically 20-40 mA for standard op-amps.\nFor higher current:\nAdd push-pull buffer stage Use power op-amps Add external pass transistors","13-basic-operating-principle#1.3 Basic Operating Principle":"","14-example-problems-with-solutions#14. Example Problems with Solutions":"","15-conclusion#15. Conclusion":"This comprehensive guide covers the fundamental theory, practical analysis methods, and real-world applications of operational amplifiers. Key takeaways:\nGolden Rules: v+=v−v_+ = v_-v+​=v−​ and i+=i−=0i_+ = i_- = 0i+​=i−​=0 (with negative feedback) Analysis Method: Apply summing-point constraint, then use KCL and Ohm’s Law Configuration Selection: Choose based on input impedance needs and phase requirements Real-World Limitations: Always check saturation, bandwidth, and slew rate Design Approach: Select configuration → choose resistors → verify performance Further Study:\nOp-amp datasheets and application notes Active filter design Precision analog design High-speed amplifier techniques Noise analysis and reduction Recommended References:\n“Op Amps for Everyone” (Texas Instruments) “The Art of Electronics” by Horowitz and Hill Manufacturer application notes (Analog Devices, Texas Instruments, Linear Technology) End of Comprehensive Op-Amp Reference Guide","2-ideal-vs-real-op-amp-characteristics#2. Ideal vs Real Op-Amp Characteristics":"","21-ideal-op-amp-properties#2.1 Ideal Op-Amp Properties":"","22-real-op-amp-imperfections#2.2 Real Op-Amp Imperfections":"","3-fundamental-op-amp-concepts#3. Fundamental Op-Amp Concepts":"","31-differential-and-common-mode-signals#3.1 Differential and Common-Mode Signals":"","32-common-mode-rejection-ratio-cmrr#3.2 Common-Mode Rejection Ratio (CMRR)":"","33-virtual-ground-and-virtual-short#3.3 Virtual Ground and Virtual Short":"","34-negative-vs-positive-feedback#3.4 Negative vs Positive Feedback":"","4-analysis-methodology#4. Analysis Methodology":"","41-the-summing-point-constraint-method#4.1 The Summing-Point Constraint Method":"","42-step-by-step-analysis-procedure#4.2 Step-by-Step Analysis Procedure":"","43-detailed-kcl-application#4.3 Detailed KCL Application":"","5-standard-op-amp-configurations#5. Standard Op-Amp Configurations":"","51-inverting-amplifier#5.1 Inverting Amplifier":"","52-noninverting-amplifier#5.2 Noninverting Amplifier":"","53-voltage-follower-buffer#5.3 Voltage Follower (Buffer)":"","54-summing-amplifier#5.4 Summing Amplifier":"","55-difference-amplifier-subtractor#5.5 Difference Amplifier (Subtractor)":"","56-integrator#5.6 Integrator":"","57-differentiator#5.7 Differentiator":"","6-understanding-gain#6. Understanding Gain":"","61-voltage-gain-fundamentals#6.1 Voltage Gain Fundamentals":"","62-complex-gain-frequency-dependent#6.2 Complex Gain (Frequency-Dependent)":"","63-gain-in-decibels-db#6.3 Gain in Decibels (dB)":"","64-open-loop-vs-closed-loop-gain#6.4 Open-Loop vs Closed-Loop Gain":"","65-gain-bandwidth-product-gbw#6.5 Gain-Bandwidth Product (GBW)":"The product of gain and bandwidth is constant:\nGBW=ACL×fBW=A0×f0=ft\\text{GBW} = A_{CL} \\times f_{BW} = A_0 \\times f_0 = f_tGBW=ACL​×fBW​=A0​×f0​=ft​Where:\nftf_tft​ = unity-gain frequency (frequency where ∣A∣=1|A| = 1∣A∣=1) A0A_0A0​ = DC open-loop gain f0f_0f0​ = open-loop bandwidth Practical Implication: Higher closed-loop gain → Lower bandwidth\nExample: If GBW = 1 MHz:\nGain of 1 → Bandwidth = 1 MHz Gain of 10 → Bandwidth = 100 kHz Gain of 100 → Bandwidth = 10 kHz","7-frequency-response-and-bandwidth#7. Frequency Response and Bandwidth":"","71-open-loop-frequency-response#7.1 Open-Loop Frequency Response":"Real op-amps have frequency-dependent gain:\nA(jω)=A01+jωω0A(j\\omega) = \\frac{A_0}{1 + j\\frac{\\omega}{\\omega_0}}A(jω)=1+jω0​ω​A0​​Where:\nA0A_0A0​ = DC gain ω0=2πf0\\omega_0 = 2\\pi f_0ω0​=2πf0​ = break frequency Bode Plot Characteristics:\nFlat response up to f0f_0f0​ -20 dB/decade rolloff above f0f_0f0​ -90° phase shift at high frequencies","72-closed-loop-bandwidth#7.2 Closed-Loop Bandwidth":"fCL=ftACLf_{CL} = \\frac{f_t}{A_{CL}}fCL​=ACL​ft​​Example (LM741):\nftf_tft​ = 1 MHz For ACLA_{CL}ACL​ = 10: fCLf_{CL}fCL​ = 100 kHz For ACLA_{CL}ACL​ = 100: fCLf_{CL}fCL​ = 10 kHz","73-stability-considerations#7.3 Stability Considerations":"Phase Margin:\nDifference between phase shift and -180° at unity-gain frequency Must be \u003e45° for stable operation 60° preferred for good transient response\nCompensation:\nInternal compensation (most modern op-amps) External compensation (older designs, high-speed op-amps) Unity-gain stable vs. conditionally stable op-amps","8-practical-limitations-and-imperfections#8. Practical Limitations and Imperfections":"","81-output-voltage-saturation#8.1 Output Voltage Saturation":"Limitation: V−rail+Vsat≤vo≤V+rail−VsatV_{-rail} + V_{sat} \\leq v_o \\leq V_{+rail} - V_{sat}V−rail​+Vsat​≤vo​≤V+rail​−Vsat​Typical Values:\nStandard op-amps: ±14V\\pm 14V±14V for ±15V\\pm 15V±15V supplies Rail-to-rail op-amps: Within 50-100 mV of rails Effect: Output clips when theoretical voltage exceeds limits","82-slew-rate-limiting#8.2 Slew Rate Limiting":"Definition: SR=∣dvodt∣maxSR = \\left|\\frac{dv_o}{dt}\\right|_{max}SR=​dtdvo​​​max​For sinusoidal output: dvodt=2πfVomcos⁡(2πft)\\frac{dv_o}{dt} = 2\\pi f V_{om} \\cos(2\\pi ft)dtdvo​​=2πfVom​cos(2πft)Maximum occurs at zero crossing: ∣dvodt∣max=2πfVom\\left|\\frac{dv_o}{dt}\\right|_{max} = 2\\pi f V_{om}​dtdvo​​​max​=2πfVom​Distortion occurs when: 2πfVom\u003eSR2\\pi f V_{om} \u003e SR2πfVom​\u003eSRFull-Power Bandwidth: fFP=SR2πVomf_{FP} = \\frac{SR}{2\\pi V_{om}}fFP​=2πVom​SR​Example (LM741, SR = 0.5 V/μs):\nFor 10V peak output: fFP=7.96f_{FP} = 7.96fFP​=7.96 kHz For 1V peak output: fFP=79.6f_{FP} = 79.6fFP​=79.6 kHz","83-offset-voltage-effects#8.3 Offset Voltage Effects":"Input offset voltage creates DC error:\nvo(error)=Voff(1+R2R1)v_o(\\text{error}) = V_{off}(1 + \\frac{R_2}{R_1})vo​(error)=Voff​(1+R1​R2​​)For inverting amplifier, this is multiplied by closed-loop gain.\nCompensation Methods:\nBalancing resistors: Add R3=R1∥R2R_3 = R_1 \\parallel R_2R3​=R1​∥R2​ at noninverting input Offset nulling: Use trim potentiometer on offset null pins AC coupling: Block DC with capacitor (if DC accuracy not needed) Chopper stabilization: Auto-zeroing circuits","84-input-bias-current-effects#8.4 Input Bias Current Effects":"Bias currents through source resistances create offset voltages:\nVerror=IB×RsourceV_{error} = I_B \\times R_{source}Verror​=IB​×Rsource​Minimization:\nUse matched source impedances at both inputs Use FET-input op-amps (pA bias currents vs. nA for BJT) Add compensation resistor at noninverting input","9-advanced-applications#9. Advanced Applications":"","91-instrumentation-amplifier#9.1 Instrumentation Amplifier":"Three op-amp configuration:\nR₁ v₁ --+--/\\/\\/--+-- (+) Op-Amp 1 Out --+ | | | | Rg | +--/\\/\\/-- R₃ --+ +--/\\/\\/--+ | | | | (-) Op-Amp 3 -- vₒ +--/\\/\\/--+ | | | Rg | +--/\\/\\/-- R₄ --+ | | | v₂ --+--/\\/\\/--+-- (+) Op-Amp 2 Out --+ R₂ Gain: Av=(1+2R1Rg)R4R3A_v = \\left(1 + \\frac{2R_1}{R_g}\\right)\\frac{R_4}{R_3}Av​=(1+Rg​2R1​​)R3​R4​​For matched resistors: Av=(1+2RRg)A_v = \\left(1 + \\frac{2R}{R_g}\\right)Av​=(1+Rg​2R​)Advantages:\nVery high input impedance (both inputs) Excellent CMRR (\u003e100 dB) Single resistor sets gain Differential input, single-ended output Applications:\nBiomedical instrumentation (ECG, EEG) Strain gauge amplifiers Bridge amplifiers Precision measurement systems","92-active-filters#9.2 Active Filters":"","93-precision-rectifiers#9.3 Precision Rectifiers":"","94-comparators#9.4 Comparators":"v₁ ---|+)|\\ | \\ | \u003e---- vₒ (\\pmVsat) | / v₂ ---|-)/ Operation:\nNo feedback (open-loop) Output saturates to +Vsat or -Vsat Fast switching between rails Output: vo={+Vsatif v+\u003ev−−Vsatif v+\u003cv−v_o = \\begin{cases} +V_{sat} \u0026 \\text{if } v_+ \u003e v_- \\\\ -V_{sat} \u0026 \\text{if } v_+ \u003c v_- \\end{cases}vo​={+Vsat​−Vsat​​if v+​\u003ev−​if v+​\u003cv−​​\nApplications:\nLevel detection Zero-crossing detection Analog-to-digital conversion Waveform generation Schmitt Trigger (with hysteresis):\nAdd positive feedback Creates two threshold voltages Prevents oscillation from noise Upper threshold: VTHV_{TH}VTH​ Lower threshold: VTLV_{TL}VTL​ Hysteresis: VTH−VTLV_{TH} - V_{TL}VTH​−VTL​","95-oscillators#9.5 Oscillators":"","96-logarithmic-amplifier#9.6 Logarithmic Amplifier":"Uses diode or transistor in feedback path to create logarithmic transfer function:\nvo=−Kln⁡(vinVref)v_o = -K \\ln\\left(\\frac{v_{in}}{V_{ref}}\\right)vo​=−Kln(Vref​vin​​)\nApplications:\nCompression of wide dynamic range signals Multiplication/division (log of product = sum of logs) Power measurement in dB","97-sample-and-hold-circuit#9.7 Sample and Hold Circuit":"S (switch) vᵢₙ ------o/o------+------|+)|\\ | | \\---- vₒ --- | \u003e --- C +--|-)/ | | |/ | | --- +----+ Operation:\nSwitch closed: Capacitor charges to input voltage Switch open: Capacitor holds voltage Buffer prevents discharge Applications:\nAnalog-to-digital conversion Peak detection Signal processing","band-pass-filter#Band-Pass Filter":"Cascade low-pass and high-pass filters, or use multiple feedback topology.\nCenter frequency: f0=12πRCf_0 = \\frac{1}{2\\pi RC}f0​=2πRC1​\nQuality factor (Q): Q=f0BWQ = \\frac{f_0}{BW}Q=BWf0​​\nWhere BW is the bandwidth between -3 dB points.","closed-loop-gain--or-#Closed-Loop Gain ( or )":"Complete Operational Amplifier Reference GuideA comprehensive reference covering op-amp theory, configurations, analysis methods, and practical applications.\nTable of Contents Introduction to Operational Amplifiers Ideal vs Real Op-Amp Characteristics Fundamental Op-Amp Concepts Analysis Methodology Standard Op-Amp Configurations Understanding Gain Frequency Response and Bandwidth Practical Limitations and Imperfections Advanced Applications Problem-Solving Guide Quick Reference Tables 1. Introduction to Operational Amplifiers 1.1 What is an Operational Amplifier? An operational amplifier (op-amp) is a high-gain differential amplifier designed as an integrated circuit (IC). The name derives from its historical use in analog computers to perform mathematical operations: addition, subtraction, integration, differentiation, and more.\n1.2 Op-Amp Symbol and Terminals +Vcc (Positive Supply) | v₁ -----|\\ | \\ | \\______ vₒ (Output) | / v₂ -----|/ | -Vee (Negative Supply) v₁ = Noninverting input (+) v₂ = Inverting input (-) Key Terminals:\nNoninverting Input (+): Positive input terminal Inverting Input (-): Negative input terminal Output: Amplified signal output Power Supplies: Typically dual supplies (\\pm15V, \\pm12V, or \\pm5V), though omitted in circuit diagrams for clarity 1.3 Basic Operating Principle The op-amp amplifies the differential voltage between its two inputs:\nvo=AOL(v+−v−)v_o = A_{OL}(v_+ - v_-)vo​=AOL​(v+​−v−​)Where:\nvov_ovo​ = output voltage AOLA_{OL}AOL​ = open-loop gain (very large, typically 10⁵ to 10⁶) v+v_+v+​ = voltage at noninverting input v−v_-v−​ = voltage at inverting input 2. Ideal vs Real Op-Amp Characteristics 2.1 Ideal Op-Amp Properties An ideal operational amplifier has the following characteristics:\nCharacteristic Ideal Value Practical Implication Input Impedance (RinR_{in}Rin​) ∞ (infinite) No current flows into inputs: i+=i−=0i_+ = i_- = 0i+​=i−​=0 Output Impedance (RoutR_{out}Rout​) 0 (zero) Output voltage independent of load Open-Loop Gain (AOLA_{OL}AOL​) ∞ (infinite) With negative feedback: v+=v−v_+ = v_-v+​=v−​ Bandwidth ∞ (infinite) No frequency limitations Common-Mode Gain 0 (zero) Perfect rejection of common-mode signals Slew Rate ∞ (infinite) Instantaneous output changes possible Offset Voltage 0 (zero) Zero output when inputs are equal Two Golden Rules for Ideal Op-Amps (with negative feedback):\nVoltage Rule: The voltages at both input terminals are equal v+=v−v_+ = v_-v+​=v−​ Current Rule: No current flows into or out of either input terminal i+=0andi−=0i_+ = 0 \\quad \\text{and} \\quad i_- = 0i+​=0andi−​=0 2.2 Real Op-Amp Imperfections Linear Range Imperfections Finite Open-Loop Gain\nTypical range: 10⁴ to 10⁶ (80-120 dB) Still large enough that ideal approximation works well Finite Input Impedance\nTypical: 1-10 MΩ (BJT inputs) Very high for FET inputs: \u003e10¹² Ω Nonzero Output Impedance\nTypical: 50-100 Ω Reduced by negative feedback Limited Bandwidth\nGain decreases at higher frequencies Characterized by gain-bandwidth product (GBW) Nonlinear Limitations Output Voltage Swing (Saturation)\nOutput cannot exceed power supply voltages Typical range: ±14V\\pm 14V±14V for ±15V\\pm 15V±15V supplies Causes clipping when exceeded Slew Rate Limitation SR=∣dvodt∣maxSR = \\left|\\frac{dv_o}{dt}\\right|_{max}SR=​dtdvo​​​max​ Maximum rate of output voltage change Typical: 0.5 V/μs (LM741) to 1000 V/μs (high-speed op-amps) Causes distortion at high frequencies/amplitudes Full-Power Bandwidth fFP=SR2πVomf_{FP} = \\frac{SR}{2\\pi V_{om}}fFP​=2πVom​SR​ Maximum frequency for full-amplitude sinusoidal output Limited by slew rate DC Imperfections (Offsets) Input Bias Current (IBI_BIB​) IB=IB++IB−2I_B = \\frac{I_{B+} + I_{B-}}{2}IB​=2IB+​+IB−​​ DC current into input terminals Typical: 80 nA (BJT), \u003c1 pA (FET) Input Offset Current (IoffI_{off}Ioff​) Ioff=IB+−IB−I_{off} = I_{B+} - I_{B-}Ioff​=IB+​−IB−​ Difference between bias currents Typical: 20 nA (BJT) Input Offset Voltage (VoffV_{off}Voff​)\nEquivalent DC voltage that causes nonzero output when inputs grounded Typical: 1-5 mV 3. Fundamental Op-Amp Concepts 3.1 Differential and Common-Mode Signals Any two input voltages can be decomposed into differential and common-mode components:\nDifferential Signal (vidv_{id}vid​ or vdv_dvd​) vid=v+−v−v_{id} = v_+ - v_-vid​=v+​−v−​ The signal of interest in most applications Op-amps are designed to amplify this component Represents the actual information being processed Common-Mode Signal (vicmv_{icm}vicm​ or vcmv_{cm}vcm​) vicm=v++v−2v_{icm} = \\frac{v_+ + v_-}{2}vicm​=2v+​+v−​​ The average of both inputs Usually represents unwanted noise (e.g., 60 Hz power line interference) Ideal op-amps completely reject this component Example: In ECG measurements, the heart signal is differential while power line noise appears as common-mode interference.\n3.2 Common-Mode Rejection Ratio (CMRR) CMRR=∣Ad∣∣Acm∣=Differential GainCommon-Mode Gain\\text{CMRR} = \\frac{|A_d|}{|A_{cm}|} = \\frac{\\text{Differential Gain}}{\\text{Common-Mode Gain}}CMRR=∣Acm​∣∣Ad​∣​=Common-Mode GainDifferential Gain​ Measures ability to reject common-mode signals Expressed in decibels: CMRRdB=20log⁡(CMRR)\\text{CMRR}_{\\text{dB}} = 20 \\log(\\text{CMRR})CMRRdB​=20log(CMRR) Typical values: 80-120 dB Higher is better Practical Significance: A CMRR of 100 dB means the differential signal is amplified 100,000 times more than the common-mode signal.\n3.3 Virtual Ground and Virtual Short Virtual Short When negative feedback is present, the infinite open-loop gain forces: v+=v−v_+ = v_-v+​=v−​This is called a “virtual short” because the voltages are equal, but no current flows between the terminals (unlike a real short circuit).\nVirtual Ground When the noninverting input is grounded (v+=0Vv_+ = 0Vv+​=0V): v−=v+=0Vv_- = v_+ = 0Vv−​=v+​=0VThe inverting input is at ground potential but cannot sink or source current. It’s “virtually” at ground.\n3.4 Negative vs Positive Feedback Negative Feedback Output signal fed back to inverting input (−) Opposes the input signal Stabilizes the circuit in linear region Enables predictable, controlled gain Required for linear amplification Positive Feedback Output fed back to noninverting input (+) Reinforces the input signal Causes saturation (output goes to rail) Used in comparators, oscillators, Schmitt triggers Summing-point constraint does not apply 4. Analysis Methodology 4.1 The Summing-Point Constraint Method When an op-amp has negative feedback, use the summing-point constraint:\nTwo Key Constraints:\nVoltage Constraint (Virtual Short) v−=v+v_- = v_+v−​=v+​ Current Constraint (Virtual Open) i−=0andi+=0i_- = 0 \\quad \\text{and} \\quad i_+ = 0i−​=0andi+​=0 4.2 Step-by-Step Analysis Procedure Step 1: Verify Negative Feedback Check that output connects to inverting input (−) If positive feedback present, summing-point constraint cannot be used Circuit will saturate (not operate linearly) Step 2: Apply Summing-Point Constraint Set v+=v−v_+ = v_-v+​=v−​ Set i+=0i_+ = 0i+​=0 and i−=0i_- = 0i−​=0 Step 3: Apply Circuit Analysis Techniques Primary Method: Nodal Analysis (KCL)\nWrite KCL equation at inverting input node Most efficient because iop−amp=0i_{op-amp} = 0iop−amp​=0 Example: “Current in = Current out” Secondary Method: Voltage Division\nUsed for noninverting configurations Analyze voltage divider in feedback network Supporting Tool: Ohm’s Law\nCalculate currents through resistors: i=v1−v2Ri = \\frac{v_1 - v_2}{R}i=Rv1​−v2​​ Use node voltages from constraints When Needed: Mesh Analysis (KVL)\nOccasionally needed for output voltage Usually nodal analysis is sufficient 4.3 Detailed KCL Application At the Inverting Node:\nAll currents entering the node must equal currents leaving: ∑iin=∑iout\\sum i_{in} = \\sum i_{out}∑iin​=∑iout​Since iop−amp=0i_{op-amp} = 0iop−amp​=0, all current through input resistors must flow through feedback elements.\nExample Steps:\nIdentify all resistors connected to inverting node Write current expression for each: i=vfrom−vtoRi = \\frac{v_{from} - v_{to}}{R}i=Rvfrom​−vto​​ Apply KCL: sum of currents = 0 Solve for output voltage 5. Standard Op-Amp Configurations 5.1 Inverting Amplifier R₁ R₂ vᵢₙ ----/\\/\\/----+----/\\/\\/---- vₒ | | (-)|\\ | | \\ | 0V --|+) \u003e-------+ | / |/ Analysis:\nv+=0Vv_+ = 0Vv+​=0V (grounded) v−=v+=0Vv_- = v_+ = 0Vv−​=v+​=0V (virtual ground) KCL at inverting node: i1=i2i_1 = i_2i1​=i2​ vinR1=0−voR2=−voR2\\frac{v_{in}}{R_1} = \\frac{0 - v_o}{R_2} = -\\frac{v_o}{R_2}R1​vin​​=R2​0−vo​​=−R2​vo​​ Characteristics:\nAv=vovin=−R2R1A_v = \\frac{v_o}{v_{in}} = -\\frac{R_2}{R_1}Av​=vin​vo​​=−R1​R2​​ Property Value Voltage Gain −R2R1-\\frac{R_2}{R_1}−R1​R2​​ Phase Shift 180° (inverted) Input Impedance R1R_1R1​ Output Impedance ~0 Ω (ideal) Minimum Gain \u003c1 (can attenuate) Key Features:\nNegative gain (output inverted) Input impedance determined by R1R_1R1​ Can have gain magnitude \u003c1 Most common configuration 5.2 Noninverting Amplifier R₂ +----/\\/\\/----+ | | vᵢₙ ---|+)|\\ | | \\ | +-|-) \u003e------+---- vₒ | | / | |/ | +----/\\/\\/---- 0V R₁ Analysis:\nv+=vinv_+ = v_{in}v+​=vin​ v−=v+=vinv_- = v_+ = v_{in}v−​=v+​=vin​ (constraint) Voltage divider: v−=vo⋅R1R1+R2v_- = v_o \\cdot \\frac{R_1}{R_1 + R_2}v−​=vo​⋅R1​+R2​R1​​ vin=vo⋅R1R1+R2v_{in} = v_o \\cdot \\frac{R_1}{R_1 + R_2}vin​=vo​⋅R1​+R2​R1​​ Characteristics:\nAv=vovin=1+R2R1A_v = \\frac{v_o}{v_{in}} = 1 + \\frac{R_2}{R_1}Av​=vin​vo​​=1+R1​R2​​ Property Value Voltage Gain 1+R2R11 + \\frac{R_2}{R_1}1+R1​R2​​ Phase Shift 0° (non-inverted) Input Impedance ∞ (ideal) Output Impedance ~0 Ω (ideal) Minimum Gain 1 (unity gain) Key Features:\nPositive gain (output in phase) Very high input impedance Minimum gain of 1 Ideal voltage amplifier 5.3 Voltage Follower (Buffer) vᵢₙ ---|+)|\\ | \\ +--|-) \u003e---- vₒ | | / | |/ | +--------+ Special case of noninverting amplifier where R2=0R_2 = 0R2​=0 and R1=∞R_1 = ∞R1​=∞\nCharacteristics:\nAv=1A_v = 1Av​=1 vo=vinv_o = v_{in}vo​=vin​ Property Value Voltage Gain 1 (unity) Phase Shift 0° Input Impedance ∞ (ideal) Output Impedance ~0 Ω (ideal) Applications:\nImpedance matching Buffering signals to prevent loading Isolation between stages Current amplification 5.4 Summing Amplifier Rₐ vₐ ----/\\/\\/----+ | Rf Rᵦ |----/\\/\\/---- vₒ vᵦ ----/\\/\\/----+ | | | Rᴄ | (-)|\\ vᴄ ----/\\/\\/----+ | \\ 0V --|+) \u003e-------+ | / |/ Analysis:\nv−=0Vv_- = 0Vv−​=0V (virtual ground) KCL: iA+iB+iC=ifi_A + i_B + i_C = i_fiA​+iB​+iC​=if​ vARA+vBRB+vCRC=−voRf\\frac{v_A}{R_A} + \\frac{v_B}{R_B} + \\frac{v_C}{R_C} = -\\frac{v_o}{R_f}RA​vA​​+RB​vB​​+RC​vC​​=−Rf​vo​​ General Formula:\nvo=−(RfRAvA+RfRBvB+RfRCvC+⋯ )v_o = -\\left(\\frac{R_f}{R_A}v_A + \\frac{R_f}{R_B}v_B + \\frac{R_f}{R_C}v_C + \\cdots\\right)vo​=−(RA​Rf​​vA​+RB​Rf​​vB​+RC​Rf​​vC​+⋯)For n inputs:\nvo=−∑i=1nRfRiviv_o = -\\sum_{i=1}^{n} \\frac{R_f}{R_i}v_ivo​=−i=1∑n​Ri​Rf​​vi​Special Cases:\nEqual resistors (RA=RB=RC=RfR_A = R_B = R_C = R_fRA​=RB​=RC​=Rf​): vo=−(vA+vB+vC)v_o = -(v_A + v_B + v_C)vo​=−(vA​+vB​+vC​) Weighted summer: Different resistor ratios give different weights Applications:\nAudio mixing Digital-to-analog conversion (DAC) Signal combining Analog computation 5.5 Difference Amplifier (Subtractor) R₁ R₂ v₁ ----/\\/\\/----+----/\\/\\/---- vₒ | | (-)|\\ | | \\ | +---|+) \u003e-------+ | | / R₃ | |/ v₂ ---/\\/\\/--+ | +----/\\/\\/---- 0V R₄ Analysis:\nVoltage divider at v+v_+v+​: v+=v2⋅R4R3+R4v_+ = v_2 \\cdot \\frac{R_4}{R_3 + R_4}v+​=v2​⋅R3​+R4​R4​​ v−=v+v_- = v_+v−​=v+​ (constraint) KCL at inverting node: v1−v−R1=v−−voR2\\frac{v_1 - v_-}{R_1} = \\frac{v_- - v_o}{R_2}R1​v1​−v−​​=R2​v−​−vo​​ General Formula:\nvo=v2(R4R3+R4)(1+R2R1)−v1(R2R1)v_o = v_2\\left(\\frac{R_4}{R_3 + R_4}\\right)\\left(1 + \\frac{R_2}{R_1}\\right) - v_1\\left(\\frac{R_2}{R_1}\\right)vo​=v2​(R3​+R4​R4​​)(1+R1​R2​​)−v1​(R1​R2​​)For matched resistors (R1=R3R_1 = R_3R1​=R3​ and R2=R4R_2 = R_4R2​=R4​):\nvo=R2R1(v2−v1)v_o = \\frac{R_2}{R_1}(v_2 - v_1)vo​=R1​R2​​(v2​−v1​)Applications:\nDifferential signal amplification Common-mode rejection Bridge amplifiers Instrumentation systems 5.6 Integrator R C vᵢₙ ----/\\/\\/----+----||---- vₒ | | (-)|\\ | | \\ | 0V --|+) \u003e-----+ | / |/ Analysis:\nv−=0Vv_- = 0Vv−​=0V (virtual ground) iR=vinRi_R = \\frac{v_{in}}{R}iR​=Rvin​​ (current through resistor) iC=CdvCdt=−Cdvodti_C = C\\frac{dv_C}{dt} = -C\\frac{dv_o}{dt}iC​=CdtdvC​​=−Cdtdvo​​ (capacitor current) iR=iCi_R = i_CiR​=iC​ (KCL) Transfer Function:\nvo(t)=−1RC∫0tvin(τ)dτ+vo(0)v_o(t) = -\\frac{1}{RC}\\int_0^t v_{in}(\\tau)d\\tau + v_o(0)vo​(t)=−RC1​∫0t​vin​(τ)dτ+vo​(0)For DC input (vin=VDCv_{in} = V_{DC}vin​=VDC​):\nvo(t)=−VDCRCt+vo(0)v_o(t) = -\\frac{V_{DC}}{RC}t + v_o(0)vo​(t)=−RCVDC​​t+vo​(0)Frequency Domain:\nH(jω)=VoVin=−1jωRCH(j\\omega) = \\frac{V_o}{V_{in}} = -\\frac{1}{j\\omega RC}H(jω)=Vin​Vo​​=−jωRC1​Characteristics:\nTime constant: τ=RC\\tau = RCτ=RC Phase shift: -90° Gain increases at lower frequencies (1/f response) Output is ramp for DC input, phase-shifted sine for AC input Applications:\nWaveform generation Analog computation Signal processing Control systems Practical Considerations:\nDC input causes output to saturate (add resistor in parallel with C) Reset switch often needed to discharge capacitor 5.7 Differentiator C R vᵢₙ ----||-------+----/\\/\\/---- vₒ | | (-)|\\ | | \\ | 0V --|+) \u003e-------+ | / |/ Analysis:\nv−=0Vv_- = 0Vv−​=0V (virtual ground) iC=Cdvindti_C = C\\frac{dv_{in}}{dt}iC​=Cdtdvin​​ (capacitor current) iR=−voRi_R = -\\frac{v_o}{R}iR​=−Rvo​​ (resistor current) iC=iRi_C = i_RiC​=iR​ (KCL) Transfer Function:\nvo(t)=−RCdvindtv_o(t) = -RC\\frac{dv_{in}}{dt}vo​(t)=−RCdtdvin​​Frequency Domain:\nH(jω)=−jωRCH(j\\omega) = -j\\omega RCH(jω)=−jωRCCharacteristics:\nTime constant: τ=RC\\tau = RCτ=RC Phase shift: +90° Gain increases at higher frequencies Output is spike for step input, phase-shifted sine for AC input Applications:\nEdge detection Rate-of-change measurement High-pass filtering Waveform shaping Practical Considerations:\nVery sensitive to high-frequency noise (amplifies noise) Usually requires input filtering (add series resistor with C) Limited practical use compared to integrator 6. Understanding Gain 6.1 Voltage Gain Fundamentals Voltage gain (AvA_vAv​) is the ratio of output voltage to input voltage:\nAv=vovinA_v = \\frac{v_o}{v_{in}}Av​=vin​vo​​For ideal linear amplifier: vo(t)=Av⋅vin(t)v_o(t) = A_v \\cdot v_{in}(t)vo​(t)=Av​⋅vin​(t)Key Points:\nGain can be positive (noninverting) or negative (inverting) Magnitude indicates amplification factor Sign indicates phase relationship 6.2 Complex Gain (Frequency-Dependent) For sinusoidal signals, gain is a complex quantity:\nAv(jω)=VoVin=∣Av∣ejϕA_v(j\\omega) = \\frac{V_o}{V_{in}} = |A_v|e^{j\\phi}Av​(jω)=Vin​Vo​​=∣Av​∣ejϕWhere:\n∣Av∣|A_v|∣Av​∣ = magnitude (amplification factor) ϕ\\phiϕ = phase shift Magnitude and Phase: ∣Av∣=Re(Av)2+Im(Av)2|A_v| = \\sqrt{\\text{Re}(A_v)^2 + \\text{Im}(A_v)^2}∣Av​∣=Re(Av​)2+Im(Av​)2​ ϕ=tan⁡−1(Im(Av)Re(Av))\\phi = \\tan^{-1}\\left(\\frac{\\text{Im}(A_v)}{\\text{Re}(A_v)}\\right)ϕ=tan−1(Re(Av​)Im(Av​)​)6.3 Gain in Decibels (dB) Decibels provide logarithmic representation of gain:\nAv∣dB=20log⁡10∣Av∣A_v|_{\\text{dB}} = 20\\log_{10}|A_v|Av​∣dB​=20log10​∣Av​∣Conversion Table:\nVoltage Gain dB Gain 0.001 -60 dB 0.01 -40 dB 0.1 -20 dB 0.707 (1/21/\\sqrt{2}1/2​) -3 dB 1 0 dB 2 +6 dB 10 +20 dB 100 +40 dB 1000 +60 dB Key Relationships:\nUnity gain (gain = 1): 0 dB Half-power point (gain = 0.707): -3 dB Decade increase (gain \\times10): +20 dB Double gain (gain \\times2): +6 dB Advantages of dB:\nMultiplication becomes addition: Atotal=A1×A2A_{total} = A_1 \\times A_2Atotal​=A1​×A2​ → AdB=A1,dB+A2,dBA_{dB} = A_{1,dB} + A_{2,dB}AdB​=A1,dB​+A2,dB​ Easier to plot wide ranges (Bode plots) Industry standard for specifications 6.4 Open-Loop vs Closed-Loop Gain Open-Loop Gain (AOLA_{OL}AOL​ or A0A_0A0​) Gain without feedback Very large: 10⁵ to 10⁶ (100-120 dB) Frequency-dependent Unstable and impractical for most applications Closed-Loop Gain (ACLA_{CL}ACL​ or AvA_vAv​) Gain with negative feedback Determined by external resistors Predictable and stable Much smaller than open-loop gain Relationship: ACL=AOL1+AOLβA_{CL} = \\frac{A_{OL}}{1 + A_{OL}\\beta}ACL​=1+AOL​βAOL​​Where β\\betaβ is the feedback factor.\nFor large AOLA_{OL}AOL​: ACL≈1βA_{CL} \\approx \\frac{1}{\\beta}ACL​≈β1​This is why closed-loop gain depends only on resistor ratios, not op-amp parameters.","common-mode-signal--or-#Common-Mode Signal ( or )":"","complete-operational-amplifier-reference-guide#Complete Operational Amplifier Reference Guide":"","dc-imperfections-offsets#DC Imperfections (Offsets)":"","differential-signal--or-#Differential Signal ( or )":"","example-1-basic-inverting-amplifier#Example 1: Basic Inverting Amplifier":"Given: vin=0.5Vv_{in} = 0.5Vvin​=0.5V, R1=10kΩR_1 = 10k\\OmegaR1​=10kΩ, R2=100kΩR_2 = 100k\\OmegaR2​=100kΩ\nFind: vov_ovo​\nSolution: Av=−R2R1=−100k10k=−10A_v = -\\frac{R_2}{R_1} = -\\frac{100k}{10k} = -10Av​=−R1​R2​​=−10k100k​=−10 vo=Av⋅vin=−10×0.5V=−5Vv_o = A_v \\cdot v_{in} = -10 \\times 0.5V = -5Vvo​=Av​⋅vin​=−10×0.5V=−5V\nAnswer: vo=−5Vv_o = -5Vvo​=−5V","example-2-noninverting-amplifier-design#Example 2: Noninverting Amplifier Design":"Design: Noninverting amplifier with gain of 21\nSolution: Av=1+R2R1=21A_v = 1 + \\frac{R_2}{R_1} = 21Av​=1+R1​R2​​=21 R2R1=20\\frac{R_2}{R_1} = 20R1​R2​​=20\nChoose R1=10kΩR_1 = 10k\\OmegaR1​=10kΩ (standard value): R2=20×10k=200kΩR_2 = 20 \\times 10k = 200k\\OmegaR2​=20×10k=200kΩ\nUse R2=200kΩR_2 = 200k\\OmegaR2​=200kΩ (or closest standard value: 220kΩ)\nAnswer: R1=10kΩR_1 = 10k\\OmegaR1​=10kΩ, R2=200kΩR_2 = 200k\\OmegaR2​=200kΩ (or 220kΩ for Av=23A_v = 23Av​=23)","example-3-summing-amplifier#Example 3: Summing Amplifier":"Given: vA=1Vv_A = 1VvA​=1V, vB=2Vv_B = 2VvB​=2V, vC=−1Vv_C = -1VvC​=−1V RA=RB=RC=10kΩR_A = R_B = R_C = 10k\\OmegaRA​=RB​=RC​=10kΩ, Rf=10kΩR_f = 10k\\OmegaRf​=10kΩ\nFind: vov_ovo​\nSolution: vo=−(RfRAvA+RfRBvB+RfRCvC)v_o = -\\left(\\frac{R_f}{R_A}v_A + \\frac{R_f}{R_B}v_B + \\frac{R_f}{R_C}v_C\\right)vo​=−(RA​Rf​​vA​+RB​Rf​​vB​+RC​Rf​​vC​) vo=−(10k10k(1)+10k10k(2)+10k10k(−1))v_o = -\\left(\\frac{10k}{10k}(1) + \\frac{10k}{10k}(2) + \\frac{10k}{10k}(-1)\\right)vo​=−(10k10k​(1)+10k10k​(2)+10k10k​(−1)) vo=−(1+2−1)=−2Vv_o = -(1 + 2 - 1) = -2Vvo​=−(1+2−1)=−2V\nAnswer: vo=−2Vv_o = -2Vvo​=−2V","example-4-slew-rate-check#Example 4: Slew Rate Check":"Given: Op-amp with SR=0.5V/μsSR = 0.5V/\\mu sSR=0.5V/μs, f=10kHzf = 10kHzf=10kHz, Vom=10VV_{om} = 10VVom​=10V\nDetermine: Will slew rate limiting occur?\nSolution: Required rate=2πfVom=2π(104)(10)=628,318V/s=0.628V/μs\\text{Required rate} = 2\\pi f V_{om} = 2\\pi(10^4)(10) = 628,318 V/s = 0.628 V/\\mu sRequired rate=2πfVom​=2π(104)(10)=628,318V/s=0.628V/μs Since 0.628\u003e0.5, YES, slew rate limiting will occur\\text{Since } 0.628 \u003e 0.5, \\text{ YES, slew rate limiting will occur}Since 0.628\u003e0.5, YES, slew rate limiting will occur\nAnswer: Slew rate limiting will occur; reduce amplitude or frequency","example-5-bandwidth-calculation#Example 5: Bandwidth Calculation":"Given: ft=1MHzf_t = 1MHzft​=1MHz, ACL=100A_{CL} = 100ACL​=100\nFind: Closed-loop bandwidth\nSolution: fCL=ftACL=1MHz100=10kHzf_{CL} = \\frac{f_t}{A_{CL}} = \\frac{1MHz}{100} = 10kHzfCL​=ACL​ft​​=1001MHz​=10kHz\nAnswer: fCL=10kHzf_{CL} = 10kHzfCL​=10kHz","full-wave-rectifier#Full-Wave Rectifier":"Uses two op-amps for precision full-wave rectification without center-tapped transformer.","half-wave-rectifier#Half-Wave Rectifier":"R₁ vᵢₙ ----/\\/\\/----+ | (-)|\\ D₁ | \\---|\u003e|---+ 0V --|+) \u003e-------+---- vₒ | / | |/ | | +----+ | --- D₂ V | --- Advantages over passive diode:\nEliminates diode voltage drop (0.7V) Works with small signals (\u003c0.7V) Sharp breakpoint at 0V","high-pass-filter#High-Pass Filter":"Simply swap resistors and capacitors from low-pass design.","linear-range-imperfections#Linear Range Imperfections":"","low-pass-filter-sallen-key#Low-Pass Filter (Sallen-Key)":"2nd-order Butterworth: H(s)=Kωc2s2+2ωcs+ωc2H(s) = \\frac{K\\omega_c^2}{s^2 + \\sqrt{2}\\omega_c s + \\omega_c^2}H(s)=s2+2​ωc​s+ωc2​Kωc2​​Cutoff frequency: fc=12πR1R2C1C2f_c = \\frac{1}{2\\pi\\sqrt{R_1 R_2 C_1 C_2}}fc​=2πR1​R2​C1​C2​​1​","negative-feedback#Negative Feedback":"","nonlinear-limitations#Nonlinear Limitations":"","open-loop-gain--or-#Open-Loop Gain ( or )":"","phase-shift-oscillator#Phase-Shift Oscillator":"Uses RC network to create 180° phase shift, combined with inverting amplifier.\nFrequency: f0=12πRC6f_0 = \\frac{1}{2\\pi RC\\sqrt{6}}f0​=2πRC6​1​","positive-feedback#Positive Feedback":"","step-1-verify-negative-feedback#Step 1: Verify Negative Feedback":"","step-2-apply-summing-point-constraint#Step 2: Apply Summing-Point Constraint":"","step-3-apply-circuit-analysis-techniques#Step 3: Apply Circuit Analysis Techniques":"","table-of-contents#Table of Contents":"","type-1-find-output-voltage#Type 1: Find Output Voltage":"Given: Input voltage(s) and resistor values\nMethod:\nApply summing-point constraint to find node voltages Write KCL equation at inverting node Express currents using Ohm’s Law Solve for vov_ovo​ Example: Inverting amplifier with vin=1Vv_{in} = 1Vvin​=1V, R1=10kΩR_1 = 10k\\OmegaR1​=10kΩ, R2=100kΩR_2 = 100k\\OmegaR2​=100kΩ\nSolution: vo=−R2R1vin=−100k10k(1V)=−10Vv_o = -\\frac{R_2}{R_1}v_{in} = -\\frac{100k}{10k}(1V) = -10Vvo​=−R1​R2​​vin​=−10k100k​(1V)=−10V","type-2-design-for-specific-gain#Type 2: Design for Specific Gain":"Given: Required gain AvA_vAv​\nMethod:\nChoose configuration (inverting or noninverting) Select standard resistor values Calculate second resistor from gain formula Example: Design noninverting amplifier with gain = 11\nChoose R1=10kΩR_1 = 10k\\OmegaR1​=10kΩ: Av=1+R2R1A_v = 1 + \\frac{R_2}{R_1}Av​=1+R1​R2​​ 11=1+R210k11 = 1 + \\frac{R_2}{10k}11=1+10kR2​​ R2=100kΩR_2 = 100k\\OmegaR2​=100kΩ","type-3-find-frequency-response#Type 3: Find Frequency Response":"Given: Circuit with reactive elements (C or L)\nMethod:\nReplace reactive elements with impedances: ZC=1jωCZ_C = \\frac{1}{j\\omega C}ZC​=jωC1​, ZL=jωLZ_L = j\\omega LZL​=jωL Apply standard analysis with impedances instead of resistances Express gain as function of frequency: Av(jω)A_v(j\\omega)Av​(jω) Find magnitude and phase Example: Low-pass filter cutoff frequency fc=12πRCf_c = \\frac{1}{2\\pi RC}fc​=2πRC1​","type-4-account-for-real-op-amp-limitations#Type 4: Account for Real Op-Amp Limitations":"Given: Real op-amp parameters\nCheck:\nSaturation: Is ∣vo∣\u003cVsat|v_o| \u003c V_{sat}∣vo​∣\u003cVsat​? Slew rate: Is 2πfVom\u003cSR2\\pi f V_{om} \u003c SR2πfVom​\u003cSR? Bandwidth: Is f\u003cfCLf \u003c f_{CL}f\u003cfCL​? Offset: Calculate DC error from VoffV_{off}Voff​ and IBI_BIB​","virtual-ground#Virtual Ground":"","virtual-short#Virtual Short":"","wien-bridge-oscillator#Wien Bridge Oscillator":"Frequency of oscillation: f0=12πRCf_0 = \\frac{1}{2\\pi RC}f0​=2πRC1​\nGain requirement: Av=3A_v = 3Av​=3\nFeatures:\nLow distortion sine wave Variable frequency by varying R or C Requires amplitude stabilization"},"title":"op_amp_chat2"},"/electrical_notes/ee_302/op_amp_list_chat/":{"data":{"1-inverting-amplifier#1. Inverting Amplifier":"","2-non-inverting-amplifier#2. Non-Inverting Amplifier":"","3-voltage-follower-buffer#3. Voltage Follower (Buffer)":"","4-summing-amplifier-adder#4. Summing Amplifier (Adder)":"","5-differential-amplifier-subtractor#5. Differential Amplifier (Subtractor)":"","6-instrumentation-amplifier#6. Instrumentation Amplifier":"","7-integrator#7. Integrator":"","8-differentiator#8. Differentiator":"","9-active-filters#9. Active Filters":"","additional-amplifier-classifications#Additional Amplifier Classifications":"","advantages-of-active-filters#Advantages of Active Filters":"No inductor required (smaller, cheaper) Gain available in passband Good isolation between stages Adjustable Q and gain Better performance than passive filters","applications#Applications":"Impedance matching and isolation Buffering high-impedance sources Preventing loading effects Driving low-impedance loads","applications-1#Applications":"Audio mixing Digital-to-analog conversion (DAC) Analog signal processing Weighted averaging","applications-2#Applications":"Strain gauge measurements Thermocouple amplification Medical instrumentation (ECG, EEG) Industrial process control","applications-3#Applications":"Waveform generation (triangle from square wave) Analog computation Signal processing Active filters","applications-4#Applications":"Waveshaping Frequency emphasis Edge detection Signal processing","band-pass-filter#Band-Pass Filter":"Passes frequencies within a specific range.","band-reject-notch-filter#Band-Reject (Notch) Filter":"Attenuates frequencies within a specific range.","based-on-inputoutput-impedance#Based on Input/Output Impedance":"Type Input Impedance Output Impedance Input Senses Output Produces Voltage Amplifier Infinite Zero Voltage Voltage Current Amplifier Zero Infinite Current Current Transconductance Amplifier Infinite Infinite Voltage Current Transresistance Amplifier Zero Zero Current Voltage","characteristics#Characteristics":"Gain magnitude controlled by resistor ratio Input impedance equals R1 (relatively low) Phase inversion (180°) Virtual ground at inverting input","characteristics-1#Characteristics":"Always has gain \\geq 1 Very high input impedance No phase inversion Ideal for buffering high-impedance sources","characteristics-2#Characteristics":"Common-mode rejection when properly balanced Used with sensors and measurement systems Can provide gain while subtracting Sensitive to resistor matching","characteristics-3#Characteristics":"Extremely high input impedance Excellent CMRR (\u003e100 dB typical) Low offset and drift Single resistor gain adjustment Ideal for sensor and biomedical applications","characteristics-4#Characteristics":"Output is running time integral of input Phase shift of -90° relative to input Gain increases at low frequencies (1/f response) Susceptible to DC offset and drift May require reset switch across capacitor","characteristics-5#Characteristics":"Output proportional to rate of change of input Phase shift of +90° relative to input Gain increases at high frequencies Amplifies high-frequency noise Often unstable without modifications Usually requires additional resistor in series with C for stability","circuit-configuration#Circuit Configuration":"Input signal applied to inverting terminal (-) through resistor R1 Non-inverting terminal (+) connected to ground Feedback resistor Rf (or R2) from output to inverting input","circuit-configuration-1#Circuit Configuration":"Input signal applied to non-inverting terminal (+) Inverting terminal (-) connected to voltage divider (R1 and R2) Feedback from output through R2 to inverting input","circuit-configuration-2#Circuit Configuration":"Input signal applied to non-inverting terminal (+) Output directly connected to inverting terminal (-) (100% feedback) Equivalent to R2 = 0 and R1 = ∞ in non-inverting configuration","circuit-configuration-3#Circuit Configuration":"Multiple inputs (vA, vB, vC, …) each through input resistors (RA, RB, RC, …) All input resistors connect to inverting terminal (-) Non-inverting terminal (+) grounded Feedback resistor Rf from output to inverting input","circuit-configuration-4#Circuit Configuration":"Input v1 applied to non-inverting terminal (+) through R3 Input v2 applied to inverting terminal (-) through R1 Feedback resistor R2 from output to inverting input R4 from non-inverting terminal to ground","circuit-configuration-5#Circuit Configuration":"Three op-amp design (two input buffers + difference amplifier) Two non-inverting amplifiers as input stage One differential amplifier as output stage Single resistor (RG) sets gain","circuit-configuration-6#Circuit Configuration":"Input through resistor R to inverting terminal (-) Capacitor C in feedback path (instead of resistor) Non-inverting terminal (+) grounded","circuit-configuration-7#Circuit Configuration":"Input through capacitor C to inverting terminal (-) Resistor R in feedback path Non-inverting terminal (+) grounded","common-mode-rejection-ratio-cmrr#Common-Mode Rejection Ratio (CMRR)**":"CMRR=20log⁡10(AdAcm) dBCMRR = 20\\log_{10}\\left(\\frac{A_d}{A_{cm}}\\right) \\text{ dB}CMRR=20log10​(Acm​Ad​​) dBMeasure of ability to reject common-mode signals.","comprehensive-operational-amplifier-circuit-guide#Comprehensive Operational Amplifier Circuit Guide":"Comprehensive Operational Amplifier Circuit Guide","description#Description":"Produces an inverted and amplified version of the input signal. The output is 180° out of phase with the input.","description-1#Description":"Produces an amplified version of the input signal with no phase inversion. Output is in phase with input.","description-2#Description":"A special case of the non-inverting amplifier with unity gain (Av = +1). Provides impedance transformation without gain.","description-3#Description":"A special type of inverting amplifier that produces an output equal to the weighted sum of multiple input voltages. Can have two or more inputs.","description-4#Description":"Amplifies the difference between two input signals while rejecting common-mode signals. Fundamental op-amp operation.","description-5#Description":"A specialized, high-performance differential amplifier with very high input impedance, high common-mode rejection ratio (CMRR), and adjustable gain.","description-6#Description":"Performs mathematical integration of the input signal with respect to time. Output voltage is proportional to the time integral of the input.","description-7#Description":"Performs mathematical differentiation of the input signal. Output voltage is proportional to the rate of change of the input.","description-8#Description":"Filters built using op-amps, resistors, and capacitors that actively shape frequency response. Offer superior performance compared to passive RC filters.","fundamental-analysis-principle-summing-point-constraint#Fundamental Analysis Principle: Summing-Point Constraint":"Due to infinite open-loop gain and negative feedback:\nv+ \\approx v- (differential input voltage \\approx 0) i+ = i- = 0 (no current flows into input terminals)","gain-bandwidth-product-gbw#Gain-Bandwidth Product (GBW)":"GBW=Av⋅f−3dB=constantGBW = A_v \\cdot f_{-3dB} = \\text{constant}GBW=Av​⋅f−3dB​=constantAs closed-loop gain increases, bandwidth decreases proportionally.","general-output-equation#General Output Equation":"vo=AOL(v+−v−)v_o = A_{OL}(v_+ - v_-)vo​=AOL​(v+​−v−​)Where:\nvo = output voltage AOL = open-loop gain (typically 10⁵ to 10⁶) v+ = voltage at non-inverting input v- = voltage at inverting input","high-pass-filter#High-Pass Filter":"Passes high frequencies, attenuates low frequencies.\nFirst-Order Transfer Function: H(s)=A0⋅s/ωc1+s/ωcH(s) = \\frac{A_0 \\cdot s/\\omega_c}{1 + s/\\omega_c}H(s)=1+s/ωc​A0​⋅s/ωc​​","ideal-op-amp-characteristics#Ideal Op-Amp Characteristics":"Infinite input impedance (Zin = ∞): No current flows into the input terminals Infinite open-loop gain (AOL = ∞): Amplifies differential input voltage to maximum Zero output impedance (Zout = 0): Can drive any load without voltage drop Zero gain for common-mode signals: Rejects signals common to both inputs Infinite bandwidth: Responds equally to all frequencies","input-offset-voltage#Input Offset Voltage":"Small DC voltage that appears at output even with zero input. Can be nulled using trim potentiometer.","introduction#Introduction":"An operational amplifier (op-amp) is a high-gain differential amplifier that amplifies the difference between two input signals. Op-amps are versatile building blocks in analog electronics, historically used to perform mathematical operations such as addition, subtraction, integration, and differentiation in analog computers.","key-equations#Key Equations":"Closed-Loop Voltage Gain: Av=−RfR1=−R2R1A_v = -\\frac{R_f}{R_1} = -\\frac{R_2}{R_1}Av​=−R1​Rf​​=−R1​R2​​Output Voltage: vo=−RfR1⋅vinv_o = -\\frac{R_f}{R_1} \\cdot v_{in}vo​=−R1​Rf​​⋅vin​Input Impedance: Zin=R1Z_{in} = R_1Zin​=R1​Output Impedance: Zout≈0Z_{out} \\approx 0Zout​≈0","key-equations-1#Key Equations":"Closed-Loop Voltage Gain: Av=1+R2R1=1+RfR1A_v = 1 + \\frac{R_2}{R_1} = 1 + \\frac{R_f}{R_1}Av​=1+R1​R2​​=1+R1​Rf​​Output Voltage: vo=(1+R2R1)⋅vinv_o = \\left(1 + \\frac{R_2}{R_1}\\right) \\cdot v_{in}vo​=(1+R1​R2​​)⋅vin​Input Impedance: Zin≈∞Z_{in} \\approx \\inftyZin​≈∞ (very high, typically MΩ range)\nOutput Impedance: Zout≈0Z_{out} \\approx 0Zout​≈0","key-equations-2#Key Equations":"Voltage Gain: Av=+1A_v = +1Av​=+1Output Voltage: vo=vinv_o = v_{in}vo​=vin​Input Impedance: Zin≈∞Z_{in} \\approx \\inftyZin​≈∞ (extremely high)\nOutput Impedance: Zout≈0Z_{out} \\approx 0Zout​≈0 (extremely low)","key-equations-3#Key Equations":"Output Voltage (General): vo=−(RfRAvA+RfRBvB+RfRCvC+...)v_o = -\\left(\\frac{R_f}{R_A}v_A + \\frac{R_f}{R_B}v_B + \\frac{R_f}{R_C}v_C + ...\\right)vo​=−(RA​Rf​​vA​+RB​Rf​​vB​+RC​Rf​​vC​+...)Two-Input Summer: vo=−(RfRAvA+RfRBvB)v_o = -\\left(\\frac{R_f}{R_A}v_A + \\frac{R_f}{R_B}v_B\\right)vo​=−(RA​Rf​​vA​+RB​Rf​​vB​)Equal Resistors (Averaging): If RA = RB = RC = … = Rf: vo=−(vA+vB+vC+...)v_o = -(v_A + v_B + v_C + ...)vo​=−(vA​+vB​+vC​+...)Weighted Average: If RA = RB = RC = … = R and Rf = R/n: vo=−1n(vA+vB+...+vn)v_o = -\\frac{1}{n}(v_A + v_B + ... + v_n)vo​=−n1​(vA​+vB​+...+vn​)","key-equations-4#Key Equations":"Output Voltage (Matched Resistors): When R4/R3 = R2/R1: vo=R2R1(v1−v2)v_o = \\frac{R_2}{R_1}(v_1 - v_2)vo​=R1​R2​​(v1​−v2​)Differential Gain: Ad=R2R1A_d = \\frac{R_2}{R_1}Ad​=R1​R2​​General Output (Unmatched Resistors): vo=(1+R2R1)R4R3+R4v1−R2R1v2v_o = \\left(1 + \\frac{R_2}{R_1}\\right)\\frac{R_4}{R_3 + R_4}v_1 - \\frac{R_2}{R_1}v_2vo​=(1+R1​R2​​)R3​+R4​R4​​v1​−R1​R2​​v2​Matching Condition for Pure Subtraction: R4R3=R2R1\\frac{R_4}{R_3} = \\frac{R_2}{R_1}R3​R4​​=R1​R2​​","key-equations-5#Key Equations":"Voltage Gain: Av=1+2RRGA_v = 1 + \\frac{2R}{R_G}Av​=1+RG​2R​Where R is the matched input stage resistors and RG is the gain-setting resistor.\nOutput Voltage: vo=Av(v1−v2)v_o = A_v(v_1 - v_2)vo​=Av​(v1​−v2​)Input Impedance: Zin≈∞Z_{in} \\approx \\inftyZin​≈∞ (extremely high, typically GΩ range)","key-equations-6#Key Equations":"Output Voltage: vo(t)=−1RC∫0tvin(τ) dτ+vo(0)v_o(t) = -\\frac{1}{RC}\\int_0^t v_{in}(\\tau) \\, d\\tau + v_o(0)vo​(t)=−RC1​∫0t​vin​(τ)dτ+vo​(0)Transfer Function (Frequency Domain): H(jω)=Vo(jω)Vin(jω)=−1jωRCH(j\\omega) = \\frac{V_o(j\\omega)}{V_{in}(j\\omega)} = -\\frac{1}{j\\omega RC}H(jω)=Vin​(jω)Vo​(jω)​=−jωRC1​For Constant Input: vo(t)=−vinRC⋅t+vo(0)v_o(t) = -\\frac{v_{in}}{RC} \\cdot t + v_o(0)vo​(t)=−RCvin​​⋅t+vo​(0)Time Constant: τ=RC\\tau = RCτ=RC","key-equations-7#Key Equations":"Output Voltage: vo(t)=−RCdvin(t)dtv_o(t) = -RC \\frac{dv_{in}(t)}{dt}vo​(t)=−RCdtdvin​(t)​Transfer Function (Frequency Domain): H(jω)=Vo(jω)Vin(jω)=−jωRCH(j\\omega) = \\frac{V_o(j\\omega)}{V_{in}(j\\omega)} = -j\\omega RCH(jω)=Vin​(jω)Vo​(jω)​=−jωRCTime Constant: τ=RC\\tau = RCτ=RC","low-pass-filter#Low-Pass Filter":"Passes low frequencies, attenuates high frequencies.\nFirst-Order Transfer Function: H(s)=A01+s/ωcH(s) = \\frac{A_0}{1 + s/\\omega_c}H(s)=1+s/ωc​A0​​Where ωc = cutoff frequency = 1/RC","operational-transconductance-amplifier-ota#Operational Transconductance Amplifier (OTA)":"A special op-amp that accepts input voltage and produces output current.\nKey Characteristic: iout=gm⋅vini_{out} = g_m \\cdot v_{in}iout​=gm​⋅vin​Where gm is transconductance (typically adjustable)\nProperties:\nVery large output impedance (ideally infinite) Output current independent of load Used in voltage-controlled amplifiers and filters Common in analog synthesizers","practical-considerations#Practical Considerations":"","sallen-key-topology#Sallen-Key Topology":"A popular second-order active filter configuration:\nCutoff Frequency: fc=12πR1R2C1C2f_c = \\frac{1}{2\\pi\\sqrt{R_1R_2C_1C_2}}fc​=2πR1​R2​C1​C2​​1​Quality Factor (Q): Q=R1R2C1C2C2(R1+R2)Q = \\frac{\\sqrt{R_1R_2C_1C_2}}{C_2(R_1 + R_2)}Q=C2​(R1​+R2​)R1​R2​C1​C2​​​","saturation-and-clipping#Saturation and Clipping":"Output voltage is limited by supply voltages: VEE\u003cvo\u003cVCCV_{EE} \u003c v_o \u003c V_{CC}VEE​\u003cvo​\u003cVCC​Typically: vo(max) \\approx VCC - 1V to 2V (depending on op-amp type)","slew-rate#Slew Rate":"Maximum rate of change of output voltage: SR=dvodt∣maxSR = \\frac{dv_o}{dt}\\Big|_{max}SR=dtdvo​​​max​ (typically in V/μs)\nLimits high-frequency, large-amplitude operation.","summary#Summary":"Operational amplifiers are fundamental building blocks enabling:\nPrecision amplification with controlled gain Mathematical operations (sum, difference, integration, differentiation) Active filtering and signal conditioning Impedance transformation and buffering High-performance instrumentation Understanding these configurations and their equations is essential for analog circuit design and analysis.","types#Types":""},"title":"op_amp_list_chat"},"/electrical_notes/ee_302/op_amp_list_nblm/":{"data":{"how-operational-amplifiers-work-ideal-and-general-principles#How Operational Amplifiers Work (Ideal and General Principles)":"The operational amplifier operates as a differential amplifier. When ideal, it has the following characteristics:\nInfinite input impedances. This means the input current for both terminals is zero. Infinite gain for the differential input signal (open-loop gain, AOLA_{OL}AOL​). Zero gain for the common-mode input signal. Zero output impedance. Infinite bandwidth. Because the open-loop gain is ideally infinite, when negative feedback is applied, a very tiny input voltage difference is needed to produce the required output voltage. This leads to the fundamental analysis tool known as the summing-point constraint: the differential input voltage and the input current of the op-amp are assumed to be forced to zero.\nIn reality, op-amps have finite characteristics (e.g., gain is 10510^5105 to 10610^6106). The output voltage is restricted by the biasing voltages applied to the op-amp. If the input signal is too large, the output will reach saturation limits (clipping) near the positive or negative supply voltages (VCCV_{CC}VCC​ and VEEV_{EE}VEE​).\nThe output voltage (vov_ovo​) is equal to the open-loop gain (AOLA_{OL}AOL​) multiplied by the difference between the input signals (v1−v2v_1 - v_2v1​−v2​): vo=AOL(v1−v2)v_o = A_{OL}(v_1 - v_2) \\text{}vo​=AOL​(v1​−v2​)In practical circuits using negative feedback, a fraction of the output is returned to the inverting input terminal, forcing the differential input voltage toward zero. If the op-amp uses the non-inverting terminal, the output is in phase with the input. If the op-amp uses the inverting terminal, the output is inverted by 180 degrees with respect to the input.","ideal-amplifier-classifications-based-on-impedance#Ideal Amplifier Classifications (Based on Impedance)":"Amplifiers are often characterized by how they handle input and output impedance, leading to four ideal classifications:\nIdeal Voltage Amplifier: Has infinite input impedance and zero output impedance. It senses the open-circuit voltage of the source and produces an amplified voltage across the load regardless of load impedance. Ideal Current Amplifier: Has zero input impedance and infinite output impedance. It senses the short-circuit current of the source and forces an amplified version of this current to flow through the load. Ideal Transconductance Amplifier: Has infinite input impedance and infinite output impedance. It senses the open-circuit voltage of the source and forces a proportional current through the load. Ideal Transresistance Amplifier: Has zero input impedance and zero output impedance. It senses the short-circuit current of the source and causes a proportional voltage across the load.","instrumentation-amplifiers#Instrumentation Amplifiers":"The instrumentation amplifier is a specific, high-performance differential amplifier. It is used in practical cases dealing with very small input voltages coming from sensors. The main advantage of this amplifier is its very high input impedance, which is particularly useful when working with sensors.","list-of-operational-amplifier-op-amp-types-and-configurations#List of Operational Amplifier (Op-Amp) Types and Configurations":"List of Operational Amplifier (Op-Amp) Types and Configurations inverting non-inverting voltage follower differential amplifier instrumentation amplifier summing amplifier integrator The sources describe Operational Amplifiers (op-amps) primarily through their characteristics and the common circuit configurations built using them.","operational-transconductance-amplifier-ota#Operational Transconductance Amplifier (OTA)":"The OTA is a special type of op-amp that functions as a transconductance amplifier. It accepts input voltage and produces output current. The primary characteristic distinguishing it from an ideal op-amp voltage amplifier is its very large output resistance (ideally infinite).","specialized-and-ideal-amplifier-types#Specialized and Ideal Amplifier Types":"","types-and-applications-of-operational-amplifier-circuits#Types and Applications of Operational Amplifier Circuits":"An operational amplifier is fundamentally a High Gain differential amplifier that amplifies the difference between two input signals. Historically, op-amps were used in analog-computer circuits to perform mathematical operations such as addition, subtraction, integration, and differentiation.\nOp-amps are almost always used with negative feedback, where part of the output signal is returned to the input in opposition to the source signal. This configuration allows for predictable and controlled circuit behavior.\nThe sources extensively detail the following types of op-amp circuit configurations:\nOp-Amp Type/Configuration Purpose/Use How It Works (Principle/Gain) Inverting Amplifier (Basic Inverter) Used to produce an output signal that is an inverted version of the input waveform. The output is 180 degrees out of phase with the input signal. The input is applied to the inverting terminal (’-’). Its closed-loop voltage gain (AvA_vAv​) is derived using a feedback resistor (RfR_fRf​ or R2R_2R2​) and input resistor (R1R_1R1​). For an ideal op-amp, Av=−R2/R1A_v = -R_2/R_1Av​=−R2​/R1​. Noninverting Amplifier Used to produce an output signal that is a noninverting version of the input waveform. The output signal is in phase with the input signal. The input signal is applied to the non-inverting terminal (’+’). The closed-loop voltage gain is determined by resistors R1R_1R1​ and R2R_2R2​. For an ideal op-amp, Av=1+R2/R1A_v = 1 + R_2/R_1Av​=1+R2​/R1​. Differential Amplifier (Subtractor) Performs subtraction/amplification of the difference between two input signals (v1v_1v1​ and v2v_2v2​). Widely used in engineering instrumentation, including along with sensors. Ideally, the output voltage is proportional to the difference between the input voltages (v1−v2v_1 - v_2v1​−v2​) multiplied by a differential gain (AdA_dAd​). Output voltage vov_ovo​ is proportional to (v1−v2)R2/R1(v_1 - v_2)R_2/R_1(v1​−v2​)R2​/R1​, assuming R4/R3=R2/R1R_4/R_3 = R_2/R_1R4​/R3​=R2​/R1​. Summing Amplifier (Summer) Used to create an output voltage that is a weighted sum of multiple input voltages. It is a special type of inverting amplifier. The output voltage is given by vo=−(Rf/RA)vA−(Rf/RB)vBv_o = -(R_f/R_A)v_A - (R_f/R_B)v_Bvo​=−(Rf​/RA​)vA​−(Rf​/RB​)vB​. Voltage Follower Provides unity voltage gain (Av=+1A_v = +1Av​=+1). Often used to achieve high input impedance . A noninverting configuration where typically R2=0R_2 = 0R2​=0 and R1R_1R1​ is an open circuit. Integrator Used to perform integration of the input signal. Produces an output voltage proportional to the running time integral of the input voltage. Differentiator Used to perform differentiation of the input signal. Produces an output voltage proportional to the time derivative of the input voltage. Active Filters Designed to pass input components with frequencies in one range to the output while rejecting components in other ranges. Active filters often have better performance than passive filters. Circuits composed of op-amps, resistors, and capacitors. An active Butterworth lowpass filter can be achieved by cascading several Sallen-Key circuits having the proper gains."},"title":"op_amp_list_nblm"},"/electrical_notes/ee_302/op_amp_nblm2/":{"data":{"":"","1-differential-signal--or-#1. Differential Signal ( or )":"","2-common-mode-signal--or-#2. Common-Mode Signal ( or )":"","common-mode-rejection-ratio-cmrr#Common-Mode Rejection Ratio (CMRR)":"","common-mode-signal-and-differential-signal#Common-Mode Signal and Differential Signal":"","functional-differences-between-non-inverting-and-inverting-op-amp-circuits#Functional Differences Between Non-Inverting and Inverting Op Amp Circuits":"","gain-in-decibels-db#Gain in Decibels (dB)":"Gain magnitudes (or transfer function magnitudes) are frequently expressed in decibels (dB).\nTo convert a transfer function magnitude (or gain magnitude) to decibels, you take 20 times the common logarithm of the magnitude: ∣Av∣dB=20log⁡∣Av∣|A_v|_{\\text{dB}} = 20 \\log |A_v|∣Av​∣dB​=20log∣Av​∣.\nDecibels are particularly advantageous for creating Bode plots, which plot the gain magnitude versus frequency on a logarithmic scale.\nKey relationships concerning decibels include:\nA magnitude of unity gain (∣Av∣=1|A_v| = 1∣Av​∣=1) corresponds to 0 dB. The half-power frequencies (or 3-dB frequencies) are points where the gain magnitude is 1/2≈0.7071/\\sqrt{2} \\approx 0.7071/2​≈0.707 times the midband value, and the gain expressed in decibels is approximately 3 dB lower than the midband gain. Specifications like the Common-Mode Rejection Ratio (CMRR) are also frequently expressed in decibels.","understanding-gain-in-terms-of-voltage-gain-and-db#Understanding Gain in Terms of Voltage Gain and dB":"","voltage-gain-#Voltage Gain ()":"This is a comprehensive overview of the functional differences between non-inverting and inverting operational amplifier (op amp) circuits, the definitions of differential and common-mode signals, and the concept of gain expressed in voltage ratio and decibels.\nFunctional Differences Between Non-Inverting and Inverting Op Amp Circuits Operational amplifiers are fundamentally differential amplifiers that amplify the difference between their two input terminals. They are almost always used with negative feedback. When used in closed-loop configurations with resistive feedback, the primary functional difference lies in the phase relationship between the input and output signals, and the way the voltage gain is calculated.\nFeature Inverting Amplifier Non-Inverting Amplifier Input Connection Applied to the inverting terminal (marked ‘-’). Applied to the non-inverting terminal (marked ‘+’). Gain Polarity Negative voltage gain (AvA_vAv​). Positive voltage gain (AvA_vAv​). Phase Relationship Output waveform is an inverted version (180° phase shift) of the input waveform. Output waveform is in phase (non-inverted) with the input waveform. Closed-Loop Gain (AvA_vAv​) Av=−R2/R1A_v = -R_2/R_1Av​=−R2​/R1​. Av=1+R2/R1A_v = 1 + R_2/R_1Av​=1+R2​/R1​. Input Impedance (Ideal) Equal to the input resistor R1R_1R1​. Infinite (Rin=∞R_{in} = \\inftyRin​=∞). Minimum Gain Can be less than 1 (e.g., -0.5). Unity (minimum gain magnitude is 1), typically implemented as a voltage follower. The negative gain in the inverting configuration means that the output voltage is an inverted version of the input. This may not matter for signals like monaural audio, but it is critical for applications like video signals where inversion leads to a negative image.\nThe non-inverting amplifier, under ideal op amp assumptions, is classified as an ideal voltage amplifier. This is because it theoretically possesses infinite input impedance and zero output impedance.\nCommon-Mode Signal and Differential Signal The operational amplifier is defined as a differential amplifier because its core function is to amplify the difference between its two input terminals. The inputs to a differential amplifier, v1v_1v1​ (non-inverting input) and v2v_2v2​ (inverting input), can be decomposed into a differential signal and a common-mode signal.\n1. Differential Signal (vidv_{id}vid​ or vdv_dvd​) The differential signal is the difference between the two input voltages: vid=v1−v2v_{id} = v_1 - v_2vid​=v1​−v2​.\nIn instrumentation systems, the differential signal is typically the signal of interest. An ideal differential amplifier produces an output voltage proportional only to this differential signal.\n2. Common-Mode Signal (vcmv_{cm}vcm​ or vicmv_{icm}vicm​) The common-mode signal is the average of the input voltages: vicm=12(v1+v2)v_{icm} = \\frac{1}{2}(v_1 + v_2)vicm​=21​(v1​+v2​).\nThe common-mode signal usually represents unwanted noise. For example, when recording an electrocardiogram (ECG), a large 60-Hz common-mode signal may be present due to the power system ground, even though the desired heart signal is differential.\nAn ideal op amp has zero gain for the common-mode input signal. Real differential amplifiers, however, respond to both signals.\nCommon-Mode Rejection Ratio (CMRR) The effectiveness of a differential amplifier in rejecting the unwanted common-mode signal is quantified by the Common-Mode Rejection Ratio (CMRR). The CMRR is defined as the ratio of the magnitude of the differential gain (AdA_dAd​) to the magnitude of the common-mode gain (AcmA_{cm}Acm​): CMRR=∣Ad∣∣Acm∣\\text{CMRR} = \\frac{|A_d|}{|A_{cm}|}CMRR=∣Acm​∣∣Ad​∣​.\nA large CMRR is critical when amplifying a small differential signal in the presence of a strong common-mode interfering signal.\nUnderstanding Gain in Terms of Voltage Gain and dB Voltage Gain (AvA_vAv​) Voltage gain is a fundamental characteristic of an amplifier. Ideally, an amplifier produces an output signal with the identical waveshape as the input signal, but with a larger amplitude.\nThe voltage gain (AvA_vAv​) is the constant that relates the output voltage vo(t)v_o(t)vo​(t) to the input voltage vi(t)v_i(t)vi​(t): vo(t)=Avvi(t)v_o(t) = A_v v_i(t)vo​(t)=Av​vi​(t).\nWhen analyzing signals that vary with frequency (sinusoidal input signals), the more general definition is complex gain. Complex voltage gain (AvA_vAv​) is defined as the ratio of the phasor for the output signal (VoV_oVo​) to the phasor for the input signal (ViV_iVi​): Av=VoViA_v = \\frac{V_o}{V_i}Av​=Vi​Vo​​.\nComplex gain is a complex quantity that includes both magnitude and phase."},"title":"op_amp_nblm2"},"/electrical_notes/ee_302/op_amp_notebooklm/":{"data":{"":"This documentation is designed to provide a comprehensive understanding of operational amplifier (op-amp) circuits, assuming foundational knowledge of basic circuit analysis techniques such as Ohm’s Law, Kirchhoff’s Current Law (KCL), and Kirchhoff’s Voltage Law (KVL), along with familiarity with nonlinear circuit elements like diodes, clippers, and clamps.\nOp-amps simplify circuit analysis considerably when used with negative feedback, allowing us to move away from the complex graphical or assumed-state analysis required for highly non-linear components like diodes and transistors.","1-voltage-constraint-virtual-short-circuit#1. Voltage Constraint (Virtual Short Circuit)":"Because the differential gain (AOLA_{OL}AOL​) is infinite, any tiny differential input voltage (vidv_{id}vid​) would drive the output to saturation unless vidv_{id}vid​ is forced to zero. vinverting=vnoninvertingv_{inverting} = v_{noninverting}vinverting​=vnoninverting​ This means the voltage at the inverting terminal is mathematically equal to the voltage at the noninverting terminal. If the noninverting terminal is grounded, the inverting terminal is considered a “virtual ground” (i.e., at 0 V).","2-current-constraint-virtual-open-circuit#2. Current Constraint (Virtual Open Circuit)":"Since the input impedance (RinR_{in}Rin​) is infinite, no current flows into the input terminals. iinverting=0andinoninverting=0i_{inverting} = 0 \\quad \\text{and} \\quad i_{noninverting} = 0iinverting​=0andinoninverting​=0","a-introduction-to-operational-amplifiers#A. Introduction to Operational Amplifiers":"An operational amplifier (op-amp) is fundamentally a differential amplifier designed as an integrated circuit (IC). They originated historically in analog computing circuits to perform mathematical functions like addition, subtraction, integration, and differentiation—hence the name.\nThe op-amp amplifies the difference between its two input signals. It typically uses dual power supplies (VCCV_{CC}VCC​ and VEEV_{EE}VEE​), often ±15V\\pm 15\\text{V}±15V, though these connections are frequently omitted from circuit diagrams for simplicity.","a-the-summing-point-constraint-ideal-assumption#A. The Summing-Point Constraint (Ideal Assumption)":"When analyzing an ideal op-amp circuit with negative feedback, we apply the summing-point constraint. This constraint simplifies the circuit model greatly by replacing the infinite gain property with two simple conditions:","b-characteristics-of-an-ideal-operational-amplifier#B. Characteristics of an Ideal Operational Amplifier":"To simplify analysis, op-amps are often modeled as ideal operational amplifiers. An ideal op amp has the following key characteristics:\nCharacteristic Ideal Value Implication for Analysis Input Impedance (RinR_{in}Rin​) Infinite (∞\\infty∞) Input currents (i+i_+i+​ and i−i_-i−​) are zero. Differential Voltage Gain (AOLA_{OL}AOL​) Infinite (∞\\infty∞) In negative feedback, the differential input voltage (vidv_{id}vid​) is forced to zero. Common-Mode Voltage Gain Zero The amplifier perfectly rejects common-mode noise. Output Impedance (RoutR_{out}Rout​) Zero (0) The output voltage is independent of the load resistance. Bandwidth Infinite Supports all frequencies without gain reduction. Slew Rate (SR) Infinite Instantaneous change in output voltage is possible. Output Offset Voltage Zero Zero output voltage when the input voltages are zero.","b-step-by-step-procedure-for-solving-ideal-op-amp-circuits#B. Step-by-Step Procedure for Solving Ideal Op-Amp Circuits":"Given the prerequisites (understanding of KCL, KVL, and Ohm’s Law), solving op-amp circuits involves three systematic steps:","c-characteristics-of-real-operational-amplifiers-imperfections#C. Characteristics of Real Operational Amplifiers (Imperfections)":"While the ideal model is used for design and basic circuit analysis, real op amps exhibit several limitations, especially in the linear range and under large-signal/high-frequency conditions.","dc-imperfections-offsets#DC Imperfections (Offsets)":"These factors introduce an undesirable DC voltage component added to the intended output signal.\nInput Bias Current (IBI_BIB​): DC current that flows into (or from) the input terminals. Input Offset Current (IoffI_{off}Ioff​): The difference between the two bias currents (Ioff=IB+−IB−I_{off} = I_{B+} - I_{B-}Ioff​=IB+​−IB−​). Input Offset Voltage (VoffV_{off}Voff​): A small DC source in series with one input terminal that models why the output is non-zero even when inputs are grounded.","example-1-the-basic-inverting-amplifier#Example 1: The Basic Inverting Amplifier":"The inverting amplifier configuration applies the input signal (vinv_{in}vin​) to the inverting terminal through resistor R1R_1R1​, while the noninverting terminal is grounded. Negative feedback is applied through resistor R2R_2R2​ connecting the output (vov_ovo​) back to the inverting input.\nAnalysis using Summing-Point Constraint and KCL:\nSet Constraints:\nThe noninverting terminal is grounded: vnoninverting=0 Vv_{noninverting} = 0\\text{ V}vnoninverting​=0 V. By Constraint 1: vinverting=vnoninverting=0 Vv_{inverting} = v_{noninverting} = 0\\text{ V}vinverting​=vnoninverting​=0 V (virtual ground). By Constraint 2: iop−amp=0i_{op-amp} = 0iop−amp​=0. Apply KCL at the Inverting Node (vinvertingv_{inverting}vinverting​): The current from the input (i1i_1i1​) must flow through the feedback path (i2i_2i2​), as no current enters the op amp terminal (iop−amp=0i_{op-amp} = 0iop−amp​=0). i1=i2i_1 = i_2i1​=i2​ Apply Ohm’s Law to define currents:\nInput Current (i1i_1i1​): Flows from vinv_{in}vin​ to the virtual ground (0 V0\\text{ V}0 V). i1=vin−0R1=vinR1i_1 = \\frac{v_{in} - 0}{R_1} = \\frac{v_{in}}{R_1}i1​=R1​vin​−0​=R1​vin​​ Feedback Current (i2i_2i2​): Flows from the virtual ground (0 V0\\text{ V}0 V) to the output (vov_ovo​). i2=0−voR2=−voR2i_2 = \\frac{0 - v_o}{R_2} = - \\frac{v_o}{R_2}i2​=R2​0−vo​​=−R2​vo​​ Solve for Gain (Av=vo/vinA_v = v_o/v_{in}Av​=vo​/vin​): Substitute current expressions into the KCL equation (i1=i2i_1 = i_2i1​=i2​): vinR1=−voR2\\frac{v_{in}}{R_1} = - \\frac{v_o}{R_2}R1​vin​​=−R2​vo​​ vovin=−R2R1\\frac{v_o}{v_{in}} = - \\frac{R_2}{R_1}vin​vo​​=−R1​R2​​ Resulting Characteristics:\nClosed-Loop Voltage Gain (AvA_vAv​): Av=−R2/R1A_v = -R_2/R_1Av​=−R2​/R1​. Phase: Inverting (negative sign indicates 180∘180^\\circ180∘ phase shift). Input Impedance: Rin=R1R_{in} = R_1Rin​=R1​ (since the inverting node is at virtual ground). Output Impedance (Ideal): Rout=0R_{out} = 0Rout​=0.","example-2-the-basic-noninverting-amplifier#Example 2: The Basic Noninverting Amplifier":"The noninverting amplifier applies the input signal (vinv_{in}vin​) directly to the noninverting terminal. The feedback is a voltage divider composed of R1R_1R1​ (to ground) and R2R_2R2​ (from output to inverting terminal).\nAnalysis using Summing-Point Constraint and KVL/Voltage Division:\nSet Constraints:\nThe noninverting terminal voltage is vinv_{in}vin​. By Constraint 1: vinverting=vnoninverting=vinv_{inverting} = v_{noninverting} = v_{in}vinverting​=vnoninverting​=vin​. By Constraint 2: The current flowing into the inverting node (iii_iii​) is zero. Apply Voltage Division to the Feedback Network: Because ii=0i_i = 0ii​=0, the voltage divider formed by R1R_1R1​ and R2R_2R2​ is isolated. The voltage across R1R_1R1​ is vinvertingv_{inverting}vinverting​ (which is constrained to be vinv_{in}vin​). We apply the voltage division principle to find vinv_{in}vin​ in terms of vov_ovo​: vin=vinverting=vo(R1R1+R2)v_{in} = v_{inverting} = v_{o} \\left( \\frac{R_1}{R_1 + R_2} \\right)vin​=vinverting​=vo​(R1​+R2​R1​​) Solve for Gain (Av=vo/vinA_v = v_o/v_{in}Av​=vo​/vin​): Rearranging the equation yields the closed-loop gain: vovin=1+R2R1\\frac{v_o}{v_{in}} = 1 + \\frac{R_2}{R_1}vin​vo​​=1+R1​R2​​ Resulting Characteristics:\nClosed-Loop Voltage Gain (AvA_vAv​): Av=1+R2/R1A_v = 1 + R_2/R_1Av​=1+R2​/R1​. Phase: Noninverting (positive gain). Input Impedance (Ideal): Rin=∞R_{in} = \\inftyRin​=∞ (because the input current is zero). Output Impedance (Ideal): Rout=0R_{out} = 0Rout​=0.","example-3-the-summing-amplifier#Example 3: The Summing Amplifier":"A summing amplifier is a variation of the inverting amplifier used to combine multiple input signals, vAv_AvA​ and vBv_BvB​, each fed through its own resistor (RAR_ARA​ and RBR_BRB​) to the inverting input node.\nAnalysis using Summing-Point Constraint and KCL:\nSet Constraints: vinverting=0 Vv_{inverting} = 0\\text{ V}vinverting​=0 V and iop−amp=0i_{op-amp} = 0iop−amp​=0.\nApply KCL at the Inverting Node (Summing Point): The sum of input currents (iA+iBi_A + i_BiA​+iB​) must flow through the feedback path (ifi_fif​), since iop−amp=0i_{op-amp} = 0iop−amp​=0. iA+iB=ifi_A + i_B = i_fiA​+iB​=if​ (Note: Directions usually define iA,iBi_A, i_BiA​,iB​ entering, ifi_fif​ leaving)\nApply Ohm’s Law: iA=vARA,iB=vBRB,if=0−voRf=−voRfi_A = \\frac{v_A}{R_A}, \\quad i_B = \\frac{v_B}{R_B}, \\quad i_f = \\frac{0 - v_o}{R_f} = - \\frac{v_o}{R_f}iA​=RA​vA​​,iB​=RB​vB​​,if​=Rf​0−vo​​=−Rf​vo​​ Solve for vov_ovo​: vARA+vBRB=−voRf\\frac{v_A}{R_A} + \\frac{v_B}{R_B} = - \\frac{v_o}{R_f}RA​vA​​+RB​vB​​=−Rf​vo​​ vo=−(RfRAvA+RfRBvB)v_o = - \\left( \\frac{R_f}{R_A} v_A + \\frac{R_f}{R_B} v_B \\right)vo​=−(RA​Rf​​vA​+RB​Rf​​vB​) This configuration acts as a linear weighted summer or adder.","input-signal-components#Input Signal Components":"The two input voltages (v1v_1v1​ and v2v_2v2​) can be decomposed into two components:\nDifferential Signal (vidv_{id}vid​): The difference between the inputs: vid=v1−v2v_{id} = v_1 - v_2vid​=v1​−v2​. Common-Mode Signal (vicmv_{icm}vicm​): The average of the inputs: vicm=12(v1+v2)v_{icm} = \\frac{1}{2}(v_1 + v_2)vicm​=21​(v1​+v2​). The output voltage (vov_ovo​) is proportional to the differential signal multiplied by the open-loop gain (AOLA_{OL}AOL​): vo=AOL(v1−v2)v_o = A_{OL}(v_1 - v_2)vo​=AOL​(v1​−v2​).","linear-range-imperfections#Linear Range Imperfections":"Finite Open-Loop Gain (A0OLA_{0OL}A0OL​): Real gain is large but finite (typically 10410^4104 to 10610^6106). Finite Bandwidth: The gain magnitude reduces at higher frequencies. The product of DC gain and bandwidth is constant (ft=A0OLfBOLf_t = A_{0OL} f_{BOL}ft​=A0OL​fBOL​), known as the unity-gain–bandwidth. Finite Input Impedance and Nonzero Output Impedance.","nonlinear-limitations#Nonlinear Limitations":"Output Voltage Swing: The output voltage is strictly limited by the power supply voltages, leading to clipping if the ideal output exceeds these limits (e.g., typically ±14V\\pm 14\\text{V}±14V for ±15V\\pm 15\\text{V}±15V supplies). Slew-Rate (SR) Limitation: The maximum rate of change of the output voltage is finite (e.g., 0.5 V/μs0.5\\text{ V}/\\mu\\text{s}0.5 V/μs for the LM741). If the required rate of output change is 2πfVom2\\pi f V_{om}2πfVom​ (for a sine wave) and this exceeds SR, the output will distort, often becoming a triangular wave. The Full-Power Bandwidth (fFPf_{FP}fFP​) is the highest frequency at which the op amp can produce a full-amplitude sinusoidal output without distortion due to slew-rate limiting.","part-i-operational-amplifier-circuit-theory-and-characteristics#Part I: Operational Amplifier Circuit Theory and Characteristics":"","part-ii-methodologies-for-solving-op-amp-problems#Part II: Methodologies for Solving Op-Amp Problems":"Op-amps are highly stable and predictable when configured with negative feedback, where a portion of the output signal is fed back to the inverting terminal to oppose the source signal. This configuration forces the op amp to operate in its linear region, allowing for straightforward analysis.","part-iii-theoretical-examples-of-op-amp-circuits#Part III: Theoretical Examples of Op-Amp Circuits":"","step-1-verify-negative-feedback#Step 1: Verify Negative Feedback":"Check that part of the output signal is returned to the inverting input terminal. If positive feedback is present (output returned to the noninverting terminal), the circuit will typically saturate, and the summing-point constraint cannot be used.","step-2-apply-the-summing-point-constraint#Step 2: Apply the Summing-Point Constraint":"Set the differential input voltage and input currents to zero based on the ideal op-amp properties derived above.","step-3-apply-standard-circuit-analysis-principles#Step 3: Apply Standard Circuit Analysis Principles":"Use KCL, KVL, and Ohm’s Law to solve for the currents and voltages of interest.\nFocus on KCL/KVL Setup (Step 3 Details):\nNodal Analysis (KCL) is Primary: Due to the zero-current constraint, KCL applied at the inverting input node (vinvertingv_{inverting}vinverting​) is often the fastest method. The current entering the node must equal the current leaving the node (and the current into the op amp is zero). Example (Inverting node): If currents i1i_1i1​ and ifi_fif​ enter the inverting node and current iop−ampi_{op-amp}iop−amp​ flows into the op-amp input: i1+if=iop−ampi_1 + i_f = i_{op-amp}i1​+if​=iop−amp​. Since iop−amp=0i_{op-amp} = 0iop−amp​=0, i1+if=0i_1 + i_f = 0i1​+if​=0, or i1=−ifi_1 = -i_fi1​=−if​. Ohm’s Law Application: Currents are calculated across the external resistors by applying Ohm’s Law (i=v/Ri = v/Ri=v/R), using the node voltages established by the constraints. Example (Current through resistor R connecting vAv_AvA​ to vinvertingv_{inverting}vinverting​): i=(vA−vinverting)/Ri = (v_A - v_{inverting})/Ri=(vA​−vinverting​)/R. Loop Analysis (KVL) for Output: KVL may be necessary to define the output voltage (vov_ovo​) based on the voltage drop across the feedback elements, although nodal analysis usually yields vov_ovo​ directly. Example (Feedback loop): In the basic inverter, KVL around the loop including the output, the feedback resistor R2R_2R2​, and the inverting input node (if grounded) yields vo+R2if=0v_o + R_2 i_f = 0vo​+R2​if​=0."},"title":"op_amp_notebooklm"},"/electrical_notes/ee_302/sample_vega_graph/":{"data":{"":"The following is a sample vega script that wil render a basic graph with two black lines. This gives the illusion of a graph with the normal 4 quadrants with (0,0) being at the center becuase I cannot change where the axis starts in vega.\nVega Graph Axis Documentation"},"title":"sample_vega_graph"}}